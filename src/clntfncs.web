@q clntfncs.web  @>
@q [...]/Finston/gwrdifpk/src/clntfncs.web  @>

@q Created by Laurence D. Finston (LDF) Fri Jul 20 11:20:03 CEST 2012  @>

@q * (1) Copyright and License.@>

@q This file is part of gwrdifpk, a package for long-term archiving.  @>
@q Copyright (C) 2013, 2014 Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen @>

@q gwrdifpk is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q gwrdifpk is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License          @>
@q along with gwrdifpk; if not, write to the Free Software                    @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q gwrdifpk is available for downloading via Git from @>
@q https://github.com/gwdg/gwrdifpk.git    @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gwdg.de@>

@q Laurence D. Finston                                                   @>
@q Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen  @>
@q Am Fassberg 11         					         @>
@q 37077 Goettingen              					 @>
@q Germany                           					 @>                                

@q Laurence.Finston@@gwdg.de (@@ stands for a single "at" sign.)@>



@q * (1) Client functions.  @>
@ Client functions.  
\initials{LDF 2012.07.20.}

\LOG
\initials{LDF 2012.07.20.}
Added this file.  As of this date, it contains only the definition of 
|client_func|, which I've moved from \filename{gwirdcli.web}.  This is
so that \.{irods\_fcgi} can call |client_func|:  Since \filename{gwirdcli.web}
contains a main function, \filename{irods\_fcgi.o} can't be linked with 
\filename{gwirdcli.o}.
\ENDLOG

@q * (1) Include files  @>

@ Include files.

@<Include files@>=

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <sys/types.h>
#include <pwd.h>
#include <errno.h>
#include <grp.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <dirent.h>
#include <fcntl.h>

#include <gcrypt.h> /* for |gcry_control| */
#include <gnutls/gnutls.h>
#include<gnutls/x509.h>

#include <string>
#include <iomanip>
#include <ios>
#include <iostream>
#include <stdarg.h>
#include <limits.h>
#include <algorithm>
#include <fstream>
#include <iterator>
#include <time.h>
#include <math.h>
#include <sstream>   

#include <map>
#include <vector>
#include <stack>
#include <deque>
#include <set>

#include <pthread.h>

#include <expat.h>

#if HAVE_CONFIG_H
#include "config.h"
#endif

#include <mysql.h>

#undef NAME_LEN
#undef LOCAL_HOST

#include "glblcnst.h++"
#include "glblvrbl.h++"
#include "excptntp.h++"
#include "helper.h++"
#include "utilfncs.h++"
#include "grouptp.h++"
#include "hndlvltp.h++"
#include "irdsavtp.h++"
#include "prsrclnt.h++"  
#include "scnrclnt.h++"
#include "rspnstp.h++"
#include "irdsobtp.h++"
#include "hndltype.h++"
#include "dcmdsbtp.h++"
#include "dcmtdttp.h++"
#include "x509cert.h++"
#include "dstngnmt.h++"
#include "pullrqtp.h++"
#include "scprpmtp.h++"
#include "exchnsrv.h++"
#include "usrinftp.h++"

#include "gntlsfnc.h++"
#include "ex_rfc2818.h++"

@q ** (2) Client function (|client_func|).  @>
@ Client function (|client_func|).  
\initials{LDF 2012.07.20.}

|main| of \.{gwirdcli} is simply a wrapper for this function.
\initials{LDF 2012.07.20.}

\LOG
\initials{LDF 2012.07.20.}
Added this function.
\ENDLOG

The argument |bool strm_val| to |output_func| is needed because FastCGI 
changes |stdout| and |stderr| so that output is written to places appropriate 
to a web application.  That is, output to |stdout| is sent back to the HTTP client 
(e.g., the browser or \.{curl}) and output to |stderr| is written to the error file 
\filename{/var/log/apache2/error\_log}.
\par
However, this function is meant to be used both by the web application
\.{irods\_fcgi} and the ``normal'' client application \.{gwirdcli}.  The output
must therefore be handled differently, depending on which program is calling
this function.
\initials{LDF 2012.07.20.}
\par
@:NOTE@> !! PLEASE NOTE:  FastCGI (as a C library) does not redirect output 
written to the \CPLUSPLUS/ streams |cout| and |cerr|!
\initials{LDF 2013.05.31.}

@q *** (3) Declaration @>

@<|client_func| declaration@>=
int
client_func (Scan_Parse_Parameter_Type &param);

@q *** (3) Definition  @>
@
@<|client_func| definition@>=
int
client_func (Scan_Parse_Parameter_Type &param)
{
@q **** (4) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG, 0, 0);

    int status;

    char c;

    stringstream temp_strm;

    gnutls_certificate_credentials_t xcred;

    User_Info_Type user_info;
    string distinguished_name_str;

@q **** (4) @>

@ |strm_val| is passed to |output_func| as an argument.  If it's |true|, 
|stderr| or |cerr| is used instead of |stdout| or |cout|.  
@:NOTE@> !! PLEASE NOTE:  FastCGI redefines |stdout| and |stderr| to write to 
places appropriate for a web application.  It {\it does not\/}, however, redefine
|cout| or |cerr|, since it is a \CEE/ library and not a \CPLUSPLUS/ one and therefore
doesn't ``know'' about |ostreams|.
\par
For non-web applications, I generally prefer to write output to |cerr| to make it possible to 
use the application as a ``filter'':  In that case, I would use |cout| for output intended for
use as input by another application.
\par
This function is called both by \.{gwrdwbap.fcgi} and \.{gwirdcli}, so I have to use a variable 
(here |strm_val|) to ensure that the output goes to |stdout| for the former and |cerr| 
for the latter.
\initials{LDF 2012.07.27.}


@<|client_func| definition@>=

    bool strm_val = is_gwirdcli;  

@q **** (4) @>
@
@<|client_func| definition@>=

    string thread_str;

    temp_strm << "[Thread " << param.thread_ctr << "] ";
    thread_str = temp_strm.str();
    temp_strm.str("");


#if DEBUG_COMPILE
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_str << "Entering `client_func'." 
             << endl 
             << "remote_connection == " << remote_connection
             << endl 
             << "anonymous         == " << anonymous
             << endl
             << "`is_gwirdpcl'     == " << is_gwirdpcl
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
     

@q **** (4) @>
@
@<|client_func| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `client_func':"
            << endl
            << "`gpg_homedir' == " << gpg_homedir
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q **** (4) Remote connection, anonymous authentication.  @>

@ Remote connection, anonymous authentication.  
\initials{LDF 2012.09.20.}

\LOG
\initials{LDF 2012.09.20.}
Added this section.
\ENDLOG

@<|client_func| definition@>=

    gnutls_anon_client_credentials_t anoncred;
    gnutls_global_init();

    if (remote_connection == true && anonymous == true)
    {

@q ***** (5) @>

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            temp_strm.str("");
            temp_strm << "In `client_func':  `remote_connection' == `true' and " 
                      << "`anonymous' == `true'."
                      << endl;
            cerr << temp_strm.str();
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

@ |Scan_Parse_Parameter_Type::remote_connection| and
|Scan_Parse_Parameter_Type::anonymous| are really only used by the server
program \.{gwirdsif}, so these assignments are redundant.  For the client \.{gwirdcli}, the
global variables |remote_connection| and |anonymous| can be used, since a client only has a
single connection to a server. However, it's less confusing if
|param->remote_connection| and |param->anonymous| are also set to |true| in this case.  
\initials{LDF 2012.09.20.}

@<|client_func| definition@>=

        param.remote_connection = true;  
        param.anonymous = true;  

@q ***** (5) @>
@
@<|client_func| definition@>=

        int ret, ii;

        /* Need to enable anonymous KX specifically. */

        gnutls_anon_allocate_client_credentials (&anoncred);

        /* Initialize TLS session */
        gnutls_init (&param.session, GNUTLS_CLIENT);

        /* Use default priorities */

        gnutls_priority_set_direct (param.session, "PERFORMANCE:+ANON-DH:!ARCFOUR-128", NULL);

        /* put the anonymous credentials to the current session */

        gnutls_credentials_set (param.session, GNUTLS_CRD_ANON, anoncred);

        /* connect to the peer  */

        param.sock = tcp_connect(remote_hostname.c_str(), port_str_anon); 

        gnutls_transport_set_ptr (param.session, 
                                  reinterpret_cast<gnutls_transport_ptr_t>(
                                     reinterpret_cast<void*>(param.sock)));

        /* Perform the TLS handshake         */

        ret = gnutls_handshake (param.session);

        if (ret < 0)
        {

             lock_cerr_mutex(); 
             temp_strm.str("");
             temp_strm << thread_str
                       << "ERROR!  In `client_func':"
                       << endl 
                       << "`gnutls_handshake' failed, returning " << ret << ":"
                       << endl
                       << gnutls_strerror(ret)
                       << endl;
             cerr << temp_strm.str();
             unlock_cerr_mutex(); 

             close(param.sock);
             param.sock = 0;
 
             gnutls_deinit (param.session);

             ++param.errors_occurred; 

             return 1;  

        }
#if DEBUG_COMPILE
   
        else if (DEBUG)
        {
             lock_cerr_mutex(); 
             temp_strm.str("");
             temp_strm << thread_str
                       << "In `client_func':"
                       << endl 
                       << "`gnutls_handshake' succeeded."
                       << endl;
             cerr << temp_strm.str();

             cerr << "Printing session info:"
                  << endl;
             print_info(param.session);

             unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    }  /* |if (remote_connection == true && anonymous == true)|  */


@q **** (4) Remote connection with X.509 certificate authentication.  @>

@ Remote connection with X.509 certificate authentication.  
\initials{LDF 2013.05.10.}

@<|client_func| definition@>=

    else if (remote_connection == true && anonymous == false)
    {
@q ***** (5) @>

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            temp_strm.str("");
            temp_strm << thread_str
                      << "In `client_func':"
                      << endl 
                      << "`remote_connection' == `true' and `anonymous' == `false'."
                      << endl;
            cerr << temp_strm.str();
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        int ret, ii;

        const char *err;

        int char_ctr = 0;

@q ***** (5) @>

@ \filename{user\_cert.pem} and \filename{user\_key.pem} may be symbolic links 
to the user's certificate and key, respectively.  Otherwise, the 
command-line options \.{--cert-filename} and \.{--key-filename} should be
used.
\initials{LDF 2013.05.10.}

\LOG
\initials{LDF 2013.07.14.}
Added code for inserting |string config_dir| at the beginning of the paths 
for the various X.509 files.
\ENDLOG

@<|client_func| definition@>=

        if (!config_dir.empty())
        {
            DEFAULT_CERT_FILENAME = DEFAULT_KEY_FILENAME = DEFAULT_CA_FILENAME
              = config_dir;

            DEFAULT_CERT_FILENAME += "/"; 
            DEFAULT_KEY_FILENAME  += "/"; 
            DEFAULT_CA_FILENAME   += "/"; 
        }

        DEFAULT_CERT_FILENAME += "user_cert.pem";  
        DEFAULT_KEY_FILENAME  += "user_key.pem";
        DEFAULT_CA_FILENAME   += "ca_cert.pem";
        DEFAULT_CRL_FILENAME   = "";
  
        string curr_key_filename;
        string curr_cert_filename;
        string curr_ca_filename; 
        string curr_crl_filename;  

        size_t pos;

@q ****** (6) @>

        if (key_filenames.size() == 0)
            curr_key_filename = DEFAULT_KEY_FILENAME;
        else
        {
            curr_key_filename = key_filenames[0];

            if (!config_dir.empty())
            {
                pos = curr_key_filename.find("/");

                if (pos == string::npos)
                {
                    curr_key_filename.insert(0, "/");
                    curr_key_filename.insert(0, config_dir);
                }
            }
        }

@q ****** (6) @>

        if (cert_filenames.size() == 0)
            curr_cert_filename = DEFAULT_CERT_FILENAME;
        else
        {
            curr_cert_filename = cert_filenames[0];

            if (!config_dir.empty())
            {
                pos = curr_cert_filename.find("/");

                if (pos == string::npos)
                {
                    curr_cert_filename.insert(0, "/");
                    curr_cert_filename.insert(0, config_dir);
                }   
            }

        }

@q ****** (6) @>

        if (ca_filenames.size() == 0)
            curr_ca_filename = DEFAULT_CA_FILENAME;
        else
        {
            curr_ca_filename = ca_filenames[0];

            if (!config_dir.empty())
            {
                pos = curr_ca_filename.find("/");

                if (pos == string::npos)
                {
                    curr_ca_filename.insert(0, "/");
                    curr_ca_filename.insert(0, config_dir);
                }   
            }
        }

@q ****** (6) @>

        if (crl_filenames.size() == 0)
            curr_crl_filename = DEFAULT_CRL_FILENAME;
        else
        {
            curr_crl_filename = crl_filenames[0];

            if (!config_dir.empty())
            {
                pos = curr_crl_filename.find("/");

                if (pos == string::npos)
                {
                    curr_crl_filename.insert(0, "/");
                    curr_crl_filename.insert(0, config_dir);
                }   
            }

        }

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "cert_filenames.size() == " << cert_filenames.size() << endl 
                 << "key_filenames.size() ==  " << key_filenames.size() << endl 
                 << "ca_filenames.size() ==   " << ca_filenames.size() << endl 
                 << "curr_key_filename ==     " << curr_key_filename << endl
                 << "curr_cert_filename ==    " << curr_cert_filename << endl
                 << "curr_ca_filename ==      " << curr_ca_filename << endl
                 << "curr_crl_filename ==     " << curr_crl_filename << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        gnutls_certificate_allocate_credentials (&xcred);

        status = gnutls_certificate_set_x509_trust_file (xcred, 
                                                         curr_ca_filename.c_str(), 
                                                         GNUTLS_X509_FMT_PEM);   
  
        stringstream temp_strm; 

        if (status < 0)
        {

            temp_strm.str("");

            temp_strm << "ERROR!  In `client_func':"
                 << endl 
                 << "`gnutls_certificate_set_x509_trust_file' failed returning " 
                 << status 
                 << ":" 
                 << endl;

            lock_cerr_mutex(); 
            cerr << temp_strm.str();
            gnutls_perror(status);
            unlock_cerr_mutex(); 
 
            temp_strm << "Exiting function unsuccessfully "
                      << "with return value 1."
                      << endl;

            lock_cerr_mutex(); 
            cerr << temp_strm.str();
            unlock_cerr_mutex(); 
 
            close(param.sock);
            param.sock = 0;

            gnutls_certificate_free_credentials (xcred);
            gnutls_deinit (param.session);

            ++param.errors_occurred; 

            return 1;

        }
        else if (DEBUG)
        {
            temp_strm.str("");

            temp_strm << "In `client_func':"
                      << endl 
                      << "`gnutls_certificate_set_x509_trust_file' returned " << status 
                      << " (the number of certificates processed)."
                      << endl;

             
            lock_cerr_mutex(); 
            cerr << temp_strm.str();
            unlock_cerr_mutex(); 
 
        }  /* |if (DEBUG)|  */ 

        gnutls_certificate_set_x509_key_file (xcred, 
                                        curr_cert_filename.c_str(), 
                                        curr_key_filename.c_str(),
  					GNUTLS_X509_FMT_PEM);

  
       gnutls_init(&param.session, GNUTLS_CLIENT);  /* Initialize TLS session   */

       ret = gnutls_priority_set_direct(param.session, "PERFORMANCE", &err); 

       if (ret < 0)   
       {

           if (ret == GNUTLS_E_INVALID_REQUEST) 
           {

               temp_strm.str("");

               temp_strm <<  "ERROR!  In `client_func':  Syntax error at " 
                         << err 
                         << endl
                         << "Exiting function unsuccessfully "
                         << "with return value 1."
                         << endl;

               lock_cerr_mutex(); 
               cerr << temp_strm.str();
               unlock_cerr_mutex(); 
 
               close(param.sock);
               param.sock = 0;

               gnutls_certificate_free_credentials (xcred);
               gnutls_deinit (param.session);

               ++param.errors_occurred; 

               return 1;

           }

           /* !! TODO:  What about other cases?  LDF 2010.02.11.*/

       }  /* |if (ret < 0) |  */
  
  status = gnutls_credentials_set (param.session, GNUTLS_CRD_CERTIFICATE, xcred);

  if (status != 0)
  {
      temp_strm.str("");

      temp_strm <<  "ERROR!  In `client_func':  `gnutls_credentials_set' failed, " 
                << "returning " << status
                << endl
                << "Exiting function unsuccessfully "
                << "with return value 1."
                << endl;

      lock_cerr_mutex(); 
      cerr << temp_strm.str();
      unlock_cerr_mutex(); 

      close(param.sock);
      param.sock = 0;
 
      gnutls_deinit (param.session);    

      ++param.errors_occurred; 

      return 1;

  }  /* |if (status != 0)| */

  else if (DEBUG)
  {

      lock_cerr_mutex(); 
      cerr << "In `client_func':  `gnutls_credentials_set' succeeded."
           << endl;
      unlock_cerr_mutex(); 

  }  /* |else if (DEBUG)|  */ 

@q **** (4) Connect to the peer.  @>
@ Connect to the peer.
\initials{LDF 2012.09.21.}

@<|client_func| definition@>=

  param.remote_connection = true;  
  param.anonymous = false;  

  param.sock = tcp_connect (remote_hostname.c_str(), port_str_x_509);

  if (param.sock == -1)
  {

      temp_strm.str("");

      temp_strm <<  "ERROR!  In `client_func':  "
                << "`tcp_connect' failed, returning -1." 
                << endl
                << "Exiting function unsuccessfully "
                << "with return value 1."
                << endl;


      lock_cerr_mutex(); 
      cerr << temp_strm.str();
      unlock_cerr_mutex(); 
 
      close(param.sock);
      param.sock = 0;

      gnutls_certificate_free_credentials (xcred);
      gnutls_deinit (param.session);

      ++param.errors_occurred; 

      return 1;

  }

  gnutls_transport_set_ptr (param.session, reinterpret_cast<gnutls_transport_ptr_t>(param.sock));


  /* Perform the TLS handshake   */

  ret = gnutls_handshake (param.session);

  if (ret < 0)
  {

     temp_strm.str("");
 
     temp_strm << "ERROR!  In `client_func':  Handshake failed:"
               << endl;

     lock_cerr_mutex();
     cerr << temp_strm.str();
     gnutls_perror (ret);
     unlock_cerr_mutex();

     temp_strm.str("");

     temp_strm << "Exiting function unsuccessfully "
               << "with return value 1."
               << endl;

     lock_cerr_mutex();
     cerr << temp_strm.str();
     unlock_cerr_mutex();

     close(param.sock);
     param.sock = 0;

     gnutls_certificate_free_credentials (xcred);
     gnutls_deinit (param.session);

     ++param.errors_occurred; 

     return 1;

  }
#if DEBUG_COMPILE 
  else if (DEBUG)
  {
      lock_cerr_mutex(); 
      cerr << "In `client_func':  Handshake was completed."
           << endl;
      unlock_cerr_mutex(); 
      
  }
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) Verify certificate.  @>

@ Verify certificate.  
\initials{LDF 2013.05.08.}

\LOG
\initials{LDF 2013.05.08.}
Added this section.
\ENDLOG

@<|client_func| definition@>=

@q ***** (5) @>

   status = verify_certificate(param.session, &param.server_cert);

   if (status != 0)
   {

     temp_strm.str("");
  
     temp_strm << "ERROR!  In `client_func':  `verify_certificate' failed, "
               << "returning " << status << "."
               << endl
               << "Exiting function unsuccessfully "
               << "with return value 1."
               << endl;

     lock_cerr_mutex();
     cerr << temp_strm.str();
     unlock_cerr_mutex();


     close(param.sock);
     param.sock = 0;

     gnutls_certificate_free_credentials (xcred);
     gnutls_deinit (param.session);

     ++param.errors_occurred; 

     return 1;

   }  /* |if (status != 0)|  */
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `client_func':  `verify_certificate' succeeded, returning 0."
           << endl;

       param.server_cert.show("param.server_cert:");

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   Distinguished_Name_Type distinguished_name;
   distinguished_name = param.server_cert;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       distinguished_name.show("distinguished_name:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */    


@q ***** (5) Print session info.  @>

@ Print session info.  
\initials{LDF 2013.05.08.}

\LOG
\initials{LDF 2013.05.08.}
Added this section.
\ENDLOG

@<|client_func| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Printing session info:"
            << endl;
       print_info(param.session);
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    }  /* |else if (remote_connection == true && anonymous == false)|  */


@q **** (4) Local connection (Unix domain socket).  @>

@ Local connection (Unix domain socket).
\initials{LDF 2012.09.20.}

\LOG
\initials{LDF 2013.04.10.}
Added code for setting |string sock_path| depending on the value of the global 
variable |string socket_dir|, which may be set using the \.{--socket-directory} 
option.
\ENDLOG 

@<|client_func| definition@>=

    else  /* |remote_connection == false|  */
    {
@q ***** (5) @>

        string sock_path;

        if (socket_dir.empty())
        {
            socket_dir = DEFAULT_SOCKET_DIRECTORY;
            sock_path  = socket_dir;
            sock_path += "/gwirdsif.sock";
        }
        else
        {
            sock_path  = socket_dir;
            sock_path += "/.gwirdsif/gwirdsif.sock";
        }

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            temp_strm.str("");
            temp_strm << "sock_path == " << sock_path << endl;
            cerr << temp_strm.str();
            unlock_cerr_mutex(); 
        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

        int len;

        struct sockaddr_un local_peer;

@q ***** (5) @>
@
@<|client_func| definition@>=

        errno = 0;
        param.sock = socket(AF_UNIX, SOCK_STREAM, 0);

        if (param.sock == -1) 
        {
            lock_cerr_mutex(); 
            temp_strm.str("");
            temp_strm << "ERROR!  In `client_func':  `socket' failed, returning -1." 
                      << endl
                      << "socket error:  " << strerror(errno)
                      << endl 
                      << "Exiting `client_func' unsuccessfully with return value 1."
                      << endl;
            cerr << temp_strm.str();
            unlock_cerr_mutex(); 
 
            close(param.sock);
            param.sock = 0;

            ++param.errors_occurred; 


            return 1;
        }

#if DEBUG_COMPILE
        if (DEBUG) 
        {
           temp_strm.str("");
           temp_strm << "Trying to connect...\n";
           cerr << temp_strm.str();
        }
#endif  /* |DEBUG_COMPILE|  */  

        local_peer.sun_family = AF_UNIX;

        strcpy(local_peer.sun_path, sock_path.c_str());

        len = strlen(local_peer.sun_path) + sizeof(local_peer.sun_family);

        errno = 0;
        status = connect(param.sock, (struct sockaddr *)&local_peer, len);

        if (status == -1) 
        {
            
            temp_strm.str("");
            temp_strm << "ERROR!  In `client_func':  `connect' failed, returning -1." 
                      << endl
                      << "connect error:  " << strerror(errno)
                      << endl
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;

            lock_cerr_mutex(); 
            cerr << temp_strm.str();
            unlock_cerr_mutex(); 

            close(param.sock);
            param.sock = 0;

            ++param.errors_occurred; 

            return 1;
        }
 
#if DEBUG_COMPILE
        if (DEBUG) 
        {
           temp_strm.str("");
           temp_strm << "Connected.\n";
           cerr << temp_strm.str();
        }
#endif  /* |DEBUG_COMPILE|  */  

@q ***** (5) @>

    }  /* |else| (|remote_connection == false|)  */


@q **** (4) @>
@
@<|client_func| definition@>=

#if DEBUG_COMPILE
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        temp_strm.str("");
        param.show("In `client_func':  param:", &temp_strm);
        cerr << temp_strm.str();
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q **** (4) @>
@
@<|client_func| definition@>=

    param.input_commands = command_str;
    command_str = "";


@q **** (4) Test standard input for input.  @>

@ Test standard input for input.
\initials{LDF 2013.07.11.}

@:NOTE@> !! PLEASE NOTE:  An input file specified using the \.{--input-filename} command-line
option takes precedence over commands specified using the \.{--commands} option.  This also
applies when the input filename is \.{"-"} and the input is passed to \.{gwirdcli} 
via a pipe.  However, if input is passed via a pipe without using the \.{--input-filename}
option with \.{-} as its argument (e.g., \.{--input-filename=-}, \.{--input-filename "-"}, 
or some other equivalent variant), then the \.{--commands} option takes precedence.
\par
This is because \.{gwirdcli} can't ``know'' that there is input to be read from |stdin| unless
it tries to read from it.  If there is no input, the reading function will block.  If there is 
no input, the user will have to enter some, which would at best be a nuisance.  However, if 
the program is running unattended, then it could theoretically block ``forever''.
\par
If the \.{--no-terminate} option is being used, then the input from |stdin| will be 
processed after the commands passed using the \.{--commands} option.  However, 
\.{gwirdcli} will exit after this, because it will have read |EOF| from |stdin|.  
When input is passed via a pipe in this way, |stdin| is not connected to the terminal, so 
the user would have no possibility of entering more commands interactively, which is really 
the intention of the \.{--no-terminate} option.  
\par
If the \.{--commands} or \.{--input-filename} option is used and the \.{--no-terminate} 
option is not used, then the input from |stdin| will not be processed.
\initials{LDF 2013.07.11.}


\LOG
\initials{LDF 2013.07.11.}
Added this section.
\ENDLOG

@<|client_func| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "param.data_filename == " << param.data_filename << endl
             << "param.input_commands == " << param.input_commands << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    if (!(param.data_filename.empty() || param.data_filename == "-"))
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "param.data_filename == " << param.data_filename << " "
                 << "(non-empty, not \"-\")"
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        if (strlen(param.data_buffer) > 0)
        {
            lock_cerr_mutex();
            cerr << "WARNING!  In `client_func':  `param.data_filename' == " 
                 << "`" << param.data_filename << "' and "
                 << endl 
                 << "`strlen(param.data_buffer)' == " << strlen(param.data_buffer)
                 << endl 
                 << "`param.data_buffer' ==" 
                 << endl 
                 << param.data_buffer 
                 << endl
                 << "`param.data_filename' takes precedence over `param.data_buffer'."
                 << endl
                 << "Setting all bytes in `param.data_buffer' to 0 and continuing."
                 << endl;
             unlock_cerr_mutex();
            
             memset(param.data_buffer, 0, BUFFER_SIZE);

             ++param.warnings_occurred;
        }
        
        if (!param.input_commands.empty())
        {
            lock_cerr_mutex();
            cerr << "WARNING!  In `client_func':  `param.data_filename' == " 
                 << "`" << param.data_filename << "' and "
                 << endl 
                 << "`param.input_commands' =="
                 << endl  
                 << param.input_commands
                 << endl
                 << "`param.data_filename' takes precedence over `param.input_commands'."
                 << endl
                 << "Setting `param.input_commands' to the empty string and continuing."
                 << endl;
             unlock_cerr_mutex();
            
             ++param.warnings_occurred;
 
             param.input_commands = "";

        }

    }  /* |if (!(param.data_filename.empty() || param.data_filename == "-"))|  */

@q ***** (5) @>

    else  if (param.data_filename == "-")
    {
        if (strlen(param.data_buffer) > 0)
        {
            lock_cerr_mutex();
            cerr << "WARNING!  In `client_func':  `param.data_filename' == `-' and" 
                 << endl 
                 << "`strlen(param.data_buffer)' == " << strlen(param.data_buffer)
                 << endl 
                 << "`param.data_buffer' ==" 
                 << endl 
                 << param.data_buffer 
                 << endl
                 << "`param.data_filename' takes precedence over `param.data_buffer'."
                 << endl
                 << "Will read from standard input."
                 << endl 
                 << "Setting all bytes in `param.data_buffer' to 0 and continuing."
                 << endl;
             unlock_cerr_mutex();
            
             memset(param.data_buffer, 0, BUFFER_SIZE);

             ++param.warnings_occurred;
        }

        if (!param.input_commands.empty())
        {
            lock_cerr_mutex();
            cerr << "WARNING!  In `client_func':  `param.data_filename' == `-' and" 
                 << endl 
                 << "`param.input_commands' =="
                 << endl  
                 << param.input_commands
                 << endl
                 << "`param.data_filename' takes precedence over `param.input_commands'."
                 << endl
                 << "Will read from standard input."
                 << endl 
                 << "Setting `param.input_commands' to the empty string and continuing."
                 << endl;
             unlock_cerr_mutex();
            
             ++param.warnings_occurred;
 
             param.input_commands = "";

        }


    }
@q ***** (5) @>

    else if (strlen(param.data_buffer) > 0)
    {

        if (!param.input_commands.empty())
        {
            lock_cerr_mutex();
            cerr << "WARNING!  In `client_func':  `strlen(param.data_buffer)' > 0 " 
                 << "and `param.input_commands' =="
                 << endl  
                 << param.input_commands
                 << endl
                 << "`param.data_buffer' takes precedence over `param.input_commands'."
                 << endl
                 << "Setting `param.input_commands' to the empty string and continuing."
                 << endl;
             unlock_cerr_mutex();
            
             ++param.warnings_occurred;
 
             param.input_commands = "";

        }

    }

@q ***** (5) @>

    else if (!param.input_commands.empty())
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "param.input_commands == " << param.input_commands << " (non-empty)"
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        strcpy(param.data_buffer, param.input_commands.c_str());

        param.input_commands = "";

    }  /* |else if (!param.input_commands.empty())|  */

@q ***** (5) @>

@ @:NOTE@> !! PLEASE NOTE:  There doesn't seem to be any practicable way of testing 
whether there are characters to read from |cin| (i.e., |stdin|).  If there are none, 
|read| blocks.  We therefore always prompt:  If there are characters to be read, they 
will be read after the first prompt, so the latter will scroll by.  It would be neater 
if the prompt could be suppressed in this case, but it doesn't seem to be practicable.
\initials{LDF 2013.07.11.}

@<|client_func| definition@>=

    if (   (param.data_filename.empty() || param.data_filename == "-")
        && strlen(param.data_buffer) == 0
        && param.input_commands.empty()) 
    {
@q ****** (6) @>

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "`param.input_commands', `param.data_buffer' are both empty "
                 << "and `param.data_filename' is empty or == `-'."
                 << endl
                 << "Will try to read from standard input."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

        status = param.get_input(); 

        if (status != 0)
        {

            temp_strm.str("");
            temp_strm << "ERROR!  In `client_func':  "
                      << "`Scan_Parse_Parameter_Type::get_input' failed, returning " 
                      << status << "." 
                      << endl
                      << "Failed to get input from standard input."
                      << endl
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;

            lock_cerr_mutex(); 
            cerr << temp_strm.str();
            unlock_cerr_mutex(); 

            close(param.sock);
            param.sock = 0;

            gnutls_certificate_free_credentials (xcred);
            gnutls_deinit (param.session);

            ++param.errors_occurred; 

            return 1;
            
        }  /* |if (status != 0)|  */

@q ****** (6) @>

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            temp_strm.str("");
            temp_strm << "In `client_func':  "
                      << "`Scan_Parse_Parameter_Type::get_input' succeeded, returning 0." 
                      << endl
                      << "`strlen(param.data_buffer)' == " << strlen(param.data_buffer)
                      << endl;

             if (strlen(param.data_buffer) > 0)
                temp_strm << "param.data_buffer == " << param.data_buffer << endl;

             if (!param.data_filename.empty())
                 temp_strm << "param.data_filename == " << param.data_filename << endl;
             else
                 temp_strm << "param.data_filename is empty." << endl;

                     
            lock_cerr_mutex(); 
            cerr << temp_strm.str();
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

    }  /* |if|  */

@q ***** (5) @>

@q **** (4) @>
@
\LOG
\initials{LDF 2013.04.18.}
Added code for the case that |exchange_data_with_server| returns 2.  This will
occur when the \.{END\_SERVER} command succeeds.
\ENDLOG 

@<|client_func| definition@>=

   status = exchange_data_with_server(param);

   if (status == 2)
   {
        temp_strm.str("");
        temp_strm << "In `client_func':  `exchange_data_with_server' returned 2:  "
                  << "`END_SERVER' command succeeded."
                  << endl
                  << "Exiting function successfully with return value 2."
                  << endl;
        cerr << temp_strm.str();

        return 2;


   }  /* |if (status == 2)|  */

   else if (status != 0)
   {
        temp_strm.str("");
        temp_strm << "ERROR!  In `client_func':  `exchange_data_with_server' failed, "
                  << "returning " << status << "."
                  << endl
                  << "Exiting function unsuccessfully with return value 1."
                  << endl;

        lock_cerr_mutex();
        cerr << temp_strm.str();
        unlock_cerr_mutex(); 

        close(param.sock);
        param.sock = 0;

        gnutls_certificate_free_credentials (xcred);
        gnutls_deinit (param.session);

        ++param.errors_occurred; 

        return 1;

   }  /* |else if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
        temp_strm.str("");
        temp_strm << "In `client_func':  `exchange_data_with_server' succeeded, returning 0."
                  << endl;
        cerr << temp_strm.str();


   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */

@q **** (4) @>
@
@<|client_func| definition@>=

#if DEBUG_COMPILE
    if (DEBUG)
    {
       temp_strm.str("");
       temp_strm << "Exiting function successfully with return value 0."
                 << endl;
       cerr << temp_strm.str();

    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |client_func| definition  */

@q **** (4) @>
@
@<Garbage@>=

@q **** (4) @>

@q *** (3) Putting `clntfncs.web' together.  @>

@ Putting {\tt clntfncs\PERIOD web} together.

@q **** (4) This is what's compiled.  @>
@ This is what's compiled.
@c
@<Include files@>@;@/

#define SA struct sockaddr

using namespace std;
using namespace gwrdifpk;
int output_func(string, bool b = false);
@<|client_func| declaration@>@;@/
@<|client_func| definition@>@;@/
#if 0 
@<Garbage@>@;@/
#endif 

@q **** (4) This is what's written to the header file `clntfncs.h'.  @>

@ This is what's written to the header file \filename{clntfncs.h}.
\initials{LDF 2012.06.27.}

@(clntfncs.h@>=
#ifndef CLNTFNCS_H
#define CLNTFNCS_H 1
using namespace std;
using namespace gwrdifpk;
@<|client_func| declaration@>@;@/
#endif 

@q * (1) Emacs-Lisp code for use in indirect buffers  @>

@q (progn (cweb-mode) (outline-minor-mode))                          @>

@q * (1) Local variables for Emacs @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q abbrev-mode:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>

