@q srvractn.web  @>
@q Created by Laurence D. Finston (LDF) Wed May 29 10:53:25 CEST 2013  @>

@q * (1) Copyright and License.@>

@q This file is part of gwrdifpk, a package for long-term archiving.  @>
@q Copyright (C) 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021 Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen @>

@q gwrdifpk is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q gwrdifpk is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License          @>
@q along with gwrdifpk; if not, write to the Free Software                    @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q gwrdifpk is available for downloading via Git from @>
@q https://github.com/gwdg/gwrdifpk.git    @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de@>

@q Laurence D. Finston                                                   @>
@q Kreuzbergring 41         					         @>
@q 37075 Goettingen              					 @>
@q Germany                           					 @>                                

@q Laurence.Finston@@gmx.de (@@ stands for a single "at" sign.)@>

@q ** (2) srvractn.web  @>
@* {\bf Scan\_Parse\_Parameter\_Type} server action function definitions.

@q ** (2) Include files  @>

@ Include files.

@<Include files@>=
#include <stdlib.h>  /* Standard Library for C  */
#include <stdio.h>
#include <sys/mman.h>
#include <errno.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <limits.h>
#include <string.h>

#include <algorithm> /* Standard Template Library (STL) for C++  */
#include <bitset>
#include <fstream> 
#include <iomanip>
#include <ios>
#include <iostream>
#include <map>
#include <string>
#include <time.h>
#include <math.h>
#include <sstream>  

#include <vector>
#include <deque>
#include <stack>
#include <set>

#include <pthread.h>  /* POSIX threads  */

#include <gcrypt.h> /* for |gcry_control| */
#include <gnutls/gnutls.h>
#include<gnutls/x509.h>

#include <mysql.h>

#include <expat.h>

#if HAVE_CONFIG_H
#include <config.h>
#endif 

#undef NAME_LEN
#undef LOCAL_HOST

#include "rspercds.h++"
#include "glblcnst.h++"
#include "glblvrbl.h++"
#include "excptntp.h++"
#include "utilfncs.h++"
#include "grouptp.h++"
#include "hndlvltp.h++"
#include "irdsavtp.h++"
#include "helper.h++"
#include "tanfncs.h++"
#include "pidfncs.h++"
#include "parser.h++"
#include "scanner.h++"
#include "rspnstp.h++"
#include "irdsobtp.h++"
#include "hndltype.h++"
#include "dcmdsbtp.h++"
#include "dcmtdttp.h++"
#include "x509cert.h++"
#include "dstngnmt.h++"
#include "pullrqtp.h++"
#include "scprpmtp.h++"
#include "usrinftp.h++"
#include "prsrfncs.h++"

@q *** (3) Server action functions.  @>
@ Server action functions.
\initials{LDF 2013.05.27.}

\LOG
\initials{LDF 2013.05.27.}
Added this section.  The declarations are in \filename{scprpmtp.web}.
\ENDLOG

@q **** (4) |server_action_command_only|.  @>
@
\LOG
\initials{LDF 2013.05.29.}
Added this function.

\initials{LDF 2013.05.16.}
@:BUG FIX@> BUG FIX: Added code for issuing a warning if |response.command| is empty.
I've been caught by this a couple of times.
\par 
\initials{LDF 2013.05.29.}
This entry is from a time when the code in this function was part of a conditional in 
|exchange_data_with_client| in \filename{exchncli.web}.
\initials{LDF 2013.05.29.}
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_command_only| definition@>=
int
Scan_Parse_Parameter_Type::server_action_command_only(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_command_only':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl 
            << "`response.command == " << response.command
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>

   if (response.command.empty())
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "WARNING!  "
            << "In `Scan_Parse_Parameter_Type::server_action_command_only':"
            << "`response.command' is empty."
            << endl 
            << "Sending a NULL byte to client, so the latter won't block, "
            << "but this is almost certainly a programming error."
            << endl;
       unlock_cerr_mutex(); 

       ++warnings_occurred;

       status = send_to_peer(0, 1);

   }  /* |if (response.command.empty())|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_command_only| definition@>=

   else 
   {
       strcpy(buffer, response.command.c_str());
       buffer_ptr = buffer;

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_command_only':  "
                << "`buffer' == " 
                << endl 
                << buffer
                << endl 
                << "Sending to client."
                << endl;

           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       status = send_to_peer(&buffer_ptr, 0);


   }  /* |else|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_command_only| definition@>=

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_command_only':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_command_only':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_command_only' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_command_only| definition   */


@q **** (4) |server_action_send_file|.  @>

@ |server_action_send_file|.
\initials{LDF 2013.05.29.}

\LOG
\initials{LDF 2012.11.20.}
In the case that |response.command.empty() == false|, now calling 
|Scan_Parse_Parameter_Type::send_to_peer| only once, passing both 
|&buffer_ptr| and |response.local_filename| to it as arguments.
Previously, the latter function would only accept one of the two.

\initials{LDF 2013.05.29.}
Added this function.  Previously, the code it contains was in a 
conditional in |exchange_data_with_client|.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_send_file| definition@>=
int
Scan_Parse_Parameter_Type::server_action_send_file(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_send_file':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_file| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_send_file':" 
            << endl;
       response.show("response:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           if (response.command.empty())
   {
       status = send_to_peer(0, 0, response.local_filename);
   }
   else
   {
       memset(buffer, 0, BUFFER_SIZE);
       strcpy(buffer, response.command.c_str());
       buffer_ptr = buffer;

       status = send_to_peer(&buffer_ptr, 0, response.local_filename);
   }

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_send_file':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_send_file':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 





@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_file| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_send_file' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_send_file| definition   */


@q **** (4) |server_action_receive_put_file|.  @>

@ |server_action_receive_put_file|.
\initials{LDF 2013.05.29.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_receive_put_file| definition@>=

int
Scan_Parse_Parameter_Type::server_action_receive_put_file(Response_Type &response)
{ 
   return 0; 

}


@q **** (4) |server_action_receive_metadata_file|.  @>

@ |server_action_receive_metadata_file|.
\initials{LDF 2013.05.29.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_receive_metadata_file| definition@>=

int
Scan_Parse_Parameter_Type::server_action_receive_metadata_file(Response_Type &response)
{ 
   return 0; 

}

@q **** (4) |server_action_send_handle|.  @>

@ |server_action_send_handle|.
\initials{LDF 2013.05.29.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=
int
Scan_Parse_Parameter_Type::server_action_send_handle(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   char temp_buffer[256];
   memset(temp_buffer, 0, 256);

   stringstream temp_strm;

   ofstream out_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

   int fd = 0;

   char temp_filename[] = "/tmp/gwirdsif.XXXXXX";

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_send_handle':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=

   if (response.handle == 0)
   {
@q ****** (6) @>

       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
            << endl 
            << "`response.handle' is NULL.  Not sending handle to client."
            << endl;
       unlock_cerr_mutex(); 

       ++warnings_occurred;

       temp_strm.str("");

       temp_strm << "GET HANDLE RESPONSE 6 " << response.options << "U";

       strcpy(buffer, temp_strm.str().c_str());

       temp_strm.str("");

       status = send_to_peer(&buffer_ptr, 0);

       if (status != 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_send_handle':"
                << endl 
                << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
                << status << "."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           return 1;      

       }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_send_handle':"
                << endl 
                << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


       return 2;
       
   }  /* |if (response.handle == 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
            << endl 
            << "Sending handle to client."
            << endl;
   unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

   unsigned char temp_val;

   string hexl_str;

   bool write_to_file = false;
   bool force_write   = false;  /* |true|  */

   memset(buffer, 0, BUFFER_SIZE);

   for (map<unsigned long int, Handle_Value_Type>::const_iterator iter 
                      = response.handle->handle_value_map.begin();
        iter != response.handle->handle_value_map.end();
        ++iter)
   {    
@q ****** (6) @>

       memset(temp_buffer, 0, 256);
       temp_strm.str("");

       temp_strm << "GET HANDLE RESPONSE 0 " << response.options << "U HANDLE "
                 << "\"" << iter->second.handle << "\"";

       if (!iter->second.filename.empty())
          temp_strm << " FILE \"" << iter->second.filename << "\"";

       temp_strm << " IDX "
                 << iter->second.idx 
                 << " TYPE \"" << iter->second.type << "\" "
                 << " DATA_LENGTH " << iter->second.data_length << " ";

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=

       if (   iter->second.data
           && iter->second.data_length > 0
           && (   iter->second.type == "EMAIL" 
               || iter->second.type == "DESC"
               || iter->second.type == "IRODS_OBJECT"
               || iter->second.type == "IRODS_OBJECT_REF"
               || iter->second.type == "IRODS_OBJECT_PID"
               || iter->second.type == "DC_METADATA"
               || iter->second.type == "DC_METADATA_PID"
               || iter->second.type == "DC_METADATA_IRODS_OBJECT"
               || iter->second.type == "DC_METADATA_IRODS_OBJECT_PID"
               || iter->second.type == "DC_METADATA_IRODS_OBJECT_REF")
          )
       {

           memcpy(temp_buffer, iter->second.data, iter->second.data_length);
           temp_strm << "DATA \"" << temp_buffer << "\" ";

       }  


@q ***** (5) @>
@
\LOG
\initials{LDF 2013.04.26.}
Added code for handling binary data.
\ENDLOG 
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=

       else if (iter->second.data && iter->second.data_length > 0)  /* binary data  */
       {
@q ****** (6) @>

#if DEBUG_COMPILE

          if (DEBUG)        
          {
              lock_cerr_mutex(); 
              cerr << "In `Scan_Parse_Parameter_Type::server_action_send_handle':  Binary data == "
                   << endl;

              fwrite(iter->second.data, 1, iter->second.data_length, stderr);
              cerr << endl;


              for (int i = 0; i < iter->second.data_length; ++i)
              {
                       
                  cerr << "iter->second.data[" << i << "== "
                       << iter->second.data[i]
                       << endl;
                   
                  temp_val = static_cast<unsigned char>(iter->second.data[i]); 

                  cerr << "temp_val == " << static_cast<unsigned int>(temp_val) 
                       << endl;

                   cerr << "isprint(iter->second.data[" << i << "]) == "
                        << static_cast<bool>(isprint(iter->second.data[i]))
                        << endl;

              }  /* |for|  */

              unlock_cerr_mutex(); 

          }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */          

@q ****** (6) @>

          hexl_str = "";

          status = hexl_encode(iter->second.data, 
                               iter->second.data_length, 
                               hexl_str, 
                               0x1e);

          if (status != 0)
          {
              lock_cerr_mutex(); 
              cerr << thread_str
                   << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
                   << endl 
                   << "`hexl_encode' failed, returning " << status << "."
                   << endl
                   << "Failed to encode data from `data' field of handle "
                   << "in hexadecimal."
                   << endl
                   << "Not sending encoded contents of `data' field to client."
                   << endl
                   << "Continuing."
                   << endl;
              unlock_cerr_mutex(); 

              ++warnings_occurred;

              temp_strm << "DATA \"(binary)\" ";

          }  /* |if (status != 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=

         else /* |status == 0|, |hexl_encode| succeeded  */ 
         {
@q ******** (8) @>

#if DEBUG_COMPILE
              if (DEBUG)   
              {
                  lock_cerr_mutex(); 
                  cerr << thread_str
                       << "In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
                       << endl 
                       << "`hexl_encode' succeeded, returning 0."
                       << endl
                       << "`hexl_str' == " << hexl_str
                       << endl;
                  unlock_cerr_mutex(); 


              }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

              temp_strm << "DATA_HEXL_ENCODED " << hexl_str << " ";

@q ******** (8) @>

         }  /* |else| (|status == 0|, |hexl_encode| succeeded)  */ 

@q ******* (7) @>

       }  /* |else| (binary data)  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=                  

       else if (iter->second.data == 0 && iter->second.data_length > 0)
       {
                      
             lock_cerr_mutex(); 
             cerr << thread_str
                  << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
                  << endl 
                  << "`iter->second.data' == 0 and `iter->second.data_length' == "
                  << iter->second.data_length << " (> 0)."
                  << endl
                  << "This shouldn't happen.  Not sending contents of `data' field "
                  << "of handle value to client."
                  << endl
                  << "Continuing."
                  << endl;
             unlock_cerr_mutex(); 

             ++warnings_occurred;

       }  /* |else if|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=                  

       else if (iter->second.data != 0 && iter->second.data_length == 0)
       {
                      
             lock_cerr_mutex(); 
             cerr << thread_str
                  << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
                  << endl 
                  << "`iter->second.data' != 0 and `iter->second.data_length' == 0." 
                  << endl
                  << "This shouldn't happen.  Not sending contents of `data' field "
                  << "of handle value to client."
                  << endl
                  << "Continuing."
                  << endl;
             unlock_cerr_mutex(); 

             ++warnings_occurred;

       }  /* |else if|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=                  

#if DEBUG_COMPILE

       if (DEBUG && iter->second.data == 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
                << endl 
                << "`iter->second.data' == 0."
                << endl
                << "No data in `data' field of handle value to send to client."
                << endl;
           unlock_cerr_mutex(); 

       }   

       if (DEBUG && iter->second.data_length == 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
                << endl 
                << "`iter->second.data_length' == 0."
                << endl;
           unlock_cerr_mutex(); 
       }   

#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=

       temp_strm << " TTL_TYPE " << iter->second.ttl_type << " "
                 << " TTL " << iter->second.ttl << " "
                 << " TIMESTAMP " << iter->second.timestamp << "U "
                 << " REFS_LENGTH " << iter->second.refs_length << " ";

@q ******** (8) refs.  @>
@ refs.  
\initials{LDF 2013.04.28.}

The contents of the \.{refs} field of the handle value is always treated
as binary data.
\initials{LDF 2013.04.28.}                  

\LOG
\initials{LDF 2013.04.28.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=

       if (iter->second.refs && iter->second.refs_length > 0)
       {
@q ********* (9) @>

#if DEBUG_COMPILE 
          if (DEBUG)        
          {
              lock_cerr_mutex(); 
              cerr << "In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
                   << "`refs_length' == " 
                   << iter->second.refs_length << " (> 0)"
                   << endl
                   << "`refs' is always treated as binary data.  Will send "
                   << "to client."
                   << endl
                   << "`refs' == "
                   << endl;

              fwrite(iter->second.refs, 1, iter->second.refs_length, stderr);
              cerr << endl;

              unlock_cerr_mutex(); 

          }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */          

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=

          hexl_str = "";

          status = hexl_encode(iter->second.refs, 
                               iter->second.refs_length, 
                               hexl_str, 
                               0x1e);

          if (status != 0)
          {
              lock_cerr_mutex(); 
              cerr << thread_str
                   << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
                   << endl 
                   << "`hexl_encode' failed, returning " << status << "."
                   << endl
                   << "Failed to encode data from `refs' field of handle "
                   << "in hexadecimal."
                   << endl
                   << "Not sending encoded contents of `refs' field to client."
                   << endl
                   << "Continuing."
                   << endl;
              unlock_cerr_mutex(); 

              ++warnings_occurred;

              temp_strm << "REFS \"(binary)\" ";

          }  /* |if (status != 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=

         else /* |status == 0|, |hexl_encode| succeeded  */ 
         {
@q ******** (8) @>

#if DEBUG_COMPILE
              if (DEBUG)   
              {
                  lock_cerr_mutex(); 
                  cerr << thread_str
                       << "In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
                       << endl 
                       << "`hexl_encode' succeeded, returning 0."
                       << endl
                       << "`hexl_str' == " << hexl_str
                       << endl;
                  unlock_cerr_mutex(); 


              }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

              temp_strm << "REFS_HEXL_ENCODED " << hexl_str << " ";

@q ******** (8) @>

         }  /* |else| (|status == 0|, |hexl_encode| succeeded)  */ 

@q ******* (7) @>

       }  /* |if (iter->second.refs && iter->second.refs_length > 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=                  

       else if (iter->second.refs == 0 && iter->second.refs_length > 0)
       {
                      
             lock_cerr_mutex(); 
             cerr << thread_str
                  << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
                  << endl 
                  << "`iter->second.refs' == 0 and `iter->second.refs_length' == "
                  << iter->second.refs_length << " (> 0)."
                  << endl
                  << "This shouldn't happen.  Not sending contents of `refs' field "
                  << "of handle value to client."
                  << endl
                  << "Continuing."
                  << endl;
             unlock_cerr_mutex(); 

             ++warnings_occurred;

       }  /* |else if|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=                  

       else if (iter->second.refs != 0 && iter->second.refs_length == 0)
       {
                      
             lock_cerr_mutex(); 
             cerr << thread_str
                  << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
                  << endl 
                  << "`iter->second.refs' != 0 and `iter->second.refs_length' == 0." 
                  << endl
                  << "This shouldn't happen.  Not sending contents of `refs' field "
                  << "of handle value to client."
                  << endl
                  << "Continuing."
                  << endl;
             unlock_cerr_mutex(); 

             ++warnings_occurred;

       }  /* |else if|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=                  

#if DEBUG_COMPILE

       if (DEBUG && iter->second.refs == 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
                << endl 
                << "`iter->second.refs' == 0."
                << endl
                << "No data in `refs' field of handle value to send to client."
                << endl;
           unlock_cerr_mutex(); 

       }   

       if (DEBUG && iter->second.refs_length == 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_send_handle':  "
                << endl 
                << "`iter->second.refs_length' == 0."
                << endl;
           unlock_cerr_mutex(); 
       }   

#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=

       temp_strm << "ADMIN_READ " << iter->second.admin_read << " "
                 << "ADMIN_WRITE " << iter->second.admin_write << " "
                 << "PUB_READ " << iter->second.pub_read << " "
                 << "PUB_WRITE " << iter->second.pub_write << " "
                 << "HANDLE_ID " << iter->second.handle_id << "UL "
                 << "HANDLE_VALUE_ID " << iter->second.handle_value_id << "UL "
                 << "IRODS_OBJECT_ID " << iter->second.irods_object_id << "UL "
                 << "CREATED " << iter->second.created << "U "
                 << "LAST_MODIFIED " << iter->second.last_modified << "U "
                 << "DELETE_FROM_DATABASE_TIMESTAMP " 
                 << iter->second.delete_from_database_timestamp << "U "
                 << "CREATED_BY_USER " << iter->second.created_by_user_id << "U "
                 << "\"" << iter->second.created_by_user_name << "\" "
                 << "MARKED_FOR_DELETION " << iter->second.marked_for_deletion
                 << endl << endl;


#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
\LOG
\initials{LDF 2013.05.29.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=
   
@q ******* (7) @>

       if (force_write 
           || (write_to_file == false 
               && (strlen(buffer) + temp_strm.str().size()) >= BUFFER_SIZE))
       {
@q ******** (8) @>

            write_to_file = true;
            force_write = false;

            errno = 0;
            fd = mkstemp(temp_filename);

            if (fd == -1)
            {
               lock_cerr_mutex(); 
               cerr << thread_str
                    << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_send_handle':"
                    << endl 
                    << "`mkstemp' failed, returning -1:" 
                    << endl
                    << strerror(errno)
                    << endl 
                    << "Exiting function unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               return 1;      
              
            }  /* |if (fd == -1)|  */

@q ******** (8) @>

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str
                     << "In `Scan_Parse_Parameter_Type::server_action_send_handle':"
                     << endl 
                     << "`mkstemp' succeeded."
                     << endl
                     << "`temp_filename' == " << temp_filename
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

            temp_file_vector.push_back(temp_filename);

            close(fd);
 
            out_strm.open(temp_filename);
            out_strm << buffer;

            memset(buffer, 0, BUFFER_SIZE);

@q ******** (8) @>

       }  /* |if|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=

       if (write_to_file == true)
       {
#if 0
           cerr << "write_to_file == " << write_to_file << endl;
           cerr << "temp_filename == " << temp_filename << endl;
#endif 
           out_strm << temp_strm.str();

       }  /* |if (write_to_file == true)|  */

@q ******* (7) @>

       else   /* |write_to_file == false|  */
       {
           strcat(buffer, temp_strm.str().c_str());
       }

@q ******* (7) @>

@q ****** (6) @>

   }  /* |for|  */

@q ***** (5) @>

   out_strm.close();

   if (write_to_file)
      status = send_to_peer(0, 0, string(temp_filename));
   else
      status = send_to_peer(&buffer_ptr, 0);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_send_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_send_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

@q ***** (5) @>

       delete response.handle;
       response.handle = 0;

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_send_handle' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;



}  /* End of |Scan_Parse_Parameter_Type::server_action_send_handle| definition   */


@q **** (4) |server_action_ls|.  @>
@
\LOG
\initials{LDF 2013.05.29.}
Added this function.

\initials{LDF 2013.05.29.}
This entry is from a time when the code in this function was part of a conditional in 
|exchange_data_with_client| in \filename{exchncli.web}.
\initials{LDF 2013.05.29.}
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_ls| definition@>=
int
Scan_Parse_Parameter_Type::server_action_ls(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string temp_filename;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_ls':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_ls| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "response.string_vector.size() == " << response.string_vector.size() 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
 
   status = ls(buffer_ptr, BUFFER_SIZE, &temp_filename, &response);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_ls':"
            << endl 
            << "`Scan_Parse_Parameter_Type::ls' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_ls':"
            << endl 
            << "`Scan_Parse_Parameter_Type::ls' succeeded, returning 0."
            << endl;

       cerr << "buffer_ptr == " << buffer_ptr << endl
            << "temp_filename == " << temp_filename << endl;

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


   status = send_to_peer(&buffer_ptr, 0, temp_filename);  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_ls':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_ls':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_ls| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_ls' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_ls| definition   */

@q **** (4) |server_action_pwd|.  @>

@ |server_action_pwd|.
\initials{LDF 2013.05.29.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_pwd| definition@>=
int
Scan_Parse_Parameter_Type::server_action_pwd(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_pwd':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_pwd| definition@>=

   status = pwd(buffer_ptr, BUFFER_SIZE);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_pwd':"
            << endl 
            << "`Scan_Parse_Parameter_Type::pwd' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */

   status = send_to_peer(&buffer_ptr, 0);  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_pwd':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_pwd':"
            << endl 
            << "`Scan_Parse_Parameter_Type::pwd' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_pwd| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_pwd' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_pwd| definition   */

@q **** (4) |server_action_cd|.  @>

@ |server_action_cd|.
\initials{LDF 2013.05.29.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_cd| definition@>=
int
Scan_Parse_Parameter_Type::server_action_cd(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_cd':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_cd| definition@>=

   status = cd(response.dirname, buffer_ptr, BUFFER_SIZE);

   if (status == 3)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_cd':"
            << endl 
            << "`Scan_Parse_Parameter_Type::cd' failed, returning 3." 
            << endl;
       unlock_cerr_mutex(); 

       ++warnings_occurred;

       temp_strm.str("");
       temp_strm << "CD RESPONSE 7 \"" << response.dirname << "\" "
                 << "\"" << irods_current_dir << "\" "
                 << " \"" << irods_current_dir << "\" "
                 << "\"`Scan_Parse_Parameter_Type::cd' failed\"";

       strcpy(buffer, temp_strm.str().c_str());
                   
   }  /* |if (status == 3)|  */

   else if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_cd':"
            << endl 
            << "`Scan_Parse_Parameter_Type::cd' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>

   status = send_to_peer(&buffer_ptr, 0);  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_cd':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_cd':"
            << endl 
            << "`Scan_Parse_Parameter_Type::cd' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_cd| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_cd' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_cd| definition   */


@q **** (4) |server_action_mkdir|.  @>

@ |server_action_mkdir|.
\initials{LDF 2013.05.29.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_mkdir| definition@>=
int
Scan_Parse_Parameter_Type::server_action_mkdir(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_mkdir':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_mkdir| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "response.flags == " << response.flags
            << endl  
            << "response.string_vector.size() == " << response.string_vector.size() 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
 
   status = mkdir(response, buffer_ptr, BUFFER_SIZE);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_mkdir':"
            << endl 
            << "`Scan_Parse_Parameter_Type::mkdir' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_mkdir':"
            << endl 
            << "`Scan_Parse_Parameter_Type::mkdir' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = send_to_peer(&buffer_ptr);  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_mkdir':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_mkdir':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_mkdir| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_mkdir' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_mkdir| definition   */

@q **** (4) |server_action_mark_irods_objects_for_deletion|.  @>

@ |server_action_mark_irods_objects_for_deletion|.
\initials{LDF 2013.08.07.}

\LOG
\initials{LDF 2013.08.07.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion| definition@>=
int
Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */ 

   set_debug_level(DEBUG, 0, 0); 

   int status;

   int ret_val = 0;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Entering "
            << "`Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "response.flags == " << response.flags
            << endl  
            << "response.string_vector.size() == " << response.string_vector.size() 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
 
   status = mark_irods_objects_for_deletion(response, buffer_ptr, BUFFER_SIZE);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  "
            << "In `Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion':"
            << endl 
            << "`Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion' failed, returning " 
            << status << "."
            << endl;
       unlock_cerr_mutex(); 

       ret_val = 2;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion':"
            << endl 
            << "`Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion' succeeded, "
            << "returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   if (buffer_ptr != 0 && strlen(buffer_ptr) > 0)
      status = send_to_peer(&buffer_ptr);  
   else
      status = send_to_peer(0, 1);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  "
            << "In `Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl;
       unlock_cerr_mutex(); 

       ret_val = 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion| definition@>=

@q ***** (5) @>

   if (ret_val != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion':"
            << endl 
            << "Exiting function unsuccessfully with return value " << ret_val << "."
            << endl;
       unlock_cerr_mutex(); 

       return ret_val;
   }

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting "
            << "`Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion' "
            << "successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of 
      |Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion| 
      definition   */



@q **** (4) |server_action_get|.  @>

@ |server_action_get|.
\initials{LDF 2013.05.29.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_get| definition@>=
int
Scan_Parse_Parameter_Type::server_action_get(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_get':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_get| definition@>=

   status = get(response, thread_str);

@q ***** (5) @>

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_get':"
            << endl 
            << "`Scan_Parse_Parameter_Type::get' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_get':"
            << endl 
            << "`Scan_Parse_Parameter_Type::get' succeeded, returning 0."
            << endl;
#if 0 
       response.show("response:");
#endif 
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

@ If |Scan_Parse_Parameter_Type::get| fails, it will create a response to 
tell the client about the error, so we just send a single NULL byte to the client 
to prevent it from blocking.
\initials{LDF 2013.05.29.}
\initials{LDF 2014.01.16.}

@<|Scan_Parse_Parameter_Type::server_action_get| definition@>=
 
    status = send_to_peer(0, 1);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << thread_str
             << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_get':"
             << endl 
             << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
             << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        return 1;

    }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_str
             << "In `Scan_Parse_Parameter_Type::server_action_get':"
             << endl 
             << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_get| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_get' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_get| definition   */

@q **** (4) |server_action_send_metadata|.  @>

@ |server_action_send_metadata|.
\initials{LDF 2013.05.29.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_send_metadata| definition@>=
int
Scan_Parse_Parameter_Type::server_action_send_metadata(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_send_metadata':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_metadata| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_send_metadata':  "
            << endl 
            << "Sending metadata to client."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_metadata| definition@>=

   strcpy(buffer, response.command.c_str());

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "response.local_filename == " << response.local_filename << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = send_to_peer(&buffer_ptr, 0, response.local_filename);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_send_metadata':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_send_metadata':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_metadata| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_send_metadata' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_send_metadata| definition   */

@q **** (4) |server_action_end_server|.  @>

@ |server_action_end_server|.
\initials{LDF 2013.05.30.}

\LOG
\initials{LDF 2013.05.30.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_end_server| definition@>=
int
Scan_Parse_Parameter_Type::server_action_end_server(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_end_server':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_end_server| definition@>=

   if (end_server_enabled)
   {
        strcpy(buffer, "END_SERVER RESPONSE 0");

   }  /* |if (end_server_enabled)|  */

@q ***** (5) @>

@ Normally this code should never be reached, because the case that 
|end_server_enabled == false| is handled in the parser rule.
\initials{LDF 2013.04.03.}

@<|Scan_Parse_Parameter_Type::server_action_end_server| definition@>=

   else /* |end_server_enabled == false|  */
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_end_server':"
            << endl 
            << "`response.type' == `END_SERVER_TYPE' and "
            << "`end_server_enabled' == `false'."
            << endl
            << "This shouldn't be possible.  However, it doesn't cause any harm."
            << endl
            << "Not ending server.  Will send failure notice to client and continue."
            << endl;

        unlock_cerr_mutex(); 

        ++warnings_occurred;

        strcpy(buffer, "END_SERVER RESPONSE 1");

   }  /* |else| (|end_server_enabled == false|)  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_end_server| definition@>=
          
#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "`buffer':  " << buffer << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = send_to_peer(&buffer_ptr, 0);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_end_server':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_end_server':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@ 
\LOG
\initials{LDF 2013.04.18.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_end_server| definition@>=

   if (end_server_enabled)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_end_server':"
            << endl 
            << "`END_SERVER' command succeeded.  "
            << "Exiting function successfully with return value 2."
            << endl;
        unlock_cerr_mutex(); 

       return 2;

   }  /* |if (end_server_enabled)|  */



@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_end_server| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_end_server' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_end_server| definition   */


@q **** (4) |server_action_sleep|.  @>

@ |server_action_sleep|.
\initials{LDF 2013.05.29.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_sleep| definition@>=
int
Scan_Parse_Parameter_Type::server_action_sleep(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_sleep':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_sleep| definition@>=

   if (sleep_server_enabled)
   {

        temp_strm.str("");
                
        temp_strm << "SLEEP RESPONSE 0 " << response.int_val;
       
        strncpy(buffer, temp_strm.str().c_str(), BUFFER_SIZE);

        temp_strm.str("");

   }  /* |if (sleep_server_enabled)|  */

@q ***** (5) @>

@ Normally this code should never be reached, because the case that 
|sleep_server_enabled == false| is handled in the parser rule.
\initials{LDF 2013.04.03.}

@<|Scan_Parse_Parameter_Type::server_action_sleep| definition@>=

   else /* |sleep_server_enabled == false|  */
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_sleep':"
            << endl 
            << "`response.type' == `SLEEP_TYPE' and "
            << "`sleep_server_enabled' == `false'."
            << endl
            << "This shouldn't be possible.  However, it doesn't cause any harm."
            << endl
            << "Not ending server.  Will send failure notice to client and continue."
            << endl;

        unlock_cerr_mutex(); 

        ++warnings_occurred;

        temp_strm.str("");
                
        temp_strm << "SLEEP RESPONSE 1 " << response.int_val;
       
        strncpy(buffer, temp_strm.str().c_str(), BUFFER_SIZE);

        temp_strm.str("");


   }  /* |else| (|sleep_server_enabled == false|)  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_sleep| definition@>=
          
#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "`buffer':  " << buffer << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = send_to_peer(&buffer_ptr, 0);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_sleep':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_sleep':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_sleep| definition@>=

   if (sleep_server_enabled)
   {
#if DEBUG_COMPILE
       if (DEBUG) 
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_sleep':"
                << endl 
                << "Going to sleep for " << response.int_val << " seconds ...";
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       status = sleep(response.int_val);

#if DEBUG_COMPILE
       if (DEBUG) 
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_sleep':"
                << endl 
                << "Woke up after " << (response.int_val - status) << " seconds."
                << endl;

            if (status != 0)
                cerr << "Was supposed to sleep for " << response.int_val << " seconds."
                     << endl;

           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |if (sleep_server_enabled)|  */

@q ***** (5) @>

@ This code should never be reached, because this case is caught in |yyparse|.
\initials{LDF 2013.04.19.}

@<|Scan_Parse_Parameter_Type::server_action_sleep| definition@>=

#if DEBUG_COMPILE 
   else if (DEBUG)  /* |sleep_server_enabled == false|  */
   {
        lock_cerr_mutex(); 
        cerr << thread_str
             << "In `Scan_Parse_Parameter_Type::server_action_sleep':"
             << endl 
             << "`sleep_server_enabled' == `false'.  Not going to sleep.  Continuing."
             << endl;
        unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)| (|sleep_server_enabled == false|)  */

#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_sleep| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_sleep' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_sleep| definition   */

@q **** (4) |server_action_show_certificate|.  @>

@ |server_action_show_certificate|.
\initials{LDF 2013.05.29.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_show_certificate| definition@>=
int
Scan_Parse_Parameter_Type::server_action_show_certificate(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Entering `Scan_Parse_Parameter_Type::server_action_show_certificate':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_show_certificate| definition@>=

   string temp_filename;

   status = show_certificates(response, buffer, BUFFER_SIZE, temp_filename);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_show_certificate':"
            << endl 
            << "`Scan_Parse_Parameter_Type::show_certificates' failed, "
            << "returning " << status << "."
            << endl
            << "Will try to continue."
            << endl;
       unlock_cerr_mutex(); 

       ++warnings_occurred;

   }  /* |if (status != 0)|  */
          
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_show_certificate':"
            << endl 
            << "`Scan_Parse_Parameter_Type::show_certificates' succeeded, "
            << "returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "`buffer':  " << buffer << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = send_to_peer(&buffer_ptr, 0, temp_filename);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_show_certificate':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_show_certificate':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_show_certificate| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_show_certificate' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_show_certificate| definition   */

@q **** (4) |server_action_get_metadata|.  @>

@ |server_action_get_metadata|.
\initials{LDF 2013.05.29.}

@q GET_PIDS (This comment is for convenience in searching or "grepping".)  LDF 2013.05.23.  @>

|Response_Type::GET_METADATA_TYPE| is also used for the \.{GET PID} and \.{GET PIDS} 
commands (which are synonymous).
\initials{LDF 2013.05.23.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_get_metadata| definition@>=
int
Scan_Parse_Parameter_Type::server_action_get_metadata(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_get_metadata':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_get_metadata| definition@>=

   string temp_filename;
 
#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_get_metadata':"
            << endl 
            << "response.type == Response_Type::GET_METADATA_TYPE"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   int ctr;

   bool do_output = (static_cast<unsigned int>(response.int_val) & 1) ? false : true;

   status = get_metadata(response.local_filename, 
                         response.int_val, 
                         &ctr,
                         response.options,
                         buffer,
                         BUFFER_SIZE,
                         do_output);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_get_metadata':"
            << endl 
            << "`Scan_Parse_Parameter_Type::get_metadata' failed, "
            << "returning " << status << "."
            << endl
            << "Will try to continue."
            << endl;
       unlock_cerr_mutex(); 

       ++warnings_occurred;

   }  /* |if (status != 0)|  */
          
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_get_metadata':"
            << endl 
            << "`Scan_Parse_Parameter_Type::get_metadata' succeeded, "
            << "returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "`buffer':   " << buffer << endl
            << "`temp_filename': " << temp_filename << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = send_to_peer(&buffer_ptr, 0, temp_filename);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_get_metadata':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_get_metadata':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 





@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_get_metadata| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_get_metadata' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_get_metadata| definition   */





@q **** (4) |server_action_get_handle|.  @>

@ |server_action_get_handle|.
\initials{LDF 2013.05.29.}

If |Scan_Parse_Parameter_Type::get_handle| succeeds, it sets up a response of
type |Response_Type::SEND_HANDLE_TYPE| and pushes it onto |param.response_deque|.
Therefore, the successful case cannot be handled within this conditional.
The error cases could, because the responses are of type |Response_Type::COMMAND_ONLY_TYPE|
and they could be sent from here.  However, I don't think the advantage is so great 
that I would want to change the code in |Scan_Parse_Parameter_Type::get_handle| at this 
time (or possibly any other time, either).
\initials{LDF 2013.05.23.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_get_handle| definition@>=
int
Scan_Parse_Parameter_Type::server_action_get_handle(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   string temp_filename;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_get_handle':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_get_handle| definition@>=


#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_get_handle':"
            << endl 
            << "`response.type'    == Response_Type::GET_HANDLE_TYPE"
            << endl
            << "`response.options' == " << response.options << " == " 
            << oct << response.options << " (octal)" << dec
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   string temp_str = (response.int_val == 0) ? response.pid_str : response.local_filename;
    
   status = get_handle(temp_str, response.int_val, response.options);

   if (status == 2)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::get_handle' returned 2:  Handle not found."
            << endl
            << "Continuing."
            << endl;
       unlock_cerr_mutex(); 

       ++warnings_occurred;

   }  /* |if (status == 2)|  */

   else if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::get_handle' failed, "
            << "returning " << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;
 
       ++errors_occurred;

   }  /* |else if (status != 0)|  */
          
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::get_handle' succeeded, "
            << "returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
\LOG
\initials{LDF 2013.07.03.}
@:BUG FIX@> BUG FIX:  Now storing the return value of |send_to_peer| in |status|.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::server_action_get_handle| definition@>=


   status = send_to_peer(0, 1);  /* Send a single NULL byte to client, 
                                    so it won't block.
                                    \initials{LDF 2013.05.23.}  */

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_get_handle| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_get_handle' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_get_handle| definition   */


@q **** (4) |server_action_send_tan_list|.  @>

@ |server_action_send_tan_list|.
\initials{LDF 2013.05.29.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_send_tan_list| definition@>=
int
Scan_Parse_Parameter_Type::server_action_send_tan_list(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_send_tan_list':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_tan_list| definition@>=

   status = send_tan_list();

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_send_tan_list':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_tan_list' failed, "
            << "returning " << status << "."
            << endl
            << "Will try to continue."
            << endl;
       unlock_cerr_mutex(); 

       ++warnings_occurred;

   }  /* |if (status != 0)|  */
          
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_send_tan_list':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_tan_list' succeeded, "
            << "returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = send_to_peer(0, 1);  /* Send a single NULL byte to client, 
                                    so it won't block.
                                    \initials{LDF 2013.05.23.}  */


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_send_tan_list| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_send_tan_list' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_send_tan_list| definition   */





@q **** (4) |server_action_process_pending|.  @>

@ |server_action_process_pending|.
\initials{LDF 2013.05.29.}

\LOG
\initials{LDF 2013.05.29.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_process_pending| definition@>=
int
Scan_Parse_Parameter_Type::server_action_process_pending(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);


   string temp_filename;

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_process_pending':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_process_pending| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
@q ****** (6) @>

       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_process_pending':"
            << endl 
            << "response.type == Response_Type::PROCESS_PENDING_TYPE"
            << endl;

@q ****** (6) @>

       cerr << "response_deque.size() == " << response_deque.size() 
            << endl
            << "delayed_response_deque.size() == " 
            << delayed_response_deque.size() 
            << endl;

@q ****** (6) @>

       if (response_deque.size() > 0)
       {
            cerr << "response_deque:"
                 << endl;

            for (deque<Response_Type>::iterator iter = response_deque.begin();
                 iter != response_deque.end();
                 ++iter)
            {
                 cerr << "Type:  " << Response_Type::typename_map[iter->type] 
                      << endl;

                 if (iter->type == Response_Type::COMMAND_ONLY_TYPE)
                     cerr << "Command:  " << iter->command << endl;

            }

            cerr << endl;

       }  /* |if|  */

@q ****** (6) @>

      if (delayed_response_deque.size() > 0)
       {
            cerr << "delayed_response_deque:"
                 << endl;

            for (deque<Response_Type>::iterator iter 
                           = delayed_response_deque.begin();
                 iter != delayed_response_deque.end();
                 ++iter)
            {
                 cerr << "Type:  " << Response_Type::typename_map[iter->type] 
                      << endl;

                 if (iter->type == Response_Type::COMMAND_ONLY_TYPE)
                     cerr << "Command:  " << iter->command << endl;

            }

            cerr << endl;

       }  /* |if|  */

@q ****** (6) @>


       unlock_cerr_mutex(); 

@q ****** (6) @>

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
\LOG
\initials{LDF 2013.08.12.}
@:BUG FIX@> BUG FIX:  Added code for testing |response_deque.size()|.
Previously, |temp_deque.push_back| caused an error, if |response_deque| 
was empty.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::server_action_process_pending| definition@>=

   deque<Response_Type> temp_deque;

   deque<Response_Type>::iterator iter_1;

   if (response_deque.size() > 0)
   {
      iter_1 = response_deque.begin();

       temp_deque.push_back(*iter_1);

       ++iter_1;

   }
   else
      iter_1 = response_deque.end();

   if (iter_1 != response_deque.end())
   {

@q ****** (6) @>

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "`After increment:"
                 << endl 
                 << "iter_1->type':     " << Response_Type::typename_map[iter_1->type] 
                 << endl
                 << "`iter_1->command':  " << iter_1->command
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        for (; iter_1 != response_deque.end(); ++iter_1)
        {
            if (iter_1->no_delay)
                temp_deque.push_back(*iter_1);
            else
                delayed_response_deque.push_back(*iter_1);                    

        }

        response_deque.clear();
        response_deque = temp_deque;
        temp_deque.clear();

@q ****** (6) @>

#if DEBUG_COMPILE
        if (DEBUG)
        {
@q ********* (9) @>

            lock_cerr_mutex(); 
            cerr << "After inserting:"
                 << endl;

@q ********* (9) @>

            if (response_deque.size() > 0)
             {

                  cerr << "response_deque:"
                       << endl;

                  for (deque<Response_Type>::iterator iter = response_deque.begin();
                       iter != response_deque.end();
                       ++iter)
                  {
                       cerr << "Type:  " << Response_Type::typename_map[iter->type] 
                            << endl;

                       if (iter->type == Response_Type::COMMAND_ONLY_TYPE)
                           cerr << "Command:  " << iter->command << endl;

                  }

                  cerr << endl;

             }  /* |if|  */

@q ********* (9) @>

             if (delayed_response_deque.size() > 0)
              {
                   cerr << "delayed_response_deque:"
                        << endl;

                   for (deque<Response_Type>::iterator iter 
                                  = delayed_response_deque.begin();
                        iter != delayed_response_deque.end();
                        ++iter)
                   {
                        cerr << "Type:  " << Response_Type::typename_map[iter->type] 
                             << endl;

                        if (iter->type == Response_Type::COMMAND_ONLY_TYPE)
                            cerr << "Command:  " << iter->command << endl;

                   }

                   cerr << endl;

              }  /* |if|  */

@q ********* (9) @>
             unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

   }  /* |if (iter_1 != response_deque.end())|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "No following responses."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_process_pending| definition@>=

#if 0 /* 1    For testing.  \initials{LDF 2013.05.24.}  */

          /* Send a response to the client.  \initials{LDF 2013.05.24.}  */

   strcpy(buffer, "PROCESS PENDING OPERATIONS RESPONSE 0");
   status = send_to_peer(&buffer_ptr, 0);  
   memset(buffer, 0, BUFFER_SIZE);
#else 

   status = send_to_peer(0, 1);  /* Just send a single NULL byte, so the client
                                    won't block.
                                    \initials{LDF 2013.05.24.}  
                                 */
#endif 

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_process_pending':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_process_pending':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_process_pending| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_process_pending' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_process_pending| definition   */



@q **** (4) |server_action_get_user_info|.  @>

@ |server_action_get_user_info|.
\initials{LDF 2013.05.30.}

This function will only be called if the \.{GET\_USER\_INFO} command was called using the
\.{DELAY} option.  Otherwise, |get_user_info_func| is called immediately in |yyparse|.
\par
Under normal circumstances, the user info can be retrieved and sent to the client immediately.
The \.{DELAY} option is for the case that commands are used that affect the user info before 
calling the \.{GET\_USER\_INFO} command in a single batch of input.
\initials{LDF 2013.05.24.}

\LOG
\initials{LDF 2013.05.30.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_get_user_info| definition@>=
int
Scan_Parse_Parameter_Type::server_action_get_user_info(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_get_user_info':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_get_user_info| definition@>=

   status = get_user_info_func(this, response.string_val.c_str());

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_get_user_info':"
            << endl 
            << "`get_user_info_func' failed, returning " 
            << status << "."
            << endl
            << "Will try to continue."
            << endl;
       unlock_cerr_mutex(); 

       ++warnings_occurred;
              

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_get_user_info':"
            << endl 
            << "`get_user_info_func' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = send_to_peer(0, 1);  /* Send NULL byte so client won't block.
                                    \initials{LDF 2013.05.24.}  */  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_get_user_info':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 


       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_get_user_info':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_get_user_info| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_get_user_info' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_get_user_info| definition   */

@q **** (4) |server_action_create_handle|.  @>

@ |server_action_create_handle|.
\initials{LDF 2013.05.30.}

\LOG
\initials{LDF 2013.05.30.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_create_handle| definition@>=
int
Scan_Parse_Parameter_Type::server_action_create_handle(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_create_handle':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_create_handle| definition@>=

   status = generate_pids(mysql_ptr, 
                          response.pid_prefix_str, 
                          response.pid_str,
                          0,
                          1, 
                          0, 
                          0, 
                          true, 
                          response.pid_institute_str, 
                          response.pid_suffix_str, 
                          0, 
                          "", 
                          user_id, 
                          username);

@q ***** (5) @>

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_create_handle':"
            << endl 
            << "`generate_pids' failed, returning " 
            << status << "."
            << endl
            << "Failed to create PID \"" << response.pid_str << "\"."
            << endl
            << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "CREATE HANDLE RESPONSE 1 \"" << response.pid_str << "\"";

       strcpy(buffer, temp_strm.str().c_str());

       temp_strm.str("");

       ++errors_occurred;

   }  /* |if (status != 0)|  */


@q ***** (5) @>

   else
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_create_handle':"
                << endl 
                << "`generate_pids' succeeded, returning 0." 
                << endl 
                << "Created PID \"" << response.pid_str << "\" successfully."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       temp_strm.str("");
       temp_strm << "CREATE HANDLE RESPONSE 0 \"" << response.pid_str << "\"";

       strcpy(buffer, temp_strm.str().c_str());

       temp_strm.str("");

   }  /* |else|  */


@q ***** (5) @>
  
   status = send_to_peer(&buffer_ptr, 0);  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_create_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;


       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_create_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 



@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_create_handle| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_create_handle' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_create_handle| definition   */
 
@q **** (4) |server_action_add_handle_value|.  @>

@ |server_action_add_handle_value|.
\initials{LDF 2013.06.15.}

\LOG
\initials{LDF 2013.06.15.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_add_handle_value| definition@>=
int
Scan_Parse_Parameter_Type::server_action_add_handle_value(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

   Handle_Type handle;

   Handle_Value_Triple hvt;

   int ret_val = 0;

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Entering `Scan_Parse_Parameter_Type::server_action_add_handle_value':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_add_handle_value| definition@>=

   if (   response.pid_str.empty()
       || (response.hvt.idx == 0 && response.hvt.type.empty() && response.hvt.data_str.empty()))
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_add_handle_value':"
            << endl 
            << "`Response_Type response' doesn't contain sufficient data to add a handle value:"
            << endl 
            << "response.pid_str == " << response.pid_str 
            << endl
            << "response.hvt.idx == " << response.hvt.idx 
            << endl
            << "response.hvt.type == " << response.hvt.type 
            << endl
            << "response.hvt.data_str == " << response.hvt.data_str
            << endl
            << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "ADD HANDLE_VALUE RESPONSE 4 \"" << response.pid_str << "\" 0 \"\" \"\"";

       strcpy(buffer, temp_strm.str().c_str());

       temp_strm.str("");

       ++errors_occurred;

       ret_val = 2;

       goto FINISH;
       

   }  /* |if|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_add_handle_value| definition@>=

   status = fetch_handle_from_database(response.pid_str, handle);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_add_handle_value':"
            << endl 
            << "`Scan_Parse_Parameter_Type::fetch_handle_from_database' failed, returning " 
            << status << "."
            << endl
            << "Failed to fetch handle object for PID \"" << response.pid_str << "\" "
            << "from database."
            << endl
            << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "ADD HANDLE_VALUE RESPONSE 3 \"" << response.pid_str << "\" 0 \"\" \"\"";

       strcpy(buffer, temp_strm.str().c_str());

       temp_strm.str("");

       ++errors_occurred;

       ret_val = 2;

       goto FINISH;

   }  /* |if (status != 0)|  */

@q ***** (5) @>
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_add_handle_value':"
            << endl 
            << "`Scan_Parse_Parameter_Type::fetch_handle_from_database' succeeded, returning 0." 
            << endl;

       handle.show("handle:");
       response.show("response:");
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

   status = handle.add_value(mysql_ptr, 
                             response.hvt.idx, 
                             response.hvt.type, 
                             response.hvt.data_str, 
                             user_id,
                             &hvt);
@q ***** (5) @>

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_add_handle_value':"
            << endl 
            << "`Handle_Type::add_handle_value' failed, returning " 
            << status << "."
            << endl
            << "Failed to add handle value to handle \"" << response.pid_str << "\"."
            << endl
            << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "ADD HANDLE_VALUE RESPONSE 1 \"" << response.pid_str << "\" 0 \"\" \"\"";

       strcpy(buffer, temp_strm.str().c_str());

       temp_strm.str("");

       ++errors_occurred;

       ret_val = 2;

       goto FINISH;

   }  /* |if (status != 0)|  */

@q ***** (5) @>

   else
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_add_handle_value':"
                << endl 
                << "`add_handle_value' succeeded, returning 0." 
                << endl 
                << "Added handle value to handle \"" << response.pid_str << "\" successfully."
                << endl;

           hvt.show("hvt:");

           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       temp_strm.str("");
       temp_strm << "ADD HANDLE_VALUE RESPONSE 0 \"" << response.pid_str << "\" " 
                 << hvt.idx << " \"" << hvt.type << "\" ";

       if (hvt.data_str[0] == '\x1e')
          temp_strm << "\"(binary)\"";
       else
          temp_strm << "\"" << hvt.data_str << "\"";

       strcpy(buffer, temp_strm.str().c_str());

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "buffer == " << buffer << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */       


       temp_strm.str("");

   }  /* |else|  */


@q ***** (5) @>

FINISH:
  
   status = send_to_peer(&buffer_ptr, 0);  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_add_handle_value':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;


       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_add_handle_value':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_add_handle_value| definition@>=

    if (ret_val != 0)
    {
#if DEBUG_COMPILE
         if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << thread_str 
                  << "In `Scan_Parse_Parameter_Type::server_action_add_handle_value':"
                  << endl 
                  << "`ret_val' == " << ret_val
                  << endl
                  << "Error or warning occurred.  Exiting function with return value `ret_val' "
                  << "== " << ret_val << "."
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

         return ret_val;


    }  /* |if (ret_val != 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_add_handle_value| definition@>=

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_add_handle_value' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_add_handle_value| definition   */

@q **** (4) |server_action_delete_handle|.  @>

@ |server_action_delete_handle|.
\initials{LDF 2013.07.04.}

\LOG
\initials{LDF 2013.07.04.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=
int
Scan_Parse_Parameter_Type::server_action_delete_handle(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

   Handle_Type handle;

   int ret_val = 0;

   string handle_database = (standalone_handle) ? "handlesystem_standalone" : "handlesystem";

   int handle_rows = 0;

   int created_by_user_id = 0;

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Entering `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;

       response.show("response:");

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=

   bool immediate = response.pid_options & 1U;

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=

   if (!(   privileges & SUPERUSER_PRIVILEGE 
         || privileges & DELETE_HANDLES_PRIVILEGE))
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "User doesn't have the `delete_handles' privilege."
            << endl;

        if (immediate)
           cerr << "Not marking handle `" << response.pid_str  << "' for immediate deletion." 
                << endl;
        else 
           cerr << "Not marking handle `" << response.pid_str  << "' for deletion." 
                << endl;

       cerr << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "DELETE HANDLE RESPONSE 1 \"" << response.pid_str << "\" "
                 << "\"ERROR!  User does not have `delete_handles' privilege.  ";

       if (immediate)
           temp_strm << "Handle not marked for immediate deletion.\"";
       else 
           temp_strm << "Handle not marked for deletion.\"";

        strcpy(buffer, temp_strm.str().c_str());
        buffer_ptr = buffer;

        temp_strm.str("");

        ++errors_occurred;

        ret_val = 2;

        goto FINISH;

   }  /* |if|  */


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=

   if (response.pid_str.empty())
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "`Response_Type response' doesn't contain sufficient data to add a handle value:"
            << endl 
            << "response.pid_str == " << response.pid_str 
            << endl
            << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "DELETE HANDLE RESPONSE 1 \"" << response.pid_str << "\" "
                 << "\"PID string empty.  ";

       if (immediate)
           temp_strm << "Can't mark handle for immediate deletion\"";
       else 
           temp_strm << "Can't mark handle for deletion\"";


       strcpy(buffer, temp_strm.str().c_str());
       buffer_ptr = buffer;

       temp_strm.str("");

       ++errors_occurred;

       ret_val = 2;

       goto FINISH;
      
   }  /* |if|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=

   status = fetch_handle_from_database(response.pid_str, handle);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::fetch_handle_from_database' failed, returning " 
            << status << "."
            << endl
            << "Failed to fetch handle object for PID \"" << response.pid_str << "\" "
            << "from database."
            << endl
            << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "DELETE HANDLE RESPONSE 1 \"" << response.pid_str << "\" "
                 << "\"Failed to fetch handle from database.\"";

       strcpy(buffer, temp_strm.str().c_str());
       buffer_ptr = buffer;

       temp_strm.str("");

       ++errors_occurred;

       ret_val = 2;

       goto FINISH;

   }  /* |if (status != 0)|  */

@q ***** (5) @>
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::fetch_handle_from_database' succeeded, returning 0." 
            << endl;

       handle.show("handle:");
       unlock_cerr_mutex(); 


   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   created_by_user_id = handle.created_by_user_id();

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "created_by_user_id == " << created_by_user_id << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=

   if (privileges & SUPERUSER_PRIVILEGE)
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
                << endl 
                << "User `" << username << "' (user ID " << user_id << ") "
                << "has superuser privilege.  Will delete handle."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |if (privileges & SUPERUSER_PRIVILEGE)|  */

@q ***** (5) @>

   else if (user_id == created_by_user_id && privileges & DELETE_HANDLES_PRIVILEGE)
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
                << endl 
                << "User `" << username << "' (user ID " << user_id << ") "
                << "created handle and has \"delete handles\" privilege.  "
                << endl 
                << "Will delete handle."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |else if (   user_id == created_by_user_id
                   && privileges & DELETE_HANDLES_PRIVILEGE)|  */

@q ***** (5) @>

   else if (user_id != created_by_user_id)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "User `" << username << "' (user ID " << user_id << ") did not create handle "
            << "and does not have \"superuser\" privilege."
            << endl
            << "`user_id' ==            " << user_id
            << endl
            << "`created_by_user_id' == " << created_by_user_id
            << endl 
            << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "DELETE HANDLE RESPONSE 1 \"" << response.pid_str << "\" "
                 << "\"Authorization failure:  User not permitted to delete handle\"";

       strcpy(buffer, temp_strm.str().c_str());
       buffer_ptr = buffer;

       temp_strm.str("");

       ++errors_occurred;

       ret_val = 2;

       goto FINISH;


   }  /* |else if (user_id != created_by_user_id)|  */

@q ***** (5) @>

   else 
   {

       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "User `" << username << "' (user ID " << user_id << ") does not have "
            << "\"delete handle\" privilege."
            << endl 
            << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "DELETE HANDLE RESPONSE 1 \"" << response.pid_str << "\" "
                 << "\"Authorization failure:  User not permitted to delete handle\"";

       strcpy(buffer, temp_strm.str().c_str());
       buffer_ptr = buffer;

       temp_strm.str("");

       ++errors_occurred;

       ret_val = 2;

       goto FINISH;

   }  /* |else if (user_id != created_by_user_id)|  */

@q ***** (5) @>

@ @:TODO@> !! TODO: LDF 2013.07.17.  Check |owner| and |group| fields in 
handle, once I've defined them.  That is, they don't exist yet.
\initials{LDF 2013.07.17.}

@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=

@q ***** (5) @>
@
\LOG
\initials{LDF 2013.08.21.}
Added this section.
\ENDLOG
@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=


#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       handle.show("handle:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 



   if (handle.handle_value_map.size() == 0)
   {

       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "Handle `" << response.pid_str << "' has no handle values."
            << endl 
            << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "DELETE HANDLE RESPONSE 1 \"" << response.pid_str << "\" "
                 << "\"Handle has no handle values.\"";

       strcpy(buffer, temp_strm.str().c_str());
       buffer_ptr = buffer;

       temp_strm.str("");

       ++errors_occurred;

       ret_val = 2;

       goto FINISH;

   }  /* |if (handle.handle_value_map.size() == 0)|  */

@q ***** (5) @>
@
\LOG
\initials{LDF 2013.08.21.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=

   else if (handle.handle_value_map.begin()->second.marked_for_deletion == true)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "Handle `" << response.pid_str << "' has already been marked for deletion."
            << endl 
            << "Will send warning message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "DELETE HANDLE RESPONSE 3 \"" << response.pid_str << "\" "
                 << "\"Handle already marked for deletion.\"";

       strcpy(buffer, temp_strm.str().c_str());
       buffer_ptr = buffer;

       temp_strm.str("");

       ++warnings_occurred;

       ret_val = 2;

       goto FINISH;

   }  /* |else if|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=


   status = handle.delete_from_database(mysql_ptr, 
                                        user_id,
                                        response.pid_options, 
                                        response.delay_value,
                                        &handle_rows, 
                                        thread_ctr);

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=

  if (status == 2)
  {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "`Handle_Type::delete_from_database' returned 2:"
            << endl;

       if (immediate)
           cerr << "No rows for PID \"" << response.pid_str << "\" "
                << "marked for immediate deletion from database."
                << endl;
       else 
           cerr << "No rows for PID \"" << response.pid_str << "\" "
                << "marked for deletion from database."
                << endl;

       cerr << "Will send message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "DELETE HANDLE RESPONSE 2 \"" << response.pid_str << "\" ";

       if (immediate)
           temp_strm << "\"No handles marked for immediate deletion from database.\"";
       else
           temp_strm << "\"No handles marked for deletion from database.\"";

       strcpy(buffer, temp_strm.str().c_str());
       buffer_ptr = buffer;

       temp_strm.str("");

       ++warnings_occurred;

       ret_val = 0;

       goto FINISH;

  }  /* |if (status == 2)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=

   else if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "`Handle_Type::delete_from_database' failed, returning " 
            << status << "."
            << endl;

       if (immediate)
           cerr << "Failed to mark handle object for PID \"" << response.pid_str << "\" "
                << "for immediate deletion from database."
                << endl;
       else 
           cerr << "Failed to mark handle object for PID \"" << response.pid_str << "\" "
                << "for deletion from database."
                << endl;

       cerr << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "DELETE HANDLE RESPONSE 1 \"" << response.pid_str << "\" ";

       if (immediate)
           temp_strm << "\"Failed to mark handle for immediate deletion from database.\"";
       else
           temp_strm << "\"Failed to mark handle for deletion from database.\"";

       strcpy(buffer, temp_strm.str().c_str());
       buffer_ptr = buffer;

       temp_strm.str("");

       ++errors_occurred;

       ret_val = 2;

       goto FINISH;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "`Handle_Type::delete_from_database' succeeded, returning 0." 
            << endl;
      
       if (immediate)
           cerr << "`handle_rows' (number of rows marked for immediate deletion from "
                << "`" << handle_database << ".handles' table) == ";
       else
           cerr << "`handle_rows' (number of rows marked for deletion from "
                << "`" << handle_database << ".handles' table) == ";

       cerr << handle_rows
            << endl << endl;

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   handle.clear();

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=

   temp_strm.str("");
   temp_strm << "DELETE HANDLE RESPONSE 0 \"" << response.pid_str << "\" ";

   if (immediate)
       temp_strm << "\"Marked " << handle_rows << " rows for immediate deletion from "
                 << "`" << handle_database << ".handles' database table\"";
   else
       temp_strm << "\"Marked " << handle_rows << " rows for deletion from "
                 << "`" << handle_database << ".handles' database table\"";

   strcpy(buffer, temp_strm.str().c_str());
   buffer_ptr = buffer;

   temp_strm.str("");

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=

FINISH:

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "buffer == " << buffer << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   if (strlen(buffer) > 0)
      status = send_to_peer(&buffer_ptr, 0);
   else
      status = send_to_peer(0, 1);  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>=

@q ***** (5) @>

   if (ret_val != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "In `Scan_Parse_Parameter_Type::server_action_delete_handle':"
            << endl 
            << "`ret_val' == " << ret_val << " (!= 0)"
            << endl
            << "Exiting function with return value " << ret_val << "."
            << endl;
       unlock_cerr_mutex(); 

       return ret_val;

   }

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_delete_handle' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_delete_handle| definition   */


@q **** (4) |server_action_undelete_handle|.  @>

@ |server_action_undelete_handle|.
\initials{LDF 2013.08.21.}

\LOG
\initials{LDF 2013.08.21.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_undelete_handle| definition@>=
int
Scan_Parse_Parameter_Type::server_action_undelete_handle(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

   Handle_Type handle;

   int ret_val = 0;

   string handle_database = (standalone_handle) ? "handlesystem_standalone" : "handlesystem";

   int handle_rows = 0;

   int created_by_user_id = 0;

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Entering `Scan_Parse_Parameter_Type::server_action_undelete_handle':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;

       response.show("response:");

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle| definition@>=

/* !! TODO:  LDF 2013.08.22.  Check user's permissions.   */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle| definition@>=

   if (response.pid_str.empty())
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_undelete_handle':"
            << endl 
            << "`Response_Type response' doesn't contain sufficient data to unmark a handle "
            << "for deletion:"
            << endl 
            << "response.pid_str == " << response.pid_str 
            << endl
            << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "UNDELETE HANDLE RESPONSE 1 \"" << response.pid_str << "\" "
                 << "\"PID string empty.  Can't unmark handle for deletion\"";

       strcpy(buffer, temp_strm.str().c_str());
       buffer_ptr = buffer;

       temp_strm.str("");

       ++warnings_occurred;

       ret_val = 2;

       goto FINISH;
      
   }  /* |if|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle| definition@>=

   status = fetch_handle_from_database(response.pid_str, handle);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_undelete_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::fetch_handle_from_database' failed, returning " 
            << status << "."
            << endl
            << "Failed to fetch handle object for PID \"" << response.pid_str << "\" "
            << "from database."
            << endl
            << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "UNDELETE HANDLE RESPONSE "
                 << GW_HANDLE_NOT_FOUND << " "
                 << "\"" << response.pid_str << "\" "
                 << "\"Failed to fetch handle from database.\"";

       strcpy(buffer, temp_strm.str().c_str());
       buffer_ptr = buffer;

       temp_strm.str("");

       ++errors_occurred;

       ret_val = 2;

       goto FINISH;

   }  /* |if (status != 0)|  */

@q ***** (5) @>
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_undelete_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::fetch_handle_from_database' succeeded, returning 0." 
            << endl;

       handle.show("handle:");
       unlock_cerr_mutex(); 


   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   created_by_user_id = handle.created_by_user_id();

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "created_by_user_id == " << created_by_user_id << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

/* !! TODO:  LDF 2013.08.22.  Check user privileges.  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle| definition@>=

   status = handle.unmark_handle_for_deletion(mysql_ptr, thread_str);

   if (status == GW_HANDLE_NOT_MARKED_FOR_DELETION)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_undelete_handle':"
            << endl 
            << "`Handle_Type::unmark_handle_for_deletion' returned " 
            << GW_HANDLE_NOT_MARKED_FOR_DELETION << " "
            << "(GW_HANDLE_NOT_MARKED_FOR_DELETION)"
            << endl 
            << "Handle `" << response.pid_str << "' not marked for deletion."
            << endl
            << "Can't unmark."
            << endl
            << "Will send warning message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "UNDELETE HANDLE RESPONSE " 
                 << GW_HANDLE_NOT_MARKED_FOR_DELETION << " "
                 << "\"" << response.pid_str << "\" "
                 << "\"Handle not marked for deletion.  Can't unmark\"";

       strcpy(buffer, temp_strm.str().c_str());
       buffer_ptr = buffer;

       temp_strm.str("");

       ++warnings_occurred;

       ret_val = 2;

       goto FINISH;
 
   }  /* |if (status == 2)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle| definition@>=

   else if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_undelete_handle':"
            << endl 
            << "`Handle_Type::unmark_handle_for_deletion' failed, returning " 
            << status << ":"
            << endl
            << gwstrerror(status)
            << endl 
            << "Failed to unmark handle \"" << response.pid_str << "\" "
            << "for deletion."
            << endl
            << "Will send error message to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");
       temp_strm << "UNDELETE HANDLE RESPONSE "
                 << status << " "
                 << "\"" << response.pid_str << "\" "
                 << "\"Failed to unmark handle for deletion.\"";

       strcpy(buffer, temp_strm.str().c_str());
       buffer_ptr = buffer;

       temp_strm.str("");

       ++errors_occurred;

       ret_val = 2;

       goto FINISH;

   }  /* |else if (status != 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle| definition@>=

   else
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_undelete_handle':"
                << endl 
                << "`Handle_Type::unmark_handle_for_deletion' succeeded, returning 0."
                << endl
                << "Unmarked handle `" << response.pid_str << "' successfully."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       temp_strm.str("");

       temp_strm << "UNDELETE HANDLE RESPONSE 0 \"" << response.pid_str << "\" \"Success\"";

       strcpy(buffer, temp_strm.str().c_str());

   }  /* |else|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle| definition@>=

FINISH:

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "buffer == " << buffer << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   if (strlen(buffer) > 0)
      status = send_to_peer(&buffer_ptr, 0);
   else
      status = send_to_peer(0, 1);  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_undelete_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_undelete_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle| definition@>=

@q ***** (5) @>

   if (ret_val != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "In `Scan_Parse_Parameter_Type::server_action_undelete_handle':"
            << endl 
            << "`ret_val' == " << ret_val << " (!= 0)"
            << endl
            << "Exiting function with return value " << ret_val << "."
            << endl;
       unlock_cerr_mutex(); 

       return ret_val;

   }

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_undelete_handle' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_undelete_handle| definition   */


@q **** (4) |server_action_delete_handle_value|.  @>

@ |server_action_delete_handle_value|.
\initials{LDF 2013.08.30.}

\LOG
\initials{LDF 2013.08.30.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_delete_handle_value| definition@>=
int
Scan_Parse_Parameter_Type::server_action_delete_handle_value(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

   int ret_val = 0;

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Entering `Scan_Parse_Parameter_Type::server_action_delete_handle_value':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;

       response.show("response:");

       show_privileges(privileges);

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle_value| definition@>=

   if (!(privileges & SUPERUSER_PRIVILEGE || privileges & DELETE_HANDLE_VALUES_PRIVILEGE))
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_delete_handle_value':"
            << endl
            << "User " << username << ", ID " << user_id << " "
            << "isn't doesn't have the `DELETE_HANDLE_VALUES_PRIVILEGE'."
            << endl 
            << "Will send failure notice to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       Response_Type new_response;

       new_response.type = Response_Type::COMMAND_ONLY_TYPE;

       temp_strm.str("");

       temp_strm << "DELETE HANDLE_VALUE RESPONSE " << GW_NO_PRIVILEGE_ERROR << " "
                 << "\"" << response.string_val << "\" -1 \"(Type)\" "
                 << "\"(Data)\" \"WARNING!  User `" << username << "', ID " << user_id << ", "
                 << "doesn't have the `delete_handle_values' privilege.\" " 
                 << (response.options & 1U) 
                 << " " << response.delay_value << "UL "
                 << purge_database_limit << "U";

       new_response.command = temp_strm.str();

       response_deque.push_back(new_response);

       ++warnings_occurred;

       ret_val = 2;

       goto FINISH;

   }  /* |if|  */


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle_value| definition@>=

   status = Handle_Value_Type::delete_handle_value(mysql_ptr,
                                                   response.string_val, 
                                                   response_deque,
                                                   user_id,
                                                   username,
                                                   privileges,
                                                   response.options,
                                                   response.delay_value,
                                                   thread_str);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_delete_handle_value':"
            << endl
            << "`Handle_Value_Type::delete_handle_value' failed, returning " << status << "."
            << endl;
       unlock_cerr_mutex(); 

       ret_val = 2;

       goto FINISH;


   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "In `Scan_Parse_Parameter_Type::server_action_delete_handle_value':"
            << endl
            << "`Handle_Value_Type::delete_handle_value' succeeded, returning 0."
            << endl 
            << "Deleted handle value successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle_value| definition@>=

FINISH:

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "buffer == " << buffer << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   if (strlen(buffer) > 0)
      status = send_to_peer(&buffer_ptr, 0);
   else
      status = send_to_peer(0, 1);  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_delete_handle_value':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_delete_handle_value':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_handle_value| definition@>=

@q ***** (5) @>

   if (ret_val != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "In `Scan_Parse_Parameter_Type::server_action_delete_handle_value':"
            << endl 
            << "`ret_val' == " << ret_val << " (!= 0)"
            << endl
            << "Exiting function with return value " << ret_val << "."
            << endl;
       unlock_cerr_mutex(); 

       return ret_val;

   }

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_delete_handle_value' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_delete_handle_value| definition   */

@q **** (4) |server_action_undelete_handle_value|.  @>

@ |server_action_undelete_handle_value|.
\initials{LDF 2013.08.30.}

\LOG
\initials{LDF 2013.08.30.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_undelete_handle_value| definition@>=
int
Scan_Parse_Parameter_Type::server_action_undelete_handle_value(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

   int ret_val = 0;

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Entering `Scan_Parse_Parameter_Type::server_action_undelete_handle_value':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;

       response.show("response:");

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle_value| definition@>=

   if (!(privileges & SUPERUSER_PRIVILEGE || privileges & UNDELETE_HANDLE_VALUES_PRIVILEGE))
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_undelete_handle_value':"
            << endl
            << "User " << username << ", ID " << user_id << " "
            << "isn't doesn't have the `UNDELETE_HANDLE_VALUES_PRIVILEGE'."
            << endl 
            << "Will send failure notice to client and continue."
            << endl;
       unlock_cerr_mutex(); 

       Response_Type new_response;

       new_response.type = Response_Type::COMMAND_ONLY_TYPE;

       temp_strm.str("");

       temp_strm << "UNDELETE HANDLE_VALUE RESPONSE " << GW_NO_PRIVILEGE_ERROR << " "
                 << "\"" << response.string_val << "\" -1 \"(Type)\" "
                 << "\"(Data)\" \"WARNING!  User `" << username << "', ID " << user_id << ", "
                 << "doesn't have the `undelete_handle_values' privilege.\"";

       new_response.command = temp_strm.str();

       response_deque.push_back(new_response);

       ++warnings_occurred;

       ret_val = 2;

       goto FINISH;

   }  /* |if|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle_value| definition@>=


   status = Handle_Value_Type::unmark_handle_value_for_deletion(mysql_ptr,
                                                                response.string_val,
                                                                response_deque,
                                                                user_id,
                                                                username,
                                                                privileges,
                                                                thread_str);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_undelete_handle_value':"
            << endl
            << "`Handle_Value_Type::unmark_handle_value_for_deletion' failed, returning " 
            << status << "."
            << endl;
       unlock_cerr_mutex(); 

       ret_val = 2;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "In `Scan_Parse_Parameter_Type::server_action_undelete_handle_value':"
            << endl
            << "`Handle_Value_Type::unmark_handle_value_for_deletion' succeeded, returning 0."
            << endl 
            << "Undeleted handle value successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle_value| definition@>=

FINISH:

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "buffer == " << buffer << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   if (strlen(buffer) > 0)
      status = send_to_peer(&buffer_ptr, 0);
   else
      status = send_to_peer(0, 1);  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_undelete_handle_value':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_undelete_handle_value':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle_value| definition@>=

@q ***** (5) @>

   if (ret_val != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "In `Scan_Parse_Parameter_Type::server_action_undelete_handle_value':"
            << endl 
            << "`ret_val' == " << ret_val << " (!= 0)"
            << endl
            << "Exiting function with return value " << ret_val << "."
            << endl;
       unlock_cerr_mutex(); 

       return ret_val;

   }

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_undelete_handle_value' "
            << "successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_undelete_handle_value| definition   */




@q **** (4) |server_action_undelete_file|.  @>

@ |server_action_undelete_file|.
\initials{LDF 2013.08.15.}

\LOG
\initials{LDF 2013.08.15.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_undelete_file| definition@>=
int
Scan_Parse_Parameter_Type::server_action_undelete_file(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Entering `Scan_Parse_Parameter_Type::server_action_undelete_file':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;

       response.show("response:");

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_file| definition@>=

   status = undelete_files(response, thread_str);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "ERROR!  In Scan_Parse_Parameter_Type::server_action_undelete_file:"
            << endl
            << "`Scan_Parse_Parameter_Type::undelete_files' failed, returning "
            << status << "."
            << endl
            << "Continuing."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

   }  /* |if (status != 0)|  */

   else
   {
#if DEBUG_COMPILE
      if (DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << thread_str 
               << "In Scan_Parse_Parameter_Type::server_action_undelete_file:"
               << endl
               << "`Scan_Parse_Parameter_Type::undelete_files' succeeded, returning 0."
               << endl;
          unlock_cerr_mutex(); 

      }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_file| definition@>=

   status = send_to_peer(0, 1);  /* |Scan_Parse_Parameter_Type::undelete_files|
                                    takes care of creating any responses to
                                    send to the client.
                                    \initials{LDF 2013.08.16.}  */

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_undelete_file':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_undelete_file':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_undelete_file' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;


}  /* End of |Scan_Parse_Parameter_Type::server_action_undelete_file|  definition  */

@q **** (4) |server_action_delete_metadata|.  @>

@ |server_action_delete_metadata|.
\initials{LDF 2013.10.31.}

\LOG
\initials{LDF 2013.10.31.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_delete_metadata| definition@>=

int
Scan_Parse_Parameter_Type::server_action_delete_metadata(Response_Type &response)
{ 
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   int status;

   int ret_val = 0;

   stringstream temp_strm;

   ofstream out_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

   char buffer[BUFFER_SIZE];

   memset(buffer, 0, BUFFER_SIZE);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_delete_metadata':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_metadata| definition@>=

   status = Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion(mysql_ptr,
                                                                     response,
                                                                     response_deque,
                                                                     irods_current_dir,
                                                                     user_id,
                                                                     errors_occurred,
                                                                     warnings_occurred,
                                                                     thread_str);

   if (remote_connection == true)
   {
       status = gnutls_record_send (session, buffer, 1);
   }
   else
   {
       status = send(sock, buffer, 1, 0);     
   }

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_delete_metadata| definition@>=

   if (status == -1) 
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Scan_Parse_Parameter_Type::server_action_delete_metadata':  "
            << "`send' failed, returning -1." << endl
            << "send error:  " << strerror(errno)
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;      

   }   /* |if (status == -1)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Scan_Parse_Parameter_Type::server_action_delete_metadata':  "
            << "`send' succeeded, returning " << status << "."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       if (ret_val == 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_str 
                << "Exiting `Scan_Parse_Parameter_Type::server_action_delete_metadata' "
                << "successfully with return value 0."
                << endl;
           unlock_cerr_mutex(); 
       }

       else 
       {
           lock_cerr_mutex(); 
           cerr << thread_str 
                << "Exiting `Scan_Parse_Parameter_Type::server_action_delete_metadata' "
                << "unsuccessfully with return value " << ret_val << "."
                << endl;
           unlock_cerr_mutex(); 
       }

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

   return ret_val;

}  /* End of |Scan_Parse_Parameter_Type::server_action_delete_metadata| definition  */

@q **** (4) |server_action_undelete_metadata|.  @>

@ |server_action_undelete_metadata|.
\initials{LDF 2013.10.31.}

\LOG
\initials{LDF 2013.10.31.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_undelete_metadata| definition@>=

int
Scan_Parse_Parameter_Type::server_action_undelete_metadata(Response_Type &response)
{ 
   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   stringstream temp_strm;

   ofstream out_strm;

   string thread_str;

   int status;

   int ret_val = 0;

   char buffer[BUFFER_SIZE];

   memset(buffer, 0, BUFFER_SIZE);

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering "
            << "`Scan_Parse_Parameter_Type::server_action_undelete_metadata':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_metadata| definition@>=

   status = Dublin_Core_Metadata_Type::undelete_dc_metadata(mysql_ptr,
                                                            response,
                                                            response_deque,
                                                            irods_current_dir,
                                                            user_id,
                                                            errors_occurred,
                                                            warnings_occurred,
                                                            thread_str);

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_metadata| definition@>=

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_undelete_metadata':"
            << endl 
            << "`Dublin_Core_Metadata_Type::undelete_dc_metadata' failed, "
            << "returning " << status << "."
            << endl
            << "Failed to unmark Dublin Core metadata for deletion."
            << endl
            << "Will send an error message to the client and "
            << "exit function unsuccessfully with return value 2."
            << endl;
       unlock_cerr_mutex(); 

       ret_val = 2;

   }  /* |if (status != 0)|  */


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_metadata| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Scan_Parse_Parameter_Type::server_action_undelete_metadata':"
            << endl 
            << "`Dublin_Core_Metadata_Type::undelete_dc_metadata' succeeded, "
            << "returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */    

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_metadata| definition@>=

   if (remote_connection == true)
   {
       status = gnutls_record_send (session, buffer, 1);
   }
   else
   {
       status = send(sock, buffer, 1, 0);     
   }

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_undelete_metadata| definition@>=

   if (status == -1) 
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Scan_Parse_Parameter_Type::server_action_undelete_metadata':  "
            << "`send' failed, returning -1." << endl
            << "send error:  " << strerror(errno)
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;      

   }   /* |if (status == -1)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Scan_Parse_Parameter_Type::server_action_undelete_metadata':  "
            << "`send' succeeded, returning " << status << "."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       if (ret_val == 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_str 
                << "Exiting `Scan_Parse_Parameter_Type::server_action_undelete_metadata' "
                << "successfully with return value 0."
                << endl;
           unlock_cerr_mutex(); 
       }

       else 
       {
           lock_cerr_mutex(); 
           cerr << thread_str 
                << "Exiting `Scan_Parse_Parameter_Type::server_action_undelete_metadata' "
                << "unsuccessfully with return value " << ret_val << "."
                << endl;
           unlock_cerr_mutex(); 
       }

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

   return ret_val;

}  /* End of |Scan_Parse_Parameter_Type::server_action_undelete_metadata| definition  */

@q **** (4) |server_action_fetch_metadata|.  @>

@ |server_action_fetch_metadata|.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this function.

\initials{LDF 2013.12.18.}
Renamed this function from |Scan_Parse_Parameter_Type::server_action_show_metadata|
to
|Scan_Parse_Parameter_Type::server_action_fetch_metadata|.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_fetch_metadata| definition@>=

int
Scan_Parse_Parameter_Type::server_action_fetch_metadata(Response_Type &response)
{ 
   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   stringstream temp_strm;

   ofstream out_strm;

   string thread_str;

   int status;

   int ret_val = 0;

   char buffer[BUFFER_SIZE];

   memset(buffer, 0, BUFFER_SIZE);

   char *buffer_ptr = buffer;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering "
            << "`Scan_Parse_Parameter_Type::server_action_fetch_metadata':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;

       response.show("response:");

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
\LOG
\initials{LDF 2013.12.16.}
Changed  |vector<Dublin_Core_Metadata_Type> dc_metadata_vector| to 
|map<unsigned long int, Dublin_Core_Metadata_Type> dc_metadata_map|.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::server_action_fetch_metadata| definition@>=

   map<unsigned long int, Dublin_Core_Metadata_Type> dc_metadata_map;
   vector<string> irods_object_path_vector;
   vector<unsigned int> id_vector;

   bool wrote_to_file = false;

   char temp_filename[] = "/tmp/gwirdsif.XXXXXX";

   for (vector<int>::iterator iter = response.int_vector.begin();
        iter != response.int_vector.end();
        ++iter)
      id_vector.push_back(static_cast<unsigned int>(*iter)); 

   status = Dublin_Core_Metadata_Type::get_dc_metadata_from_database(mysql_ptr,
                                                                     response,
                                                                     dc_metadata_map,
                                                                     irods_object_path_vector,
                                                                     id_vector,
                                                                     false,
                                                                     0U,
                                                                     "gwirdsif", 
                                                                     thread_str);

@q ***** (5) @>

   if (status == 2)
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str << "In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':"
                << endl
                << "`Dublin_Core_Metadata_Type::get_dc_metadata_from_database' returned 2:"
                << endl 
                << "No rows found."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */        

       temp_strm.str("");

       temp_strm << "FETCH METADATA RESPONSE " << GW_WARNING << " " 
                 << response.options << "U "
                 << "\"No Dublin Core metadata found\"";

       strcpy(buffer, temp_strm.str().c_str());

   }  /* |if (status == 2)|  */

@q ***** (5) @>

   else if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':"
            << endl 
            << "`Dublin_Core_Metadata_Type::get_dc_metadata_from_database' failed, "
            << "returning " << status << "."
            << endl
            << "Failed to retrieve Dublin Core metadata from database."
            << endl
            << "Will send an error message to the client and "
            << "exit function unsuccessfully with return value 2."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "FETCH METADATA RESPONSE " << GW_ERROR << " " 
                 << response.options << "U  "
                 << "\"Failed to retrieve Dublin Core metadata\"";

       strcpy(buffer, temp_strm.str().c_str());

       ret_val = 2;

   }  /* |else if (status != 0)|  */

@q ***** (5) @>

   else if (status == 0 && dc_metadata_map.size() == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':"
            << endl 
            << "`Dublin_Core_Metadata_Type::get_dc_metadata_from_database' succeeded, "
            << "returning 0, but `dc_metadata_map' is empty."
            << endl
            << "This shouldn't be possible."
            << endl 
            << "Will send an warning message to the client and "
            << "exit function unsuccessfully with return value 2."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "FETCH METADATA RESPONSE " << GW_WARNING << " " 
                 << response.options << "U "
                 << "\"Failed to retrieve Dublin Core metadata\"";

       strcpy(buffer, temp_strm.str().c_str());

       ret_val = 2;

   }  /* |else if (status == 0 && dc_metadata_map.size() == 0)|  */

@q ***** (5) @>

   else 
   {
@q ****** (6) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str << "In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':"
                << endl 
                << "`Dublin_Core_Metadata_Type::get_dc_metadata_from_database' "
                << "succeeded, returning 0:"
                << endl
                << "`dc_metadata_map.size()' == " << dc_metadata_map.size()
                << endl;

           for (map<unsigned long int, Dublin_Core_Metadata_Type>::iterator iter 
                   = dc_metadata_map.begin();
                iter != dc_metadata_map.end();
                ++iter)
           {
               iter->second.show("", false);
           }   

           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

       temp_strm.str("");

       temp_strm << "FETCH METADATA RESPONSE " << GW_SUCCESS << " " 
                 << response.options << "U \"Success\" ";

@q ****** (6) @>

       for (map<unsigned long int, Dublin_Core_Metadata_Type>::iterator iter 
               = dc_metadata_map.begin();
            iter != dc_metadata_map.end();
            ++iter)
       {
@q ******* (7) @>

           temp_strm << "DUBLIN_CORE_METADATA " 
                     << iter->second.id << "UL " 
                     << iter->second.user_id << "UL "
                     << iter->second.irods_server_id << "U "
                     << "\"" << iter->second.irods_object_path << "\" "
                     << "\"" << iter->second.dc_metadata_irods_object_path << "\" "
                     << iter->second.handle_id << "UL " 
                     << iter->second.irods_object_ref_id << "UL "
                     << iter->second.irods_object_self_id << "UL "
                     << "\"" << iter->second.created_str << "\" "
                     << static_cast<unsigned long int>(iter->second.created) << "UL " 
                     << "\"" << iter->second.last_modified_str << "\" "
                     << static_cast<unsigned long int>(iter->second.last_modified) << "UL "
                     << static_cast<int>(iter->second.marked_for_deletion) << " "
                     << iter->second.delete_file << " "
                     << "\"" << iter->second.delete_from_database_timestamp_str << "\" "
                     << static_cast<unsigned long int>(
                           iter->second.delete_from_database_timestamp) 
                     << "UL ";


#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << thread_str 
                    << "In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':"
                    << endl
                    << "`temp_strm.str() =="
                    << endl
                    << temp_strm.str()
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>



           if (iter->second.metadata_sub_map.size() > 0)
           {

              for (multimap<unsigned int, Dublin_Core_Metadata_Sub_Type>::iterator iter_1 
                      = iter->second.metadata_sub_map.begin();
                   iter_1 != iter->second.metadata_sub_map.end();
                   ++iter_1)
               {

                  temp_strm << "DUBLIN_CORE_METADATA_SUB " 
                            << iter_1->second.id << "UL "
                            << iter_1->second.metadata_id << "UL "
                            << iter_1->second.element_id << "U "
                            << iter_1->second.qualifier_id << "U "
                            << iter_1->second.term_id << "U "
                            << "\"" << iter_1->second.value << "\" ";

                   for (multimap<string, string>::iterator iter_2
                          = iter_1->second.attribute_map.begin();
                        iter_2 != iter_1->second.attribute_map.end();
                        ++iter_2)
                   {
                       temp_strm << "\"" << iter_2->first << "\" "
                                 << "\"" << iter_2->second << "\" ";
                   }

               }  /* |for|  */

           }  /* |if (iter->metadata_sub_map.size() > 0)|  */

@q ******* (7) @>

       }  /* |for|  */   

@q ****** (6) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str << "In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':"
                << endl 
                << "`temp_strm.str().length()' == " << temp_strm.str().length()
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

       if (wrote_to_file == true)
       {
           out_strm << temp_strm.str();
           temp_strm.str("");

       }
       else if (strlen(buffer) + temp_strm.str().size() <  BUFFER_SIZE - 1)
       {
           strcat(buffer, temp_strm.str().c_str());
       }
       else
       {
@q ******* (7) @>
           
           errno = 0;
           status = mkstemp(temp_filename);

@q ******* (7) @>

           if (status == -1)  
           {
               lock_cerr_mutex(); 
               cerr << thread_str 
                    << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':"
                    << endl 
                    << "`mkstemp' failed, returning -1:"
                    << endl
                    << strerror(errno)
                    << endl 
                    << "Failed to create temporary file."
                    << endl
                    << "Will send an error message to the client and "
                    << "exit function unsuccessfully with return value 2."
                    << endl;
               unlock_cerr_mutex(); 

               temp_strm.str("");

               temp_strm << "FETCH METADATA RESPONSE " << GW_ERROR << " " 
                         << response.options << "U "
                         << "\"Failed to create temporary file for Dublin Core metadata\"";

               strcpy(buffer, temp_strm.str().c_str());

               ret_val = 2;

               goto END_SHOW_METADATA;


           }  /* |if (status == -1)  |  */

@q ******* (7) @>

           close(status);  /* We just need the name.  \initials{LDF 2013.12.16.}  */
           
           temp_file_vector.push_back(temp_filename);

           out_strm.open(temp_filename);

           if (!(out_strm && out_strm.is_open() && out_strm.good()))
           {
               lock_cerr_mutex(); 
               cerr << thread_str 
                    << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':"
                    << endl 
                    << "`ofstream::open' failed."
                    << endl
                    << "Failed to open temporary file `" << temp_filename << "'."
                    << endl
                    << "Will send an error message to the client and "
                    << "exit function unsuccessfully with return value 2."
                    << endl;
               unlock_cerr_mutex(); 

               temp_strm.str("");

               temp_strm << "FETCH METADATA RESPONSE " << GW_ERROR << " " 
                         << response.options << "U "
                         << "\"Failed to open temporary file for Dublin Core metadata\"";

               strcpy(buffer, temp_strm.str().c_str());

               ret_val = 2;

               goto END_SHOW_METADATA;

           }  /* |if|  */
          
@q ******* (7) @>

#if DEBUG_COMPILE
           else if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << thread_str 
                    << "In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':"
                    << endl 
                    << "`ofstream::open' succeeded.  Opened temporary file "
                    << "`" << temp_filename << "' "
                    << "for writing successfully."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           out_strm << temp_strm.str();

           wrote_to_file = true;    

@q ******* (7) @>

       }  /* |else|  */

@q ****** (6) @>
       
   }  /* |else|  */

@q ***** (5) @>

END_SHOW_METADATA:

   if (wrote_to_file)
   {
      out_strm.close();
   }

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':"
            << endl 
            << "buffer == " 
            << endl 
            << buffer 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_fetch_metadata| definition@>=

   if (wrote_to_file)
   {
       status = send_to_peer(0, 0, temp_filename);
   }
   else
   {
       status = send_to_peer(&buffer_ptr, 0);
   }

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;      

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 



@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_fetch_metadata| definition@>=

   if (status == -1) 
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':  "
            << "`send' failed, returning -1." << endl
            << "send error:  " << strerror(errno)
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;      

   }   /* |if (status == -1)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Scan_Parse_Parameter_Type::server_action_fetch_metadata':  "
            << "`send' succeeded, returning " << status << "."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       if (ret_val == 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_str 
                << "Exiting `Scan_Parse_Parameter_Type::server_action_fetch_metadata' "
                << "successfully with return value 0."
                << endl;
           unlock_cerr_mutex(); 
       }

       else 
       {
           lock_cerr_mutex(); 
           cerr << thread_str 
                << "Exiting `Scan_Parse_Parameter_Type::server_action_fetch_metadata' "
                << "unsuccessfully with return value " << ret_val << "."
                << endl;
           unlock_cerr_mutex(); 
       }

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

   return ret_val;

}  /* End of |Scan_Parse_Parameter_Type::server_action_fetch_metadata| definition  */

@q **** (4) |server_action_mv|.  @>
@
\LOG
\initials{LDF 2013.12.19.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_mv| definition@>=
int
Scan_Parse_Parameter_Type::server_action_mv(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string temp_filename;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

   int ret_val;

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_mv':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_mv| definition@>=

   status = mv(response, thread_str);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_mv':"
            << endl 
            << "`Scan_Parse_Parameter_Type::mv' failed, returning " 
            << status << "."
            << endl
            << "Will exit function unsuccessfully with return value 2."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       ret_val = 2;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_mv':"
            << endl 
            << "`Scan_Parse_Parameter_Type::mv' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_mv| definition@>=

   status = send_to_peer(0, 1);  /* Send a single NULL byte to client, 
                                    so it won't block.
                                    \initials{LDF 2013.05.23.}  */

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_mv| definition@>=

   if (ret_val != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_mv' unsuccessfully "
            << "with return value " << ret_val << "."
            << endl;
       unlock_cerr_mutex(); 

   }

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_mv| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_mv' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return ret_val;

}  /* End of |Scan_Parse_Parameter_Type::server_action_mv| definition   */

@q **** (4) Generate checksum (|Scan_Parse_Parameter_Type::server_action_generate_checksum|).  @>
@
@<|Scan_Parse_Parameter_Type::server_action_generate_checksum| definition@>=

int
Scan_Parse_Parameter_Type::server_action_generate_checksum(Response_Type &response)
{

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string temp_filename;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

   int ret_val;

   Response_Type new_response;
   new_response.type = Response_Type::COMMAND_ONLY_TYPE;

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Entering `Scan_Parse_Parameter_Type::server_action_generate_checksum':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_generate_checksum| definition@>=

   status = generate_checksum(response, false, thread_str);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_generate_checksum':"
            << endl 
            << "`Scan_Parse_Parameter_Type::generate_checksum' failed, returning " 
            << status << "."
            << endl
            << "Will exit function unsuccessfully with return value 2."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       ret_val = 2;

   }  /* |if (status != 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_generate_checksum| definition@>=

   else
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_generate_checksum':"
                << endl 
                << "`Scan_Parse_Parameter_Type::generate_checksum' succeeded, returning 0."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |else|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_generate_checksum| definition@>=

   status = send_to_peer(0, 1);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_generate_checksum| definition@>=

   if (ret_val != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_generate_checksum' "
            << "unsuccessfully with return value " << ret_val << "."
            << endl;
       unlock_cerr_mutex(); 

   }

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_generate_checksum| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_generate_checksum' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return ret_val;


}  /* End of |Scan_Parse_Parameter_Type::server_action_generate_checksum| definition   */


@q **** (4) Verify checksum (|Scan_Parse_Parameter_Type::server_action_verify_checksum|).  @>
@
@<|Scan_Parse_Parameter_Type::server_action_verify_checksum| definition@>=

int
Scan_Parse_Parameter_Type::server_action_verify_checksum(Response_Type &response)
{
   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string temp_filename;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

   int ret_val;

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Entering `Scan_Parse_Parameter_Type::server_action_verify_checksum':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl 
            << "`response.remote_filename' == `" << response.remote_filename << "'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_verify_checksum| definition@>=

   status = generate_checksum(response, true, thread_str);

   if (status == 2)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "NOTICE!  In `Scan_Parse_Parameter_Type::server_action_verify_checksum':"
            << endl 
            << "`Scan_Parse_Parameter_Type::generate_checksum' returned 2:"
            << endl
            << "Checksum not verified."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (status == 2)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_verify_checksum| definition@>=


   else if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_verify_checksum':"
            << endl 
            << "`Scan_Parse_Parameter_Type::generate_checksum' failed, returning " 
            << status << "."
            << endl
            << "Will exit function unsuccessfully with return value 2."
            << endl;
       unlock_cerr_mutex(); 

       ret_val = 2;

   }  /* |else if (status != 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_verify_checksum| definition@>=

   else
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::server_action_verify_checksum':"
                << endl 
                << "`Scan_Parse_Parameter_Type::generate_checksum' succeeded, returning 0."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |else|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_verify_checksum| definition@>=

   status = send_to_peer(0, 1);    /* Send a single NULL byte to client, 
                                      so it won't block.
                                      \initials{LDF 2013.05.23.}  */

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_verify_checksum| definition@>=

   if (ret_val != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_verify_checksum' "
            << "unsuccessfully with return value " << ret_val << "."
            << endl;
       unlock_cerr_mutex(); 

   }

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_verify_checksum| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_verify_checksum' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return ret_val;


}  /* End of |Scan_Parse_Parameter_Type::server_action_verify_checksum| definition   */

@q **** (4) Store public key (|Scan_Parse_Parameter_Type::server_action_store_public_key|).  @>
@
\LOG
\initials{LDF 2014.01.21.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_store_public_key| definition@>=

int
Scan_Parse_Parameter_Type::server_action_store_public_key(Response_Type &response)
{
   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string temp_filename;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

   int ret_val = 0;

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Entering `Scan_Parse_Parameter_Type::server_action_store_public_key':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_store_public_key| definition@>=

   Response_Type new_response;
   new_response.type = Response_Type::COMMAND_ONLY_TYPE;

   temp_strm << "SEND PUBLIC_KEY 0 \"" << response.string_val << "\" 0U \"\"";

   new_response.command = temp_strm.str();

   response_deque.push_back(new_response);

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_store_public_key| definition@>=

   status = send_to_peer(0, 1);    /* Send a single NULL byte to client, 
                                      so it won't block.
                                      \initials{LDF 2013.05.23.}  */

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_store_public_key':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_store_public_key':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_store_public_key| definition@>=

   if (ret_val != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_store_public_key' "
            << "unsuccessfully with return value " << ret_val << "."
            << endl;
       unlock_cerr_mutex(); 

   }

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_store_public_key| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_store_public_key' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return ret_val;


}  /* End of |Scan_Parse_Parameter_Type::server_action_store_public_key| definition   */


@q **** (4) Register pull (|Scan_Parse_Parameter_Type::server_action_register_pull|).  @>
@
\LOG
\initials{LDF 2014.01.31.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type::server_action_register_pull| definition@>=

int
Scan_Parse_Parameter_Type::server_action_register_pull(Response_Type &response)
{
   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string temp_filename;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

   int ret_val = 0;

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_register_pull| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Entering `Scan_Parse_Parameter_Type::server_action_register_pull':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;

       response.show("response:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_register_pull| definition@>=

   Pull_Request_Type *pull_request 
      = static_cast<Pull_Request_Type*>(response.pointer_val); 

   response.pointer_val = static_cast<void*>(0);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       pull_request->show("*pull_request:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_register_pull| definition@>=

   status = process_pull_request(response, pull_request, thread_str);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_register_pull':"
            << endl 
            << "`Scan_Parse_Parameter_Type::process_pull_request' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 2."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred; 

   }  /* |if (status != 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_register_pull| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_register_pull':"
            << endl 
            << "`Scan_Parse_Parameter_Type::process_pull_request' succeeded, returning 0." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_register_pull| definition@>=

   status = send_to_peer(0, 1);    /* Send a single NULL byte to client, 
                                      so it won't block.
                                      \initials{LDF 2013.05.23.}  */

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "ERROR!  In `Scan_Parse_Parameter_Type::server_action_register_pull':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::server_action_register_pull':"
            << endl 
            << "`Scan_Parse_Parameter_Type::send_to_peer' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_register_pull| definition@>=

   if (ret_val != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_register_pull' "
            << "unsuccessfully with return value " << ret_val << "."
            << endl;
       unlock_cerr_mutex(); 

   }

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::server_action_register_pull| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_register_pull' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   delete pull_request;

   pull_request = 0;

   return ret_val;


}  /* End of |Scan_Parse_Parameter_Type::server_action_register_pull| definition   */




@q **** (4) |server_action_unknown|.  @>
@
@<|Scan_Parse_Parameter_Type::server_action_unknown| definition@>=
int
Scan_Parse_Parameter_Type::server_action_unknown(Response_Type &response)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status;

   char buffer[BUFFER_SIZE];
   char *buffer_ptr = buffer;
   memset(buffer, 0, BUFFER_SIZE);

   stringstream temp_strm;

   string thread_str;

   temp_strm << "[Thread " << thread_ctr << "] ";

   thread_str = temp_strm.str();

   temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::server_action_unknown':"
            << endl
            << "`response.type' == " 
            << Response_Type::typename_map[response.type] << " (" << response.type << ")"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ***** (5) @>

   lock_cerr_mutex(); 
   cerr << thread_str
        << "WARNING!  In `Scan_Parse_Parameter_Type::server_action_unknown':  "
        << "`response.type' == " 
        << Response_Type::typename_map[response.type] << " (" << response.type << ")"
        << endl 
        << "This case hasn't been accounted for yet.  Sending a single NULL byte to "
        << "client (so it won't block) and continuing."
        << endl;
   unlock_cerr_mutex(); 

   ++warnings_occurred;

   memset(buffer, 0, BUFFER_SIZE);

   if (remote_connection == true)
   {
       status = gnutls_record_send (session, buffer, 1);
   }
   else
   {
       status = send(sock, buffer, 1, 0);     
   }

@q ***** (5) @>

   if (status == -1) 
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Scan_Parse_Parameter_Type::server_action_unknown':  "
            << "`send' failed, returning -1." << endl
            << "send error:  " << strerror(errno)
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;      

   }   /* |if (status == -1)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Scan_Parse_Parameter_Type::server_action_unknown':  "
            << "`send' succeeded, returning " << status << "."
            << endl;

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::server_action_unknown' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::server_action_unknown| definition  */


@q **** (4) @>

@
@c
@<Include files@>@;@/
using namespace std;
using namespace gwrdifpk;
@<|Scan_Parse_Parameter_Type::server_action_command_only| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_send_file| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_receive_put_file| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_receive_metadata_file| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_send_handle| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_ls| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_pwd| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_cd| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_mkdir| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_get| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_send_metadata| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_end_server| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_sleep| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_show_certificate| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_get_metadata| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_get_handle| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_send_tan_list| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_process_pending| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_get_user_info| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_create_handle| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_add_handle_value| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_delete_handle| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_delete_handle_value| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_undelete_handle_value| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_undelete_file| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_delete_metadata| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_undelete_metadata| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_fetch_metadata| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_mv| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_generate_checksum| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_verify_checksum| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_store_public_key| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_register_pull| definition@>@;@/
@<|Scan_Parse_Parameter_Type::server_action_unknown| definition@>@;@/


@q *** (3) This is what's written to the header file `srvractn.h'.  @>

@ This is what's written to the header file \filename{srvractn.h}.
\initials{LDF 2013.05.29.}

@(srvractn.h@>=
#ifndef SRVRACTN_H
#define SRVRACTN_H 1
/* Empty  */
#endif 

@q ** (2) @>

@q * (1) Emacs-Lisp code for use in indirect buffers  @>

@q (progn (cweb-mode) (outline-minor-mode))                          @>

@q * (1) Local variables for Emacs @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q abbrev-mode:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>
