@q prsrclnt.web@>
@q Created by Laurence D. Finston (LDF) Mon Jul 30 09:42:25 CEST 2012  @>

@q * (1) Copyright and License.@>

@q This file is part of gwrdifpk, a package for long-term archiving.  @>
@q Copyright (C) 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021 Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen @>

@q gwrdifpk is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q gwrdifpk is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License          @>
@q along with gwrdifpk; if not, write to the Free Software                    @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q gwrdifpk is available for downloading via Git from @>
@q https://github.com/gwdg/gwrdifpk.git    @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de@>

@q Laurence D. Finston                                                   @>
@q Kreuzbergring 41         					         @>
@q 37075 Goettingen              					 @>
@q Germany                           					 @>                                

@q Laurence.Finston@@gmx.de (@@ stands for a single "at" sign.)@>



@q * (1) Client Parser.  @>
@* Client Parser.
\initials{LDF 2012.07.30.}

@q ** (2) Include files.@>
@ Include files.

@<Include files@>=

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <limits.h>
#include <signal.h>

#include <algorithm>
#include <fstream>
#include <iomanip>
#include <ios>
#include <iostream>
#include <iterator>
#include <time.h>
#include <math.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include <sstream>   
#include <map>
#include <vector>
#include <deque>
#include <stack>
#include <set>
#include <bitset>

#include <pthread.h>

#include <expat.h>

#if HAVE_CONFIG_H
#include "config.h"
#endif

#include <gcrypt.h> /* for |gcry_control| */
#include <gnutls/gnutls.h>
#include<gnutls/x509.h>

#include <mysql.h>

#undef NAME_LEN
#undef LOCAL_HOST

#include "rspercds.h++"
#include "glblcnst.h++"
#include "glblvrbl.h++"
#include "gpgkprtp.h++"
#include "utilfncs.h++"
#include "grouptp.h++"
#include "hndlvltp.h++"
#include "irdsavtp.h++"
#include "pidfncs.h++" 
#include "tanfncs.h++" 
#include "prsrclnt.h++"  
#include "scnrclnt.h++"
#include "rspnstp.h++"
#include "irdsobtp.h++"
#include "hndltype.h++"
#include "dcmdsbtp.h++"
#include "dcmtdttp.h++"
#include "x509cert.h++"
#include "dstngnmt.h++"
#include "pullrqtp.h++"
#include "scprpmtp.h++"
#include "usrinftp.h++"

@q ** (2) Declarations of additional functions.@>
@ Declarations of additional functions.

@<Declarations of additional functions@>=

int 
zzlex(YYSTYPE* lvalp, yyscan_t parameter);

int
zzwrap(void);

int
zzerror(void* v, char const* s);

@q ** (2) Options.@>
@ Options.

@<Options@>=
@=%verbose@>@;@/
@=%pure-parser@>@;@/
@=%parse-param {yyscan_t parameter}@>@;@/
@=%name-prefix="zz"@>@;@/
@=%lex-param {yyscan_t parameter}@>@;@/
@=%debug@>

@q ** (2) |union| declaration.@>
@ {\bf union} declaration.

\LOG
\initials{LDF 2012.09.28.}
Added |unsigned int uint_value|.

\initials{LDF 2013.04.28.}
Added |void *pointer_value|.
\ENDLOG 

@<|union| declaration@>=

@=%union {@>

  int int_value;
  unsigned int uint_value;
  unsigned long int ulint_value;
  float float_value;
  char string_value[1024];
  void *pointer_value;

@=}@>

@q ** (2) Token and type declarations.@>
@ Token and type declarations.
\initials{LDF 2012.07.30.}


\LOG
\initials{LDF 2012.07.30.}
Added token declarations for |SERVER_ZZ| and |FINISHED_ZZ|.

\initials{LDF 2012.09.10.}
Added token declarations for |FAILED_ZZ| and |SUCCEEDED_ZZ|.

\initials{LDF 2012.09.26.}
Added token declaration for |PUT_ZZ|.

\initials{LDF 2012.09.27.}
Added token declaration for |RECEIVE_ZZ|.

\initials{LDF 2012.10.10.}
Added token declaration for |PIDS_ZZ|.

\initials{LDF 2012.10.12.}
Added token declarations for |UNSIGNED_INTEGER_ZZ|, 
|ATTRIBUTE_ZZ|, |VALUE_ZZ|, |UNITS_ZZ| and |TIME_SET_ZZ|.

\initials{LDF 2012.10.12.}
Added the token declarations for |HANDLE_ZZ|, |HANDLES_ZZ|, |HANDLE_VALUE_ZZ|
and |HANDLE_VALUES_ZZ|.

\initials{LDF 2012.10.16.}
Added token declarations for 
|IDX_ZZ|, 
|TYPE_ZZ|, 
|DATA_ZZ|, 
|DATA_LENGTH_ZZ|, 
|TTL_TYPE_ZZ|, 
|TTL_ZZ|, 
|TIMESTAMP_ZZ|, 
|REFS_ZZ|, 
|REFS_LENGTH_ZZ|, 
|ADMIN_READ_ZZ|, 
|ADMIN_WRITE_ZZ|, 
|PUB_READ_ZZ|, 
|PUB_WRITE_ZZ|, 
|HANDLE_ID_ZZ|, 
|HANDLE_VALUE_ID_ZZ|, 
|CREATED_ZZ| and 
|LAST_MODIFIED_ZZ|.

\initials{LDF 2012.10.16.}
Added token declaration for |UNSIGNED_LONG_INTEGER_ZZ|.

\initials{LDF 2012.11.19.}
Added token declarations for |CLIENT_SIDE_FILENAME_ZZ| and |OVERWRITE_ZZ|.

\initials{LDF 2012.11.21.}
Added token declarations for |LOCAL_FILENAME_ZZ|, |REMOTE_FILENAME_ZZ|, |FLAG_ZZ|
and |REFERENCE_ZZ|.

\initials{LDF 2012.12.13.}
Added token declaration for |SENDING_ZZ|.

\initials{LDF 2012.12.14.}
Added token declaration for |ADD_ZZ|.

\initials{LDF 2012.12.31.}
Added token declaration for |OUTPUT_ZZ|.

\initials{LDF 2013.02.28.}
Added token declaration for |CREATED_BY_USER_ZZ|

\initials{LDF 2013.03.07.}
Added token declaration for |STORE_ZZ|.

\initials{LDF 2013.04.03.}
Added token declaration for |END_SERVER_ZZ|.

\initials{LDF 2013.04.05.}
Added token declaration for |DUMMY_STATEMENT_ZZ|.

\initials{LDF 2013.04.19.}
Added token declaration for |SLEEP_ZZ|.

\initials{LDF 2013.04.26.}
Added token declarations for |HEXL_ENCODED_STRING_ZZ|
and |DATA_HEXL_ENCODED_ZZ|.

\initials{LDF 2013.04.28.}
Changed the type of |HEXL_ENCODED_STRING_ZZ| from |char_value| to |pointer_value|.
Added token declaration for |REFS_HEXL_ENCODED_ZZ|.

\initials{LDF 2013.05.02.}
Added token declaration for |SIGNAL_ZZ|.

\initials{LDF 2013.05.03.}
Added token declarations for |CERTIFICATE_ZZ|, |CERTIFICATES_ZZ|, |FOR_ZZ| 
and |ALL_ZZ|.

\initials{LDF 2013.05.10.}
Added token declarations for |AUTHENTICATION_ZZ| and |ERROR_ZZ|.

\initials{LDF 2013.05.15.}
Added the following token declarations:
|CERTIFICATE_ID_ZZ|\hfil\break 
|USER_ID_ZZ|\hfil\break
|ISSUER_CERT_ID_ZZ|\hfil\break
|USER_NAME_ZZ|\hfil\break
|ORGANIZATION_ZZ|\hfil\break
|ORGANIZATIONAL_UNIT_NAME_ZZ|\hfil\break
|COMMON_NAME_ZZ|\hfil\break
|COUNTRY_NAME_ZZ|\hfil\break
|LOCALITY_NAME_ZZ|\hfil\break
|STATE_OR_PROVINCE_NAME_ZZ|\hfil\break
|SERIAL_NUMBER_ZZ|\hfil\break
|VALIDITY_NOT_BEFORE_ZZ|\hfil\break
|VALIDITY_NOT_AFTER_ZZ|\hfil\break
|IS_CA_ZZ|\hfil\break
|IS_PROXY_ZZ|

\initials{LDF 2013.05.16.}
Added token declaration for |GET_USER_ZZ|.

\initials{LDF 2013.05.17.}
Added token declaration for |GET_USER_INFO_ZZ|.

\initials{LDF 2013.05.19.}
Added token declaration for |WHOAMI_ZZ|.

\initials{LDF 2013.05.22.}
Added token declarations for |PRIVILEGES_ZZ|, |IRODS_HOMEDIR_ZZ|, 
|IRODS_CURRENT_DIR_ZZ|, 
|IRODS_ZONE_ZZ|, |IRODS_DEFAULT_RESOURCE_ZZ|, |DEFAULT_HANDLE_PREFIX_ID_ZZ|,
|DEFAULT_HANDLE_PREFIX_ZZ|, |DEFAULT_INSTITUTE_ID_ZZ| and 
|DEFAULT_INSTITUTE_NAME_ZZ|.

\initials{LDF 2013.05.23.}
Added token declarations for |PROCESS_ZZ|, |PENDING_ZZ| and |OPERATIONS_ZZ|.

\initials{LDF 2013.06.04.}
Added token declarations for |GROUP_ZZ| and |GROUPS_ZZ|.

\initials{LDF 2013.06.05.}
Added token declarations for |GROUP_ID_ZZ|, |GROUP_NAME_ZZ|, |CREATOR_ID_ZZ|, 
and |CREATOR_USERNAME_ZZ|.

\initials{LDF 2013.07.04.}
Added token declarations for |UNDELETE_ZZ|, |DELETION_ZZ|, |MARK_ZZ| and |UNMARK_ZZ|.

\initials{LDF 2013.07.15.}
Added token declaration for |DELETED_ZZ|.

\initials{LDF 2013.08.07.}
Added token declaration for |IRODS_OBJECT_ZZ|.

\initials{LDF 2013.08.08.}
Added token declarations for |DELAY_ZZ| and |OPTION_ZZ|.

\initials{LDF 2013.08.12.}
Added token declaration for |DATABASE_ZZ|.

\initials{LDF 2013.08.22.}
Added token declaration for |MARKED_FOR_DELETION_ZZ|.

\initials{LDF 2013.08.26.}
Added token declarations for |DELETE_FROM_DATABASE_TIMESTAMP_ZZ|
and |IRODS_OBJECT_ID_ZZ|.

\initials{LDF 2013.08.30.}
Added token declaration for |HANDLE_VALUE_SPECIFICATION_ZZ|.

\initials{LDF 2013.12.06.}
Added token declaration for |DUBLIN_CORE_METADATA_ZZ|.

\initials{LDF 2013.12.16.}
Added token declaration for |DUBLIN_CORE_METADATA_SUB_ZZ|.

\initials{LDF 2013.12.18.}
Added token declaration for |FETCH_ZZ|.

\initials{LDF 2013.12.19.}
Added token declaration for |MV_ZZ|.

\initials{LDF 2013.12.24.}
Added token declarations for 
|CHECKSUM_ZZ|, 
|VERIFIED_ZZ|,
|NOT_VERIFIED_ZZ|,
|MD5_ZZ|,
|SHA1_ZZ|,
|SHA224_ZZ|,
|SHA256_ZZ|,
|SHA384_ZZ|
and
|SHA512_ZZ|.

\initials{LDF 2014.01.03.}
Replaced token declarations for |VERIFIED_ZZ| and |NOT_VERIFIED_ZZ| with
one for |VERIFY_ZZ|.

\initials{LDF 2014.01.07.}
Added the following token declarations:
|ENCRYPT_ZZ|,
|DECRYPT_ZZ|,
|SIGN_ZZ|,
|CLEARSIGN_ZZ|,
|DETACHED_ZZ|,
|SIGNATURE_ZZ|
and
|VERIFY_SIGNATURE_ZZ|.

\initials{LDF 2014.01.16.}
Removed token declaration for |OVERWRITE_ZZ|.

\initials{LDF 2014.01.16.}
Added token declaration for |GPG_KEY_FINGERPRINT_ZZ|.

\initials{LDF 2014.01.21.}
Added token declaration for |PUBLIC_KEY_ZZ|.

\initials{LDF 2014.01.31.}
Added token declarations for |PULL_ZZ| and |REGISTER_ZZ|.
\ENDLOG 

@q *** (3) Code  @>

@<Token and type declarations@>=

%token<int_value>       INTEGER_ZZ@;@/
%token<uint_value>      UNSIGNED_INTEGER_ZZ@;@/
%token<uint_value>      UNSIGNED_LONG_INTEGER_ZZ@;@/

%token<int_value>       END_ZZ@;@/
%token<int_value>       END_SERVER_ZZ@;@/

%token<int_value>       CERTIFICATE_ZZ@;@/
%token<int_value>       CERTIFICATES_ZZ@;@/

%token<int_value>       CERTIFICATE_ID_ZZ@;@/
%token<int_value>       USER_ID_ZZ@;@/
%token<int_value>       ISSUER_CERT_ID_ZZ@;@/
%token<int_value>       USER_NAME_ZZ@;@/

%token<int_value>       GET_USER_ZZ@;@/
%token<int_value>       GET_USER_INFO_ZZ@;@/
%token<int_value>       WHOAMI_ZZ@;@/

%token<int_value>       PROCESS_ZZ@;@/
%token<int_value>       PENDING_ZZ@;@/
%token<int_value>       OPERATIONS_ZZ@;@/


%token<int_value>       ORGANIZATION_ZZ@;@/
%token<int_value>       ORGANIZATIONAL_UNIT_NAME_ZZ@;@/
%token<int_value>       COMMON_NAME_ZZ@;@/
%token<int_value>       COUNTRY_NAME_ZZ@;@/

%token<int_value>       LOCALITY_NAME_ZZ@;@/
%token<int_value>       STATE_OR_PROVINCE_NAME_ZZ@;@/
 
%token<int_value>       SERIAL_NUMBER_ZZ@;@/

%token<int_value>       VALIDITY_NOT_BEFORE_ZZ@;@/
%token<int_value>       VALIDITY_NOT_AFTER_ZZ@;@/

%token<int_value>       IS_CA_ZZ@;@/
%token<int_value>       IS_PROXY_ZZ@;@/

%token<int_value>       FOR_ZZ@;@/
%token<int_value>       ALL_ZZ@;@/

%token<int_value>       SIGNAL_ZZ@;@/

%token<string_value>    HANDLE_VALUE_SPECIFICATION_ZZ@;@/

@
@<Token and type declarations@>=

%token<int_value>       SLEEP_ZZ@;@/
%token<int_value>       DUMMY_STATEMENT_ZZ@;@/

%token<int_value>       ADD_ZZ@;@/
%token<int_value>       STORE_ZZ@;@/

%token<int_value>       FILE_ZZ@;@/
%token<string_value>    CLIENT_SIDE_FILENAME_ZZ@;@/
%token<int_value>       DIRECTORY_ZZ@;@/
%token<int_value>       LOCAL_ZZ@;@/
%token<int_value>       REMOTE_ZZ@;@/
%token<string_value>    LOCAL_FILENAME_ZZ@;@/
%token<string_value>    REMOTE_FILENAME_ZZ@;@/
%token<string_value>    FLAG_ZZ@;@/
%token<int_value>       REFERENCE_ZZ@;@/
%token<int_value>       MKDIR_ZZ@;@/
%token<int_value>       RM_ZZ@;@/
%token<int_value>       CREATE_ZZ@;@/
%token<int_value>       DELETE_ZZ@;@/
%token<int_value>       UNDELETE_ZZ@;@/
%token<int_value>       DELETION_ZZ@;@/
%token<int_value>       MARK_ZZ@;@/
%token<int_value>       UNMARK_ZZ@;@/
%token<int_value>       COPY_ZZ@;@/
%token<int_value>       MOVE_ZZ@;@/
%token<int_value>       RENAME_ZZ@;@/
%token<int_value>       CHMOD_ZZ@;@/
%token<int_value>       CHOWN_ZZ@;@/
%token<int_value>       SHOW_ZZ@;@/
%token<int_value>       USER_ZZ@;@/
%token<int_value>       INFO_ZZ@;@/
%token<int_value>       PWD_ZZ@;@/
%token<int_value>       CD_ZZ@;@/


@
@<Token and type declarations@>=

%token<int_value>       METADATA_ZZ@;@/
%token<int_value>       DUBLIN_CORE_METADATA_ZZ@;@/
%token<int_value>       DUBLIN_CORE_METADATA_SUB_ZZ@;@/
%token<int_value>       OUTPUT_ZZ@;@/
%token<int_value>       URI_ZZ@;@/
%token<int_value>       PASSWORD_ZZ@;@/
%token<int_value>       SU_ZZ@;@/
%token<int_value>       SET_ZZ@;@/
%token<int_value>       GET_ZZ@;@/
%token<int_value>       FETCH_ZZ@;@/
%token<int_value>       PUT_ZZ@;@/
%token<int_value>       SESSION_ZZ@;@/
%token<int_value>       LS_ZZ@;@/
%token<int_value>       MV_ZZ@;@/

%token<int_value>       REPOSITORY_ZZ@;@/
%token<int_value>       RESPONSE_ZZ@;@/
%token<int_value>       CONNECT_ZZ@;@/
%token<int_value>       DISCONNECT_ZZ@;@/
%token<int_value>       CONNECTION_ZZ@;@/
%token<int_value>       RESET_ZZ@;@/
%token<int_value>       WRITE_ZZ@;@/
%token<int_value>       READ_ZZ@;@/
%token<int_value>       TO_ZZ@;@/
%token<int_value>       DISTINGUISHED_NAME_ZZ@;@/
%token<string_value>    STRING_ZZ@;@/
%token<pointer_value>   HEXL_ENCODED_STRING_ZZ@;@/


%token<int_value>       SEND_ZZ@;@/
%token<int_value>       SENDING_ZZ@;@/
%token<int_value>       TAN_ZZ@;@/
%token<int_value>       LIST_ZZ@;@/

%token<int_value>       HANDLE_ZZ@;@/
%token<int_value>       HANDLES_ZZ@;@/

%token<int_value>       HANDLE_VALUE_ZZ@;@/
%token<int_value>       HANDLE_VALUES_ZZ@;@/

@
@<Token and type declarations@>=

%token<int_value>       IDX_ZZ@;@/
%token<int_value>       TYPE_ZZ@;@/
%token<int_value>       DATA_ZZ@;@/
%token<int_value>       DATA_LENGTH_ZZ@;@/
%token<int_value>       DATA_HEXL_ENCODED_ZZ@;@/
%token<int_value>       TTL_TYPE_ZZ@;@/
%token<int_value>       TTL_ZZ@;@/
%token<int_value>       TIMESTAMP_ZZ@;@/
%token<int_value>       REFS_ZZ@;@/
%token<int_value>       REFS_LENGTH_ZZ@;@/
%token<int_value>       REFS_HEXL_ENCODED_ZZ@;@/
%token<int_value>       ADMIN_READ_ZZ@;@/
%token<int_value>       ADMIN_WRITE_ZZ@;@/
%token<int_value>       PUB_READ_ZZ@;@/
%token<int_value>       PUB_WRITE_ZZ@;@/
%token<int_value>       HANDLE_ID_ZZ@;@/
%token<int_value>       HANDLE_VALUE_ID_ZZ@;@/
%token<int_value>       IRODS_OBJECT_ID_ZZ@;@/

%token<int_value>       CREATED_ZZ@;@/
%token<int_value>       LAST_MODIFIED_ZZ@;@/
%token<int_value>       CREATED_BY_USER_ZZ@;@/
%token<int_value>       DELETE_FROM_DATABASE_TIMESTAMP_ZZ@;@/


%token<int_value>       DELETED_ZZ@;@/
%token<int_value>       MARKED_FOR_DELETION_ZZ@;@/

%token<int_value>       PID_ZZ@;@/
%token<int_value>       PIDS_ZZ@;@/

%token<int_value>       RECEIVE_ZZ@;@/

%token<int_value>       FAILED_ZZ@;@/
%token<int_value>       SUCCEEDED_ZZ@;@/

%token<int_value>       ATTRIBUTE_ZZ@;@/
%token<int_value>       VALUE_ZZ@;@/
%token<int_value>       UNITS_ZZ@;@/ 
%token<int_value>       TIME_SET_ZZ@;@/ 

%token<int_value>       PRIVILEGES_ZZ@;@/
%token<int_value>       IRODS_HOMEDIR_ZZ@;@/
%token<int_value>       IRODS_CURRENT_DIR_ZZ@;@/
%token<int_value>       IRODS_ZONE_ZZ@;@/ 
%token<int_value>       IRODS_DEFAULT_RESOURCE_ZZ@;@/ 

%token<int_value>       IRODS_OBJECT_ZZ@;@/ 

%token<int_value>       DEFAULT_HANDLE_PREFIX_ID_ZZ@;@/
%token<int_value>       DEFAULT_HANDLE_PREFIX_ZZ@;@/ 
%token<int_value>       DEFAULT_INSTITUTE_ID_ZZ@;@/ 
%token<int_value>       DEFAULT_INSTITUTE_NAME_ZZ@;@/

%token<int_value>       AUTHENTICATION_ZZ@;@/
%token<int_value>       ERROR_ZZ@;@/

%token<int_value>       GROUP_ZZ@;@/
%token<int_value>       GROUPS_ZZ@;@/

%token<int_value>       GROUP_ID_ZZ@;@/
%token<int_value>       GROUP_NAME_ZZ@;@/
%token<int_value>       CREATOR_ID_ZZ@;@/
%token<int_value>       CREATOR_USERNAME_ZZ@;@/

%token<int_value>       DATABASE_ZZ@;@/
%token<int_value>       DELAY_ZZ@;@/
%token<int_value>       OPTION_ZZ@;@/

%token<int_value>       SERVER_ZZ@;@/
%token<int_value>       FINISHED_ZZ@;@/

%token<int_value> CHECKSUM_ZZ;@/
%token<int_value> VERIFY_ZZ;@/
%token<int_value> MD5_ZZ;@/
%token<int_value> SHA1_ZZ;@/
%token<int_value> SHA224_ZZ;@/
%token<int_value> SHA256_ZZ;@/
%token<int_value> SHA384_ZZ;@/
%token<int_value> SHA512_ZZ;@/

%token<int_value> ENCRYPT_ZZ;@/
%token<int_value> DECRYPT_ZZ;@/
%token<int_value> SIGN_ZZ;@/
%token<int_value> CLEARSIGN_ZZ;@/
%token<int_value> DETACHED_ZZ;@/
%token<int_value> SIGNATURE_ZZ;@/
%token<int_value> VERIFY_SIGNATURE_ZZ;@/
%token<int_value> GPG_KEY_FINGERPRINT_ZZ;@/
%token<int_value> PUBLIC_KEY_ZZ@;@/

%token<int_value> PULL_ZZ@;@/
%token<int_value> REGISTER_ZZ@;@/

@q ** (2) Rules.  @>
@ Rules.

@<Rules@>=

@q *** (3) Program.  @>
@ Program.
\initials{LDF 2012.07.30.}

@<Rules@>=

@=program: statement_list END_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] program: statement_list END_ZZ" 
             << endl
             << "Exiting `zzparse' with return value 0."
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 
  
    return 0;

};

@q *** (3) statement_list.  @>
@ \<statement list>.
\initials{LDF 2012.07.30.}

@q **** (4) statement_list --> EMPTY.  @>

@ \<statement list> $\longrightarrow$ \.{EMPTY}.  
This rule ensures that an empty file won't cause an error.
\initials{LDF 2012.07.30.}

@<Rules@>=

@=statement_list: /* Empty  */  @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] statement_list: /* Empty */" << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

};

@q **** (4) statement_list --> statement_list statement.  @>

@ \<statement list> $\longrightarrow$ \<statement>.
\initials{LDF 2012.07.30.}

@<Rules@>=

@=statement_list: statement_list statement @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] statement_list: statement_list statement" 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


};




@q **** (4) statement --> PWD_ZZ RESPONSE_ZZ STRING_ZZ  @>

@ \<statement> $\longrightarrow$ \.{PWD\_ZZ} \.{RESPONSE\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.09.06.}

\LOG
\initials{LDF 2012.09.06.}
Added \.{RESPONSE\_ZZ}.
\ENDLOG 

@<Rules@>=

@=statement: PWD_ZZ RESPONSE_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] `statement: PWD_ZZ RESPONSE_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$3@> 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    string temp_str = @=$3@>;

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "pwd -->" 
         << endl 
         << @=$3@> 
         << endl << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex();


};


@q **** (4) statement --> PWD_ZZ FAILED_ZZ INTEGER_ZZ  @>

@ \<statement> $\longrightarrow$ \.{PWD\_ZZ} \.{FAILED\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.09.10.}

\LOG
\initials{LDF 2012.09.10.}
Added this rule.
\ENDLOG 

@<Rules@>=

@=statement: PWD_ZZ FAILED_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] `statement: PWD_ZZ FAILED_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER_ZZ' == " << @=$3@> 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "ERROR!  In `zzparse', rule `statement: PWD_ZZ FAILED_ZZ INTEGER_ZZ':"
         << endl 
         << "Server-side error:  `pwd' failed."
         << endl
         << "Exiting function unsuccessfully with return value 1."
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex();

    return 1;

};


@q **** (4) statement --> LS_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ  @>

@ \<statement> $\longrightarrow$ \.{LS\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ}
\.{STRING\_ZZ}.
\initials{LDF 2012.09.06.}

\LOG
\initials{LDF 2012.09.06.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: LS_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));


    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule"
             << endl 
             << "`statement: LS_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ'." 
             << endl
             << "`INTEGER_ZZ' == " << @=$3@> 
             << endl 
             << "`STRING_ZZ'  == " << @=$4@> 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    /* !! TODO:  LDF 2012.11.28.  Add code for evaluating result code.  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule"
             << endl 
             << "`statement: LS_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ':" 
             << endl
             << "`STRING_ZZ' == " << @=$4@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "ls -->" 
         << endl 
         << @=$4@> 
         << endl;
    unlock_cerr_mutex();
    unlock_cout_mutex();

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> MV_ZZ RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ @>
@q **** (4)               STRING_ZZ STRING_ZZ STRING_ZZ STRING_ZZ          @>

@ \<statement> $\longrightarrow$ \.{MV\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ}
\.{UNSIGNED\_INTEGER\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.12.19.}

\LOG
\initials{LDF 2013.12.19.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: MV_ZZ RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ STRING_ZZ @>
@=STRING_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule"
             << endl 
             << "`statement: MV_ZZ RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ "
             << "STRING_ZZ STRING_ZZ STRING_ZZ STRING_ZZ':" 
             << endl
             << "`INTEGER_ZZ'          (3) (Response code) == " << @=$3@> 
             << endl 
             << "`UNSIGNED_INTEGER_ZZ' (4) (Options)       == " << @=$4@> 
             << endl 
             << "`STRING_ZZ'           (5) (Old filename)  == " << @=$5@> 
             << endl 
             << "`STRING_ZZ'           (6) (New filename)  == " << @=$6@> 
             << endl 
             << "`STRING_ZZ'           (7) (Flags)         == " << @=$7@> 
             << endl 
             << "`STRING_ZZ'           (8) (Message)       == " << @=$8@> 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "mv -->" 
         << endl 
         << "Response code:  " << @=$3@> << " (" << gwstrerror(@=$3@>) << ")"
         << endl 
         << "Options:        " << @=$4@> 
         << endl 
         << "Old filename:   " << @=$5@> 
         << endl 
         << "New filename:   " << @=$6@> 
         << endl 
         << "Flags:          " << @=$7@> 
         << endl 
         << "Message:        " << @=$8@> 
         << endl
         << endl;
    unlock_cerr_mutex();
    unlock_cout_mutex();

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> PUT_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ STRING_ZZ @>

@ \<statement> $\longrightarrow$ \.{PUT\_ZZ} \.{RESPONSE\_ZZ} 
\.{STRING\_ZZ} \.{INTEGER\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.09.27.}

\LOG
\initials{LDF 2012.09.27.}
Added this rule.
\ENDLOG

@:TODO@> !! TODO:  Change the code in the server that sends this command to the 
client so that it uses response and error codes from \filename{rspercds.web}.
\initials{LDF 2014.01.14.}

@<Rules@>=

@=statement: PUT_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: PUT_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ'  (3) (Filename)      == " << @=$3@> 
             << endl 
             << "`INTEGER_ZZ' (4) (Response code) == " << @=$4@> << " "
             << "(" << gwstrerror(@=$4@>) << ")"
             << endl 
             << "`STRING_ZZ'  (5) (Message)       == " << @=$5@> 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "put -->" 
         << endl 
         << "Filename:       " << @=$3@> 
         << endl 
         << "Response code:  " << @=$4@> << " (" << gwstrerror(@=$4@>) << ")"
         << endl 
         << "Message:        " << @=$5@>
         << endl;
  
    if (@=$4@> == 2)
       cout << "Prefix not found." << endl;

    else if (@=$4@> == 3)
       cout << "Prefix disabled." << endl;

    cout << endl;
    unlock_cerr_mutex();
    unlock_cout_mutex();

    if (@=$4@> == 4)
       ++param->warnings_occurred;

};

@q **** (4) statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ STRING_ZZ @>
@q **** (4)            get_file_response_options                                 @>

@ \<statement> $\longrightarrow$ \.{GET\_ZZ} \.{FILE\_ZZ} \.{RESPONSE\_ZZ} 
\.{STRING\_ZZ} \.{INTEGER\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ} \.{STRING\_ZZ} 
\<client-side filename optional>.
\initials{LDF 2012.10.02.}

The response code \.{INTEGER\_ZZ} will be 0 in the case that the ``get'' operation
succeeded and the server is sending the file, an odd number $> 0$ in error cases, and 
an even number $> 0$ if just a message is being sent.
\initials{LDF 2013.04.05.}

@:TODO@> !! TODO:  The number of cases that need to be accounted for is 
quite large.  Only the ones expected to be most common have been tested yet.
See ``!! TODO'' note below.
\initials{LDF 2014.01.24.}

\LOG
\initials{LDF 2012.10.02.}
Added this rule.

\initials{LDF 2012.10.12.}
Added |FILE_ZZ|.  Without it, this rule was confusing, because I've added more
``\.{GET}'' rules.

\initials{LDF 2014.01.16.}
Added \.{UNSIGNED\_INTEGER\_ZZ} and \<get file response options>.  
Removed \< overwrite optional> and \<client-side filename optional>.
\ENDLOG

@<Rules@>=

@=statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ @>
@=get_file_response_options@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

    string irods_object_filename;

    string output_filename;

    string thread_str;
    stringstream temp_strm;

    temp_strm << "[Thread " << param->thread_ctr << "] ";
    thread_str = temp_strm.str();
    temp_strm.str("");

    GPG_Key_Pair_Type gpg_key_pair;


    string client_side_filename;
    bool detached_signature = false;
    string detached_signature_str;

    bool decrypt_file        = false;
    bool overwrite           = false;
    bool store_signature     = false;
    bool expand              = false;

    bool compressed_tar_file = (@=$6@> &  32U) ? true : false;
    bool compressed_gzip     = (@=$6@> &  64U) ? true : false;
    bool compressed_bzip2    = (@=$6@> & 128U) ? true : false;
  
    string store_signature_filename;

    size_t pos = 0;

    bool decrypt_create_file = false;

    bool created_temp_files = false;

    char temp_expand_filename[32];
    memset(temp_expand_filename, 0, 32);


@q ***** (5) @>

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_str
             << "`statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ STRING_ZZ "
             << "get_file_response_options'."
             << endl
             << "`STRING_ZZ'                     (4) (Server-side filename) == " << @=$4@>
             << endl 
             << "`INTEGER_ZZ'                    (5) (Response code)        == " << @=$5@> 
             << " (" << gwstrerror(@=$5@>) << ")"
             << endl 
             << "`UNSIGNED_INTEGER_ZZ'           (6) (Options)              == " << @=$6@>
             << " == " << oct << @=$6@> << " (octal)" << dec
             << endl 
             << "`STRING_ZZ'                     (7) (Message)              == " << @=$7@> 
             << endl
             << "`get_file_response_options'     (8)                        == " << @=$8@>
             << endl
             << "`compressed_tar_file'                                      == " 
             << compressed_tar_file  
             << endl
             << "`compressed_gzip'                                          == " 
             << compressed_gzip          
             << endl
             << "`compressed_bzip2'                                         == " 
             << compressed_bzip2        
             << endl
             << "($6 &  32U)                                                == " << (@=$6@> &  32U)
             << endl
             << "($6 &  64U)                                                == " << (@=$6@> &  64U)
             << endl
             << "($6 & 128U)                                                == " << (@=$6@> & 128U)
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<Rules@>= 

    overwrite       = (@=$6@> &  1U) ? true : false;

    decrypt_file    = (@=$6@> &  4U) ? true : false;

    store_signature = (@=$6@> &  8U) ? true : false;

    expand          = (@=$6@> & 16U) ? true : false;

@q ***** (5) @>
@
@<Rules@>= 

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_str
             << "In `zzparse', `statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ"
             << endl 
             << "INTEGER_ZZ STRING_ZZ "
             << "get_file_response_options':"
             << endl
             << "overwrite       == " << overwrite       
             << endl
             << "decrypt_file    == " << decrypt_file    
             << endl
             << "store_signature == " << store_signature 
             << endl
             << "expand          == " << expand          
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>
@
@<Rules@>= 

    if (@=$8@> & 1U && param->string_vector.size() > 0)
       client_side_filename = param->string_vector.front();

    if (@=$8@> & 4U && param->string_vector.size() > 1)
    {
       detached_signature = true;
       detached_signature_str = param->string_vector.back();

    }  /* |if|  */

    else if (store_signature)
    {
        lock_cerr_mutex(); 
        cerr << "WARNING!  `store_signature' == `true', "
             << "but either `detached_signature' == `false'"
             << endl
             << "or `detached_signature_str' is empty:"
             << endl
             << "`detached_signature'     == " << detached_signature
             << endl
             << "`detached_signature_str' == " << detached_signature_str
             << endl
             << "Can't store signature.  Setting `store_signature' to `false'."
             << endl;
        unlock_cerr_mutex(); 

        ++param->warnings_occurred; 

        store_signature = false;

    }

    lock_cout_mutex();
    lock_cerr_mutex(); 

    cout << "get response -->" 
         << endl
         << "Remote filename:  " << @=$4@> 
         << endl 
         << "Response code:    " << @=$5@> << " (" << gwstrerror(@=$5@>) << ")"
         << endl
         << "Message:          " << @=$7@>
         << endl 
         << "Overwrite:        ";

    if (overwrite)
        cout << "True" << endl;
    else
        cout << "False" << endl;
        
    cout << "Decrypt file:     ";

    if (decrypt_file)
        cout << "True" << endl;
    else
        cout << "False" << endl;

    cout << "Store signature:  ";

    if (store_signature)
        cout << "True" << endl;
    else
        cout << "False" << endl;

    cout << "Expand:           ";

    if (expand)
        cout << "True" << endl;
    else
        cout << "False" << endl;

    cout << endl;

    unlock_cerr_mutex(); 
    unlock_cout_mutex();

@q ***** (5) @>
@
@<Rules@>=

    if (@=$5@> == 0)  /* Exit status of server-side ``\.{get}'' command was zero (success)  */
    {
@q ****** (6) @>


        string local_filename;
        string temp_filename;

        status = param->receive_file(@=$4@>, 
                                     client_side_filename, 
                                     overwrite, 
                                     &local_filename, 
                                     &temp_filename);

        if (status != 0)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "ERROR!  In `zzparse', rule"
                 << endl 
                 << "`statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ STRING_ZZ':"
                 << endl         
                 << "`Scan_Parse_Parameter_Type::receive_file' failed, returning "
                 << status << "." 
                 << endl
                 << "Failed to receive file `" << @=$4@> << "'";

             if (client_side_filename.length() > 0)
                 cerr << " or store it in `" << client_side_filename << "'";

             cerr << "." << endl;

             if (status == 1)
                cerr << "`access' error for local filename" << endl;
             else if (status == 2)
                cerr << "Local file already exists "
                     << "and `overwrite' == false'" << endl;
             else if (status == 3)
                cerr << "`mkdir' error." << endl;
             else if (status == 4)
                cerr << "`access' error for local path." << endl;
             else if (status == 5)
                cerr << "`ofstream::open' error for local file." << endl;
             else 
                cerr << "Unknown error." << endl;

             if (temp_filename.empty())
                 cerr << "Failed to store file contents in file."
                      << endl;
             else 
             {
                 cerr << "Stored file contents in file:  " << temp_filename << "" 
                      << endl;

                 created_temp_files = true; 

             }

             cerr << "Will try to continue."
                  << endl;
            unlock_cerr_mutex(); 

            irods_object_filename = temp_filename;

            ++param->warnings_occurred;

        }  /* |if (status != 0)|  */

        else  /* |status == 0|  */
        {
            lock_cout_mutex();
            lock_cerr_mutex(); 
            cout << "Received remote file `" << @=$4@> << "'."
                 << endl 
                 << "Stored in local file `" << local_filename << "'." 
                 << endl << endl;
            unlock_cerr_mutex(); 
            unlock_cout_mutex();

            irods_object_filename = local_filename;

        }  /* |else| (|status == 0|)  */


@q ****** (6) @>
@
\LOG
\initials{LDF 2014.01.21.}
Added this section.
\ENDLOG
@<Rules@>=

        if (decrypt_file)
        {
@q ******* (7) @>

             pos = local_filename.find_last_of(".");

             if (pos != string::npos)
                pos = local_filename.find(".gpg", pos);

@q ******* (7) @>

             if (pos != string::npos)
             {
@q ******** (8) @>

#if DEBUG_COMPILE
                 if (param->PARSER_DEBUG)    
                 {
                     lock_cerr_mutex(); 
                     cerr << "`" << local_filename << "' ends in `.gpg'."
                          << endl
                          << "Will strip extension."
                          << endl;
                     unlock_cerr_mutex(); 

                 }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

                 output_filename = local_filename.substr(0, pos);
                   
#if DEBUG_COMPILE
                 if (param->PARSER_DEBUG)    
                 {
                     lock_cerr_mutex(); 
                     cerr << "`output_filename' == " << output_filename
                          << endl;
                     unlock_cerr_mutex(); 

                 }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

@ |overwrite == false|:  Must check whether a file whose name is the 
value of  |output_filename| already exists.  If so, |pos| is set to |string::npos| 
and a file will be created using |mkstemp|.
\initials{LDF 2014.01.21.}

@<Rules@>=
                 if (overwrite == false)
                 {
@q ********* (9) @>

                      errno = 0;
                      status = access(output_filename.c_str(), F_OK);

@q ********* (9) @>

                      if (status == -1 && errno == ENOENT)
                      {
#if DEBUG_COMPILE
                          if (param->PARSER_DEBUG)    
                          {
                              lock_cerr_mutex(); 
                              cerr << "`output_filename' == " << output_filename << "' "
                                   << "doesn't exist."
                                   << endl 
                                   << "Will store decrypted text in `" << output_filename << "'."
                                   << endl;
                              unlock_cerr_mutex(); 

                          }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

                      }   /* |if (status == -1 && errno == ENOENT)|  */

@q ********* (9) @>

                      else if (status == -1)
                      {
                          lock_cerr_mutex(); 
                          cerr << "ERROR!  `access' failed, returning -1:"
                               << endl
                               << strerror(errno)
                               << endl 
                               << "Failed to check for existence of `output_filename' == "
                               << "`" << output_filename << "'."
                               << endl
                               << "Setting `pos' = `string::npos'.  Will create a file "
                               << "using `mkstemp'."
                               << endl
                               << "Continuing."
                               << endl;
                          unlock_cerr_mutex(); 

                          pos = string::npos;

                      }   /* |if (status == -1)|  */

@q ********* (9) @>

                      else if (status == 0)
                      {
                          lock_cerr_mutex(); 
                          cerr << "WARNING!  `overwrite' == `false',"
                               << "but `output_filename' =="
                               << endl 
                               << "`" << output_filename << "' already exists."
                               << endl
                               << "Can't write decrypted output to `" << output_filename << "'."
                               << endl 
                               << "Setting `pos' = `string::npos'.  Will create a file "
                               << "using `mkstemp'."
                               << endl
                               << "Continuing."
                               << endl;
                          unlock_cerr_mutex();

                          pos = string::npos; 

                      }   /* |else if (status == 0)|  */

@q ********* (9) @>

                 }  /* |if (overwrite == false)|  */

@q ******** (8) @>

#if DEBUG_COMPILE
                 else if (param->PARSER_DEBUG)
                 {
                     lock_cerr_mutex(); 
                     cerr << "`overwrite' == `true'.  Will write decrypted text to "
                          << "`" << output_filename << "' without checking for existence."
                          << endl;
                     unlock_cerr_mutex(); 

                 }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

             }  /* |if (pos != string::npos)|  */

@q ******* (7) @>

@ |pos| may be set to |string::npos| in the conditional above.  Therefore, a second 
|if| is used here instead of |else|.
\initials{LDF 2014.01.21.}

@<Rules@>=

             if (pos == string::npos)
             {
@q ******** (8) @>

#if DEBUG_COMPILE
                 if (param->PARSER_DEBUG)    
                 {
                     lock_cerr_mutex(); 
                     cerr << "Either `" << local_filename << "' =="
                          << endl
                          << "`" << local_filename << "' "
                          << "doesn't end in `.gpg',"
                          << endl 
                          << "or `overwrite' == `true'"
                          << endl 
                          << "and `output_filename' == "
                          << "`" << output_filename << "' already exists:"
                          << endl
                          << "`overwrite' == " << overwrite
                          << endl 
                          << "Setting `decrypt_create_file' to `true' and "
                          << "creating file."
                          << endl;
                     unlock_cerr_mutex(); 

                 }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

                 decrypt_create_file = true;

@q ******** (8) @>

                 char output_filename_str[output_filename.length() + 8];
                 strcpy(output_filename_str, output_filename.c_str());
                 strcat(output_filename_str, ".XXXXXX");

                 errno = 0;
                 status = mkstemp(output_filename_str);

                 if (status == -1)
                 {
                     lock_cerr_mutex(); 
                     cerr << "ERROR!  `mkstemp' failed, returning -1:"
                          << endl
                          << strerror(errno)
                          << endl
                          << "Failed to create file for decrypted output."
                          << endl
                          << "Skipping to end of parser rule.  Will try to continue."
                          << endl;
                     unlock_cerr_mutex(); 

                     goto END_GET_FILE_RULE;

                 }  /* |if (status == -1)|  */
                 
@q ******** (8) @>
 
                 close(status);

                 output_filename = output_filename_str;

                 created_temp_files = true;

@q ******** (8) @>


#if DEBUG_COMPILE 
                 if (param->PARSER_DEBUG)
                 {
                     lock_cerr_mutex(); 
                     cerr << "`mkstemp' succeeded, returning 0."
                          << endl
                          << "Created file for decrypted output successfully."
                          << endl
                          << "`output_filename' == " << output_filename
                          << endl;
                     unlock_cerr_mutex(); 
                 }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

                 lock_cout_mutex(); 
                 lock_cerr_mutex(); 
                 cout << "Will write decrypted text to file"
                      << endl 
                      << "`" << output_filename << "'."
                      << endl;
                 unlock_cerr_mutex(); 
                 unlock_cout_mutex(); 

@q ******** (8) @>

             }  /* |if (pos == string::npos)|  */

@q ******* (7) @>
@
@<Rules@>=

             char buffer[2048];
             memset(buffer, 0, 2048);

             char *buffer_ptr = buffer;

@q ******* (7) @>

             status = decrypt(irods_object_filename,
                              true, 
                              0, 
                              0, 
                              output_filename,
                              gpg_passphrase);

             if (status != 0)
             {
                 lock_cerr_mutex(); 
                 cerr << "ERROR!  `decrypt' failed, returning " << status << ":"
                      << endl
                      << "Failed to decrypt `local_filename' == " << local_filename
                      << endl
                      << "Will try to continue."
                      << endl;
                 unlock_cerr_mutex(); 

                ++param->errors_occurred;       

                 goto END_GET_FILE_RULE;

             }  /* |if (status != 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
             else if (param->PARSER_DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << "`decrypt' succeeded, returning 0:"
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

        }  /* |if (decrypt_file)|  */

@q ****** (6) @>
@
\LOG
\initials{LDF 2014.01.16.}
Added this section.
\ENDLOG

@<Rules@>=

        if (@=$6@> & 2U)  /* verify  */
        {
@q ******* (7) @>

#if DEBUG_COMPILE 
           if (param->PARSER_DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << thread_str 
                    << "`statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ STRING_ZZ "
                    << "get_file_response_options':"
                    << endl
                    << "$6 & 2U == " << (@=$6@> & 2U)
                    << endl
                    << "\"verify\" option specified."
                    << endl
                    << "`param->temp_gpg_key_fingerprint' == " << param->temp_gpg_key_fingerprint
                    << endl
                    << "`detached_signature_str'          == " << detached_signature_str
                    << endl
                    << "`decrypt_file'                    == " << decrypt_file
                    << endl;
                unlock_cerr_mutex(); 

           }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>
          
           if (@=$8@> & 4U) /* Detached signature  */
           {
@q ******** (8) @>

#if DEBUG_COMPILE 
               if (param->PARSER_DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str 
                        << "`statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ STRING_ZZ "
                        << "get_file_response_options':"
                        << endl
                        << "$8 & 4U == " << (@=$8@> & 4U)
                        << endl
                        << "Detached signature:"
                        << endl
                        << "`detached_signature_str' == " << detached_signature_str
                        << endl;
                    unlock_cerr_mutex(); 
               }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

               status = verify_gpg_signature(param->mysql_ptr,
                                             "",
                                             irods_object_filename, 
                                             detached_signature_str, 
                                             "",
                                             param->temp_gpg_key_fingerprint,
                                             &gpg_key_pair,
                                             store_signature,
                                             &store_signature_filename,
                                             overwrite,
                                             thread_str);

@q ******** (8) @>

           }  /* |if (@=$6@> & 4U)|  */

@q ******* (7) @>
@
@<Rules@>=

           else  /* Signature not detached  */
           {
@q ******** (8) @>

#if DEBUG_COMPILE 
               if (param->PARSER_DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str 
                        << "`statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ STRING_ZZ "
                        << "get_file_response_options':"
                        << endl
                        << "$8 & 4U == " << (@=$8@> & 4U)
                        << endl
                        << "Signature not detached."
                        << endl;
                    unlock_cerr_mutex(); 
               }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

               status = verify_gpg_signature(param->mysql_ptr,
                                             "",
                                             irods_object_filename, 
                                             "",
                                             "",
                                             param->temp_gpg_key_fingerprint,
                                             &gpg_key_pair,
                                             store_signature,
                                             &store_signature_filename,
                                             overwrite,
                                             thread_str);


@q ******** (8) @>

           }  /* |else| (Signature not detached)  */

@q ******* (7) @>
@
@<Rules@>=

            if (status != 0)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "ERROR!  In `zzparse', rule"
                     << endl 
                     << "`statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ "
                     << "INTEGER_ZZ STRING_ZZ':"
                     << endl         
                     << "`verify_gpg_signature' failed, returning "
                     << status << ":" 
                     << endl
                     << "Failed to verify signature.  Continuing."
                     << endl;
                unlock_cerr_mutex(); 

                ++param->errors_occurred;       

            }

@q ******* (7) @>
@
@<Rules@>=

            else
            {
@q ******** (8) @>

                lock_cout_mutex(); 
                lock_cerr_mutex(); 
                cout << thread_str << "Verified ";

                if (detached_signature == true)
                   cout << "detached ";
                else
                   cout << "(non-detached) ";

                cout << "signature successfully:"
                     << endl 
                     << "UID:              " << gpg_key_pair.uid
                     << endl
                     << "Key ID:           " << gpg_key_pair.get_key_id()
                     << endl
                     << "Key fingerprint:  " << gpg_key_pair.fingerprint
                     << endl;

                 if (decrypt)
                 {

                    temp_strm.str("");
                    pos = output_filename.find_last_of("/");

                    if (   decrypt_create_file 
                        && pos != string::npos 
                        && pos != output_filename.size() - 1)
                    {
                         temp_strm << "./";
                         temp_strm << output_filename.substr(pos + 1);
                    }
                    else
                       temp_strm << output_filename;
                       
                    cout << "Encrypted file:   " << irods_object_filename 
                         << endl
                         << "Decrypted file:   " << temp_strm.str()
                         << endl;



                    temp_strm.str("");

                 }

                 if (store_signature && !store_signature_filename.empty())
                 {
                     cout << "Signature file:   " << store_signature_filename
                          << endl;

                 }

                unlock_cerr_mutex(); 
                unlock_cout_mutex(); 

@q ******** (8) @>

#if DEBUG_COMPILE
                if (param->PARSER_DEBUG)      
                {
                    lock_cerr_mutex(); 
                    gpg_key_pair.show("gpg_key_pair:");
                    unlock_cerr_mutex(); 

                }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */        

@q ******** (8) @>

            }  /* |else|  */

@q ******* (7) @>

        }  /* |if (@=$6@> & 2U)| (verify)   */

@q ****** (6) |expand == true|.  @>

@ |expand == true|.  The number of possible cases is very large:
The file may be a compressed tar file containing a directory structure or
a compressed ordinary file.  It may have been compressed with \.{gzip} or \.{bzip2}.
It may have been encrypted and/or signed.  The signature may be detached.
If the ``force'' option (\.{-f}) was {\it not\/} used, then a temporary file may 
have created.
\par
In order to handle all of the possible cases correctly, it will be necessary to 
use conditionals.  More of these may be written than would stricty speaking be 
necessary, but it seems to me that trying to make this more efficient would result
in code that would be very difficult to understand.
\par
After it's been tested, it may be possible to make the code more compact.
\initials{LDF 2014.01.24.}

\LOG
\initials{LDF 2014.01.24.}
Added this section.
\ENDLOG

@<Rules@>=

        if (expand)
        {

            /* !! TODO:  LDF 2014.01.24.  Test other cases.  */

@q ******* (7) @>

#if DEBUG_COMPILE 
            if (param->PARSER_DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `zzparse', rule"
                     << endl 
                     << "`statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ "
                     << "INTEGER_ZZ STRING_ZZ':"
                     << endl
                     << "`expand' == `true'."
                     << endl
                     << "`output_filename' == " << output_filename
                     << endl 
                     << "`local_filename' == " << local_filename
                     << endl 
                     << "`irods_object_filename' == " << irods_object_filename
                     << endl 
                     << "`temp_filename' == " << temp_filename
                     << endl
                     << "`created_temp_files' == " << created_temp_files
                     << endl;
                unlock_cerr_mutex(); 
  
            }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

@ |overwrite && output_filename.empty() && temp_filename.empty()|.
This is the simplest case.  We can just expand the file.
\initials{LDF 2014.01.24.}

@<Rules@>=

            if (overwrite && output_filename.empty() && temp_filename.empty())
            {

                temp_strm.str("");

                if (compressed_tar_file)
                {
                    temp_strm << "tar --extract ";

                    if (compressed_gzip)
                        temp_strm << "--gunzip ";

                    else 
                       temp_strm << "--bzip2 ";

                    temp_strm << "--file=";
                }

                else if (compressed_gzip)
                   temp_strm << "gunzip --force ";
                else if (compressed_bzip2)
                   temp_strm << "bunzip2 --force ";

                temp_strm << irods_object_filename;

            }  /* |if (overwrite && output_filename.empty() && temp_filename.empty())|  */

@q ******* (7) @>
@
@<Rules@>=

            else if (created_temp_files)
            {
@q ******** (8) @>

#if DEBUG_COMPILE 
                if (param->PARSER_DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str << "In `zzparse', rule"
                         << endl 
                         << "`statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ "
                         << "INTEGER_ZZ STRING_ZZ':"
                         << endl
                         << "`created_temp_files' == `true'"
                         << endl
                         << "`output_filename' == " << output_filename
                         << endl 
                         << "`local_filename' == " << local_filename
                         << endl 
                         << "`irods_object_filename' == " << irods_object_filename
                         << endl 
                         << "`temp_filename' == " << temp_filename
                         << endl;
                    unlock_cerr_mutex(); 
  
                }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

                temp_strm.str("");

                if (compressed_tar_file)
                {
@q ********* (9) @>

                     lock_cerr_mutex(); 
                     cerr << "WARNING!  `overwrite' == `false' "
                          << "and `compressed_tar_file' == `true':"
                          << endl
                          << "Can't write expanded output to `" << output_filename << "'."
                          << endl 
                          << "Setting `pos' = `string::npos'.  Will create a file "
                          << "using `mkstemp'."
                          << endl
                          << "Skipping to end of parser rule.  Will try to continue."
                          << endl;
                     unlock_cerr_mutex();

                     ++param->warnings_occurred; 

                     goto END_GET_FILE_RULE;

@q ********* (9) @>

                }

@q ******** (8) @>
@
@<Rules@>=
                else
                {
@q ********* (9) @>

                    strcpy(temp_expand_filename, "/tmp/gwirdcli.XXXXXX");

                    errno = 0;
                    status = mkstemp(temp_expand_filename);

                    if (status == -1)
                    {
                        lock_cerr_mutex(); 
                        cerr << "ERROR!  `mkstemp' failed, returning -1:"
                             << endl
                             << strerror(errno)
                             << endl
                             << "Failed to create file for expanded output."
                             << endl
                             << "Skipping to end of parser rule.  Will try to continue."
                             << endl;
                        unlock_cerr_mutex(); 

                        goto END_GET_FILE_RULE;

                    }  /* |if (status == -1)|  */
                 
@q ********* (9) @>
 
                    close(status);

@q ********* (9) @>

#if DEBUG_COMPILE 
                    if (param->PARSER_DEBUG)
                    {
                        lock_cerr_mutex(); 
                        cerr << thread_str << "In `zzparse', rule"
                             << endl 
                             << "`statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ "
                             << "INTEGER_ZZ STRING_ZZ':"
                             << endl
                             << "`mkstemp' succeeded."
                             << endl 
                             << "`temp_expand_filename' == " << temp_expand_filename
                             << endl;
                        unlock_cerr_mutex(); 
  
                    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>
@
@<Rules@>=

                    if (compressed_gzip)
                       temp_strm << "zcat ";
                    else if (compressed_bzip2)
                       temp_strm << "bunzip2 ";

                    temp_strm << output_filename << " > " 
                              << temp_expand_filename;

                }

@q ******** (8) @>

            }  /* |else if (created_temp_files)|  */

@q ******* (7) @>
@
@<Rules@>=

#if DEBUG_COMPILE 
            if (param->PARSER_DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `zzparse', rule"
                     << endl 
                     << "`statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ "
                     << "INTEGER_ZZ STRING_ZZ':"
                     << endl
                     << "`temp_strm.str()' == " << temp_strm.str()
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>
@
@<Rules@>=

            if (temp_strm.str().length() > 0)
            {
@q ******** (8) @>

                status = system(temp_strm.str().c_str());

                if (status != 0)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str << "ERROR!  In `zzparse', rule"
                         << endl 
                         << "`statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ "
                         << "INTEGER_ZZ STRING_ZZ':"
                         << endl
                         << "`system' failed, returning "
                         << status << ":"
                         << endl;

                     if (WIFEXITED(status))
                     {
                       cerr << "WEXITSTATUS(" << status << ") == " 
                            << WEXITSTATUS(status) << endl;
                     }
                     else
                     {
                       cerr << "Process didn't exit." << endl;

                     }
                     unlock_cerr_mutex();     

                }  /* |if (status != 0)|  */
            
@q ******** (8) @>
@
@<Rules@>=

                else
                {
#if DEBUG_COMPILE 
                    if (param->PARSER_DEBUG)
                    {
                        lock_cerr_mutex(); 
                        cerr << thread_str << "In `zzparse', rule"
                             << endl 
                             << "`statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ "
                             << "INTEGER_ZZ STRING_ZZ':"
                             << endl
                             << "`system' succeeded." 
                             << endl;
                        unlock_cerr_mutex(); 

                    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

                    lock_cout_mutex();
                    lock_cerr_mutex(); 
                    cout << "Expanded file successfully."
                         << endl;

                    if (strlen(temp_expand_filename) > 0)
                        cout << "Wrote expanded output to "
                             << "`" << temp_expand_filename << "'."
                             << endl;
                 
                    unlock_cerr_mutex(); 
                    unlock_cout_mutex(); 

                    temp_strm.str("");

                }  /* |else|  */

@q ******** (8) @>

            }  /* |if (temp_strm.str().length() > 0)|  */

@q ******* (7) @>
@
@<Rules@>=
            else 
            {
                 lock_cerr_mutex(); 
                 cerr << thread_str << "WARNING!  In `zzparse', rule"
                      << endl 
                      << "`statement: GET_ZZ FILE_ZZ RESPONSE_ZZ STRING_ZZ "
                      << "INTEGER_ZZ STRING_ZZ':"
                      << endl
                      << "`temp_strm.str()' is empty:"
                      << endl 
                      << "Some case has not been accounted for.  Not calling `system'." 
                      << endl
                      << "Will try to continue."
                      << endl;
                 unlock_cerr_mutex(); 

                 ++param->warnings_occurred;

            }  /* |else|  */


@q ******* (7) @>

        }  /* |if (expand)|  */

@q ****** (6) @>


    }  /* |if (@=$5@> == 0)|  */

@q ***** (5) @>
@
@<Rules@>=

    else  /* Exit status of server-side ``\.{get}'' command was non-zero (failure)  */
    {

        lock_cout_mutex();
        lock_cerr_mutex(); 
        cout << "Response code == " << @=$5@> << " == " << oct << @=$5@> << " (octal) "
             << dec << "(!= 0) (" << gwstrerror(@=$5@>) << "):"
             << endl
             << "Not calling `receive_file'.  "
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex();
        unlock_cout_mutex();
     
        if (@=$5@> == GW_ERROR)
           ++param->errors_occurred; 
        else if (@=$5@> == GW_WARNING)
           ++param->warnings_occurred; 

    }  /* |else|  */

@q ***** (5) @>

END_GET_FILE_RULE:

    param->temp_gpg_key_fingerprint = "";
    param->string_vector.clear();

    param->PARSER_DEBUG = save_PARSER_DEBUG; 



};

@q **** (4) get_file_response_options.  @>

@ \<get file response options>.  
\initials{LDF 2012.11.19.}

\LOG
\initials{LDF 2012.11.19.}
Added type declaration for \<client-side filename optional>.

\initials{LDF 2014.01.16.}
Removed type declaration for \<client-side filename optional>.
Replaced it with one for \<get file response options>.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> get_file_response_options@>

@q ***** (5) get_file_response_options:  /* Empty  */@>
@ \<get file response options> $\longrightarrow$ \.{Empty}.

\LOG
\initials{LDF 2012.11.19.}
Added this rule.

\initials{LDF 2013.04.04.}
@:BUG FIX@> BUG FIX:  Now setting the value of this rule, i.e., |@=$$$@>|, to the
empty string.

\initials{LDF 2014.01.16.}
Changed \<client-side filename optional> to \<get file response options>.
\ENDLOG

@<Rules@>=
@=get_file_response_options: /* Empty  */@>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `get_file_response_options: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 0U;

    param->temp_gpg_key_fingerprint = "";
    param->string_vector.clear();

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) get_file_response_options: get_file_response_options @>
@q ***** (5) CLIENT_SIDE_FILENAME_ZZ STRING_ZZ                    @>

@ \<get file response options> $\longrightarrow$ \<get file response options> 
\.{CLIENT\_SIDE\_FILENAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.11.19.}

\LOG
\initials{LDF 2012.11.19.}
Added this rule.

\initials{LDF 2014.01.16.}
Changed \<client-side filename optional> to \<get file response options>.
\ENDLOG

@<Rules@>=
@=get_file_response_options: get_file_response_options CLIENT_SIDE_FILENAME_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `get_file_response_options: "
             << "CLIENT_SIDE_FILENAME_ZZ STRING_ZZ'." 
             << endl
             << "`STRING_ZZ' == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> |= 1U;

    param->string_vector.push_back(@=$3@>);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) get_file_response_options: get_file_response_options @>
@q ***** (5) GPG_KEY_FINGERPRINT_ZZ STRING_ZZ                     @>

@ \<get file response options> $\longrightarrow$ \<get file response options> 
\.{GPG\_KEY\_FINGERPRINT\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2014.01.16.}

\LOG
\initials{LDF 2014.01.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=get_file_response_options: get_file_response_options GPG_KEY_FINGERPRINT_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `get_file_response_options: "
             << "GPG_KEY_FINGERPRINT_ZZ STRING_ZZ'." 
             << endl
             << "`STRING_ZZ' == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> |= 2U;

    param->temp_gpg_key_fingerprint = @=$3@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) get_file_response_options: get_file_response_options @>
@q ***** (5) DETACHED_ZZ SIGNATURE_ZZ STRING_ZZ                     @>

@ \<get file response options> $\longrightarrow$ \<get file response options> 
\.{DETACHED\_ZZ SIGNATURE\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2014.01.16.}

\LOG
\initials{LDF 2014.01.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=get_file_response_options: get_file_response_options DETACHED_ZZ SIGNATURE_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `get_file_response_options: "
             << "DETACHED_ZZ SIGNATURE_ZZ STRING_ZZ'." 
             << endl
             << "`STRING_ZZ' == " << @=$4@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> |= 4U;

    param->string_vector.push_back(@=$4@>);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> GET_ZZ PIDS_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ  @>
@q **** (4) INTEGER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ                       @>

@ \<statement> $\longrightarrow$ \.{GET\_ZZ} \.{PIDS\_ZZ} \.{RESPONSE\_ZZ} 
\.{STRING\_ZZ} \.{INTEGER\_ZZ} \.{INTEGER\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.10.10.}

\LOG
\initials{LDF 2012.10.10.}
Added this rule.

\initials{LDF 2012.12.31.}
Added \.{UNSIGNED\_INTEGER\_ZZ}.
\ENDLOG

@<Rules@>=

@=statement: GET_ZZ PIDS_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ @>
@=STRING_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule"
             << endl 
             << "`statement: GET_ZZ PIDS_ZZ RESPONSE_ZZ STRING_ZZ "
             << "INTEGER_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ':"
             << endl 
             << "`STRING_ZZ' (4) ==           " << @=$4@> 
             << endl
             << "`INTEGER_ZZ' (5) ==          " << @=$5@> 
             << endl 
             << "`INTEGER_ZZ' (6) ==          " << @=$6@> 
             << endl 
             << "`UNSIGNED_INTEGER_ZZ' (7) == " << @=$7@> 
             << endl 
             << "`STRING_ZZ' (8) ==           " << @=$8@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "get pids -->" 
         << endl 
         << "Filename:        " << @=$4@> 
         << endl 
         << "Exit status:     " << @=$5@> 
         << endl 
         << "Number of PIDS:  " << @=$6@> 
         << endl 
         << "Response:        " << @=$7@>
         << endl;


    if (@=$6@> > 0)
       cout << "PIDs:            " << @=$8@>
            << endl;

    cout << endl;


    unlock_cerr_mutex(); 
    unlock_cout_mutex();

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) statement --> GET_ZZ METADATA_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ  @>
@q **** (4) INTEGER_ZZ UNSIGNED_INTEGER_ZZ avu_list                            @>

@ \<statement> $\longrightarrow$ \.{GET\_ZZ} \.{METADATA\_ZZ} \.{RESPONSE\_ZZ} 
\.{STRING\_ZZ} \.{INTEGER\_ZZ} \.{INTEGER\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ}
\<avu list>.
\initials{LDF 2012.10.12.}

\LOG
\initials{LDF 2012.10.12.}
Added this rule.

\initials{LDF 2012.12.31.}
Added \.{UNSIGNED\_INTEGER\_ZZ}.
\ENDLOG

@<Rules@>=

@=statement: GET_ZZ METADATA_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ INTEGER_ZZ @>
@=UNSIGNED_INTEGER_ZZ avu_list@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));


    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: GET_ZZ METADATA_ZZ RESPONSE_ZZ STRING_ZZ "
             << "INTEGER_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ avu_list'."
             << endl  
             << "`STRING_ZZ' == " << @=$4@> 
             << endl
             << "`INTEGER_ZZ' == " << @=$5@> 
             << endl 
             << "`INTEGER_ZZ' == " << @=$6@> 
             << endl 
             << "`UNSIGNED_INTEGER_ZZ' == " << @=$7@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "get metadata -->" 
         << endl 
         << "Filename:        " << @=$4@> 
         << endl 
         << "Exit status:     " << @=$5@> 
         << endl 
         << "Number of AVUs:  " << @=$6@> 
         << endl
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex();

    stringstream temp_strm;

    if (param && param->irods_object)
    {
        lock_cout_mutex();
        lock_cerr_mutex(); 
        if (param->irods_object->avu_vector.size() == 0)
           cout << "No user-defined metadata (AVUs) to display"
                << endl << endl;
         else
         {
            param->irods_object->path = @=$4@>;

            param->irods_object_vector.push_back(*param->irods_object);
            delete param->irods_object;
            param->irods_object = 0;

            param->irods_object_vector.back().show("", &temp_strm);
            cout << temp_strm.str();

         }
         unlock_cerr_mutex();
         unlock_cout_mutex();
    }
    else
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `statement: GET_ZZ METADATA_ZZ RESPONSE_ZZ STRING_ZZ "
             << "INTEGER_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ avu_list':"
             << endl 
             << "`param' is NULL or `param->irods_object' is NULL."
             << endl
             << "Can't display user-defined metadata (AVUs) for iRODS object "
             << "`" << @=$4@> << "'."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> GET_ZZ METADATA_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ  @>
@q **** (4) INTEGER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ                           @>

@ \<statement> $\longrightarrow$ \.{GET\_ZZ} \.{METADATA\_ZZ} \.{RESPONSE\_ZZ} 
\.{STRING\_ZZ} \.{INTEGER\_ZZ} \.{INTEGER\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.10.12.}

\LOG
\initials{LDF 2012.10.12.}
Added this rule.  Currently, it is only matched if there was a server-side error,
but this may change in the future.

\initials{LDF 2012.12.31.}
Added \.{UNSIGNED\_INTEGER\_ZZ}.
\ENDLOG

@<Rules@>=

@=statement: GET_ZZ METADATA_ZZ RESPONSE_ZZ STRING_ZZ INTEGER_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ @>
@=STRING_ZZ@>
{

    /* !! PLEASE NOTE: This rule is only matched if there was a server-side
       error.  The rule above is the one that's normally matched.
       \initials{LDF 2013.12.06.}  */

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

    
#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: GET_ZZ METADATA_ZZ RESPONSE_ZZ STRING_ZZ "
             << "INTEGER_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ'."
             << endl 
             << "`STRING_ZZ' (4) (filename or PID) ==   " << @=$4@> 
             << endl
             << "`INTEGER_ZZ' (5) (error code) ==       " << @=$5@> 
             << endl 
             << "`INTEGER_ZZ' (6) (number of AVUS) ==   " << @=$6@> 
             << endl
             << "`UNSIGNED_INTEGER_ZZ' (7) (options) == " << @=$7@> 
             << endl
             << "`STRING_ZZ' (8) (response) ==          " << @=$8@> 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "get metadata -->" 
         << endl 
         << "Filename or PID:  " << @=$4@> 
         << endl 
         << "Exit status:      " << @=$5@> 
         << endl 
         << "Number of AVUs:   " << @=$6@> 
         << endl 
         << "Options:          " << hex << @=$7@> << " (hexadecimal)" << dec
         << endl 
         << "Response:         " << @=$8@> 
         << endl << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex();

param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) avu_list and avu.  @>

@ \<avu list> and \<avu>.
\initials{LDF 2012.10.12.}

\LOG
\initials{LDF 2012.10.12.}
Added these type declarations.
\ENDLOG

@<Token and type declarations@>=

%type<int_value> avu_list
%type<int_value> avu

@q ***** (5) avu_list:  /* Empty  */ @>

@ \<avu list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2012.10.12.}

\LOG
\initials{LDF 2012.10.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=avu_list: /* Empty  */@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `avu_list: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 
   
    if (param->irods_object)
    {
         param->irods_object->clear();
    }
    else
        param->irods_object = new Irods_Object_Type;

    @=$$@> = 0;

};

@q ***** (5) avu_list: avu_list avu @>

@ \<avu list> $\longrightarrow$ \<avu list> \<avu>.
\initials{LDF 2012.10.12.}

\LOG
\initials{LDF 2012.10.12.}
Added this rule.
\ENDLOG


@<Rules@>=

@=avu_list: avu_list avu@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `avu_list: avu_list avu." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


};

@q ***** (5) avu: ATTRIBUTE_ZZ STRING_ZZ VALUE_ZZ STRING_ZZ UNITS_ZZ STRING_ZZ  @>
@q ***** (5)      TIME_SET_ZZ UNSIGNED_INTEGER_ZZ                               @>

@ \<avu> $\longrightarrow$ \.{ATTRIBUTE\_ZZ} \.{STRING\_ZZ} \.{VALUE\_ZZ} 
\.{STRING\_ZZ} \.{UNITS\_ZZ} \.{STRING\_ZZ} \.{TIME\_SET\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2012.10.12.}

\LOG
\initials{LDF 2012.10.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=avu: ATTRIBUTE_ZZ STRING_ZZ VALUE_ZZ STRING_ZZ UNITS_ZZ STRING_ZZ @>
@=TIME_SET_ZZ UNSIGNED_INTEGER_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `avu: ATTRIBUTE_ZZ STRING_ZZ VALUE_ZZ"
             << endl 
             << "STRING_ZZ UNITS_ZZ STRING_ZZ TIME_SET_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   Irods_AVU_Type irods_avu(@=$2@>, @=$4@>, @=$6@>, @=$8@>);

   if (param && param->irods_object)
   {
        param->irods_object->avu_vector.push_back(irods_avu);
   }

   else
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << param->thread_ctr << "] "
            << "ERROR!  In `zzparse', rule `avu: ATTRIBUTE_ZZ STRING_ZZ VALUE_ZZ"
            << endl 
            << "STRING_ZZ UNITS_ZZ STRING_ZZ TIME_SET_ZZ UNSIGNED_INTEGER_ZZ':"
            << endl 
            << "`param' == 0 or `param->irods_object' == 0."
            << endl
            << "Can't push `Irods_AVU_Type irods_avu' onto "
            << "`param->irods_object.avu_vector'."
            << endl
            << "Will try to continue."
            << endl;
       unlock_cerr_mutex(); 
   }

};


@q **** (4) statement --> SERVER_ZZ FINISHED_ZZ@>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{FINISHED\_ZZ}.
\initials{LDF 2012.07.30.}

\LOG
\initials{LDF 2012.07.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ FINISHED_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
       lock_cerr_mutex(); 
       cerr << "[Thread " << param->thread_ctr << "] "
            << "In `zzparse', rule `statement: SERVER_ZZ FINISHED_ZZ'." 
            << endl;
       unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->server_finished = true;

};

@q **** (4) statement --> GET_ZZ HANDLE_ZZ RESPONSE_ZZ INTEGER_ZZ  @>
@q **** (4) UNSIGNED_INTEGER_ZZ handle_item_list                   @>

@ \<statement> $\longrightarrow$ \.{GET\_ZZ} \.{HANDLE\_ZZ} \.{RESPONSE\_ZZ} 
\.{INTEGER\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ} \<handle item list>.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.

\initials{LDF 2013.04.26.}
Now calling |Handle_Value_Type::write_to_database|.  This writes |param->handle_value| to 
the client-side \.{gwirdcli.handles} database table.

\initials{LDF 2013.12.19.}
Added \.{UNSIGNED\_INTEGER\_ZZ}.  It's used for options.
\ENDLOG

@<Rules@>=

@=statement: GET_ZZ HANDLE_ZZ RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ handle_item_list @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', Rule"
             << endl 
             << "`statement: GET_ZZ HANDLE_ZZ RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ "
             << "handle_item_list'."
             << endl
             << "`INTEGER_ZZ'          (4) (Response code) == " << @=$4@> 
             << endl 
             << "`UNSIGNED_INTEGER_ZZ' (5) (Options)       == " << @=$5@> 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>

@ See |Scan_Parse_Parameter_Type::get_handle| in \filename{scprpmtp.web} 
for error codes.
\initials{LDF 2012.11.14.}

@<Rules@>=

    if (@=$4@> != 0)
    {
        lock_cout_mutex();
        lock_cerr_mutex(); 
        cout << "get handle -->"
             << endl
             << "Server-side error:"
             << endl 
             << "Response code:   " << @=$4@>
             << endl
             << "Options:         " << @=$5@>
             << endl
             << "handle:          " << param->handle_value.handle
             << endl;

         if (@=$4@> == 1 || @=$4@> == 2 || @=$4@> == 4)
         {
            cout << "Database error";
            ++param->errors_occurred;
         }
         else if (@=$4@> == 3)
         {
            cout << "Database query returned 0 rows";
            ++param->warnings_occurred;
         }
         else if (@=$4@> == 5)
         {
            cout << "`Handle_Type::set' failed";
            ++param->errors_occurred;
         }
         else if (@=$4@> > 5)
         {
            cout << "Other error.";
            ++param->errors_occurred;
         }

         cout << endl;
         unlock_cerr_mutex();
         unlock_cout_mutex();

    }  /* |if|  */

@q ***** (5) @>
@
\LOG
\initials{LDF 2013.02.08.}
Added code for converting |param->handle_value.timestamp|, |param->handle_value.created|
and |param->handle_value.last_modified| to timestamps.

\initials{LDF 2013.02.28.}
Added code to account for |param->handle_value.created_by_user_id| and 
|param->handle_value.created_by_user_name|.
\ENDLOG

@<Rules@>=

    else  /* Success  */
    {
@q ****** (6) @>

        int field_width = strlen("delete_from_database_timestamp:  ");


        lock_cerr_mutex(); 
        lock_cout_mutex();
        cout << "get handle -->" 
             << endl 
             << setw(field_width) << left 
             << "Response code:  " << @=$4@>
             << endl
             << "Options:        " << @=$5@>
             << endl
             << setw(field_width) << left
             << "filename:" << param->handle_value.filename
             << endl 
             << setw(field_width) << left
             << "handle:" << param->handle_value.handle
             << endl 
             << setw(field_width) << left
             << "idx:" << param->handle_value.idx
             << endl 
             << setw(field_width) << left
             << "type:" << param->handle_value.type
             << endl
             << setw(field_width) << left
             << "data_length:" << param->handle_value.data_length
             << endl;

        if (param->handle_value.data && param->handle_value.data_length > 0)
        {
             cout << setw(field_width) << left << "data:";

             fwrite(param->handle_value.data, 1, param->handle_value.data_length, stdout);
        }

        else if (param->handle_value.data == 0 && param->handle_value.data_length > 0)
             cout << setw(field_width) << left << "data:" << "(binary)";
        else
             cout << setw(field_width) << left << "data:" << "NULL";
    
        cout << endl 
             << setw(field_width) << left 
             << "ttl_type:" << param->handle_value.ttl_type
             << endl
             << setw(field_width) << left 
             << "ttl:" << param->handle_value.ttl
             << endl
             << setw(field_width) << left 
             << "timestamp:" << param->handle_value.timestamp;

        if (param->handle_value.timestamp != 0)
           cout  << " " << "(" << convert_seconds(param->handle_value.timestamp, true) << ")";

        cout << endl
             << setw(field_width) << left 
             << "refs_length:" << param->handle_value.refs_length
             << endl;


        if (param->handle_value.refs && param->handle_value.refs_length > 0)
        {
             cout << "refs:";

             fwrite(param->handle_value.refs, 1, param->handle_value.refs_length, stdout);
        }

        else if (param->handle_value.refs == 0 && param->handle_value.refs_length > 0)
             cout << setw(field_width) << left << "refs:" << "(binary)";
        else
             cout << setw(field_width) << left << "refs:" << "NULL";

    
        cout << endl
             << setw(field_width) << left << "admin_read:" 
             << param->handle_value.admin_read
             << endl
             << setw(field_width) << left << "admin_write:" 
             << param->handle_value.admin_write
             << endl
             << setw(field_width) << left << "pub_read:" << param->handle_value.pub_read
             << endl
             << setw(field_width) << left << "pub_write:" << param->handle_value.pub_write
             << endl
             << setw(field_width) << left 
             << "handle_id:" << param->handle_value.handle_id
             << endl
             << setw(field_width) << left 
             << "handle_value_id:" << param->handle_value.handle_value_id
             << endl
             << setw(field_width) << left 
             << "irods_object_id:" << param->handle_value.irods_object_id
             << endl 
             << setw(field_width) << left 
             << "created:" << param->handle_value.created;

        if (param->handle_value.created != 0)
            cout << " " << "(" 
                  << convert_seconds(param->handle_value.created, true) << ")";

        cout << endl
             << setw(field_width) << left 
             << "last_modified:" << param->handle_value.last_modified;

        if (param->handle_value.last_modified  != 0)
           cout << " " << "(" 
                << convert_seconds(param->handle_value.last_modified, true) << ")";

        cout << endl
             << setw(field_width) << left 
             << "delete_from_database_timestamp:" 
             << param->handle_value.delete_from_database_timestamp;

        if (param->handle_value.delete_from_database_timestamp  != 0)
           cout << " " << "(" 
                << convert_seconds(param->handle_value.delete_from_database_timestamp, true)
                << ")";

        cout << endl
             << setw(field_width) << left 
             << "created_by_user:" << param->handle_value.created_by_user_id << " " 
             << param->handle_value.created_by_user_name
             << endl 
             << setw(field_width) << left 
             << "marked_for_deletion:" << param->handle_value.marked_for_deletion
             << endl
             << endl;
        unlock_cout_mutex();
        unlock_cerr_mutex();


#if DEBUG_COMPILE 
        if (param->PARSER_DEBUG)
        {

           cerr << "param->handle_value.data == " << param->handle_value.data << endl
                << "param->handle_value.data_length == " 
                << param->handle_value.data_length << endl;

           cerr << "param->handle_value == " << endl;


           param->handle_value.show();


        }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
\LOG
\initials{LDF 2013.12.19.}
Added this section.
\ENDLOG

@<Rules@>=

        if (@=$5@> & 1U)  /* No store  */
        {
            lock_cout_mutex();
            lock_cerr_mutex(); 
            cout << "Not storing handle value in `gwirdcli.handles' database."
                 << endl;
            unlock_cerr_mutex(); 
            unlock_cout_mutex(); 
 
        }  /* |if|  */

@q ****** (6) @>
@
@<Rules@>=

        else  /* |options & 1U == 0|, storing  */
        {
@q ******* (7) @>

            status = param->handle_value.write_to_database(param->mysql_ptr, "gwirdcli", true);

            if (status != 0)
            {
                lock_cerr_mutex();
                cerr << "[Thread " << param->thread_ctr << "] ERROR!  In `zzparse', Rule"
                     << endl 
                     << "`statement: GET_ZZ HANDLE_ZZ RESPONSE_ZZ INTEGER_ZZ "
                     << "handle_item_list':"
                     << endl
                     << "`Handle_Value_Type::write_to_database' failed, returning "
                     << status << "."
                     << endl 
                     << "Failed to write handle value to `gwirdcli.handles' table."
                     << endl
                     << "Will try to continue."
                     << endl;
                unlock_cerr_mutex(); 

                ++param->errors_occurred;

            }  /* |if (status != 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE 
            else if (param->PARSER_DEBUG)
            {
                lock_cerr_mutex();
                cerr << "[Thread " << param->thread_ctr << "] In `zzparse', Rule"
                     << endl 
                     << "`statement: GET_ZZ HANDLE_ZZ RESPONSE_ZZ INTEGER_ZZ "
                     << "handle_item_list':"
                     << endl
                     << "`Handle_Value_Type::write_to_database' succeeded, returning 0."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        }  /* |else| (|options & 1U == 0|, storing)  */

@q ****** (6) @>

    }  /* |else|  Success  */

@q ***** (5) @>
@
@<Rules@>=

    param->handle_value.clear();   /* !! TODO:  LDF 2013.04.26.
                                      I may want to copy the value
                                      of |param->handle_value| to
                                      somewhere before clearing it.  */

@q ***** (5) @>

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) handle_item_list and handle_item.  @>

@ \<handle item list> and \<handle item>.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added these type declarations.
\ENDLOG

@<Token and type declarations@>=

%type<int_value> handle_item_list
%type<int_value> handle_item

@q ***** (5) handle_item_list:  /* Empty  */ @>

@ \<handle item list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item_list: /* Empty  */@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item_list: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->handle_value.clear();   

    @=$$@> = 0;

};

@q ***** (5) handle_item_list: handle_item_list handle_item @>

@ \<handle item list> $\longrightarrow$ \<handle item list> \<handle item>.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG


@<Rules@>=

@=handle_item_list: handle_item_list handle_item@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
       lock_cerr_mutex(); 
       cerr << "[Thread " << param->thread_ctr << "] "
            << "In `zzparse', rule `handle_item_list: handle_item_list handle_item." 
            << endl;
       unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

};

@q ***** (5) handle_item: FILE_ZZ STRING_ZZ @>

@ \<handle item> $\longrightarrow$ \.{FILE\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: FILE_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: FILE_ZZ STRING_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.filename = @=$2@>;

};

@q ***** (5) handle_item: HANDLE_ZZ STRING_ZZ @>

@ \<handle item> $\longrightarrow$ \.{HANDLE\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: HANDLE_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));
#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: HANDLE_ZZ STRING_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.handle = @=$2@>;

};


@q ***** (5) handle_item: IDX_ZZ INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{IDX\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: IDX_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: IDX_ZZ INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.idx = @=$2@>;

};

@q ***** (5) handle_item: TYPE_ZZ STRING_ZZ @>

@ \<handle item> $\longrightarrow$ \.{TYPE\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: TYPE_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

 #if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: TYPE_ZZ STRING_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.type = @=$2@>;

};

@q ***** (5) handle_item: DATA_ZZ STRING_ZZ @>

@ \<handle item> $\longrightarrow$ \.{DATA\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: DATA_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));


    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: DATA_ZZ STRING_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.data = new char[strlen(@=$2@>) + 1]; 
   memset(param->handle_value.data, 0, strlen(@=$2@>) + 1);
   memcpy(param->handle_value.data, @=$2@>, strlen(@=$2@>));

   param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) handle_item: DATA_LENGTH_ZZ INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{DATA\_LENGTH\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: DATA_LENGTH_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


 #if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: DATA_LENGTH_ZZ INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->handle_value.data_length = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 


};

@q ***** (5) handle_item: DATA_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ @>

@ \<handle item> $\longrightarrow$ \.{DATA\_HEXL\_ENCODED\_ZZ} \.{HEXL\_ENCODED\_STRING\_ZZ}.
\initials{LDF 2013.04.26.}

\LOG
\initials{LDF 2013.04.26.}
Added this rule.

\initials{LDF 2013.04.28.}
Rewrote this rule to account for the change in the type of \.{HEXL\_ENCODED\_STRING\_ZZ}
from |char[1024] string_value| to |void *pointer_value| (see union declaration above).
This makes it possible to have hexadecimal encoded strings of length $> 1024$.
\ENDLOG

@<Rules@>=

@=handle_item: DATA_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ @>
{
@q ****** (6) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: DATA_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ'."
             << endl;

        cerr << "`HEXL_ENCODED_STRING_ZZ' == " << static_cast<char*>(@=$2@>) 
             << endl;

        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

    string temp_str = static_cast<char*>(@=$2@>); 

    delete[] static_cast<char*>(@=$2@>);
    @=$2@> = 0;

    string dest;
    unsigned int dest_length;

    status = hexl_decode(temp_str, dest, dest_length);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "ERROR!  In `zzparse', "
             << "rule `handle_item: DATA_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ':"
             << endl
             << "`hexl_decode' failed, returning " << status << "."
             << endl
             << "Failed to decode hexadecimal-encoded string:"
             << endl
             << temp_str
             << endl
             << "Leaving data field of handle unset.  Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        ++param->errors_occurred;

    }  /* |if (status != 0)|  */

@q ****** (6) @>

    else /* |status == 0|  */
    {
@q ******* (7) @>

#if DEBUG_COMPILE 
        if (param->PARSER_DEBUG)
        {
            cerr << "[Thread " << param->thread_ctr << "] "
                 << "In `zzparse', "
                 << "rule `handle_item: DATA_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ':"
                 << endl
                 << "`hexl_decode' succeeded, returning 0."
                 << endl
                 << "Decoded hexadecimal-encoded string successfully."
                 << endl
                 << "`dest_length' == " << dest_length
                 << endl 
                 << "param->handle_value.data_length == " << param->handle_value.data_length
                 << endl 
                 << "`buffer' == " << endl;

            fwrite(dest.c_str(), 1, dest_length, stderr);

            cerr << endl
                 << "Setting `data' field of handle to `buffer'."
                 << endl;

            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

        if (   param->handle_value.data_length > 0 
            && param->handle_value.data_length != dest_length)
        {
            cerr << "[Thread " << param->thread_ctr << "] "
                 << "WARNING!  In `zzparse', "
                 << "rule `handle_item: DATA_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ':"
                 << endl
                 << "`param->handle_value.data_length' == " << param->handle_value.data_length
                 << endl
                 << "`dest_length' == " << dest_length
                 << endl 
                 << "`param->handle_value.data_length' is not 0 and not equal to `dest_length'."
                 << endl
                 << "This shouldn't happen.  Resetting `param->handle_value.data_length' "
                 << "to `dest_length' == " << dest_length << "."
                 << endl
                 << "Will try to continue."  
                 << endl;

             param->handle_value.data_length = dest_length; 

             ++param->warnings_occurred;
    
        }  /* |if|  */

@q ******* (7) @>

#if DEBUG_COMPILE

@q ******** (8) @>

        else if (   param->PARSER_DEBUG
                 && param->handle_value.data_length > 0 
                 && param->handle_value.data_length == dest_length)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] "
                 << "In `zzparse', "
                 << "rule `handle_item: DATA_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ':"
                 << endl
                 << "`param->handle_value.data_length' == `dest_length' == " << dest_length
                 << endl
                 << "This is as it should be."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if|  */

@q ******** (8) @>

        else if (   param->PARSER_DEBUG
                 && param->handle_value.data_length ==  0)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] "
                 << "In `zzparse', "
                 << "rule `handle_item: DATA_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ':"
                 << endl
                 << "`param->handle_value.data_length' == 0.  It may be set later."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if|  */

@q ******** (8) @>

#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

        param->handle_value.data = new char[dest_length + 1]; 
        memset(param->handle_value.data, 0, dest_length + 1);
        memcpy(param->handle_value.data, dest.c_str(), dest_length);

@q ******* (7) @>

    }  /* |else| (|status == 0|)  */

@q ****** (6) @>

    param->PARSER_DEBUG = save_PARSER_DEBUG; 


};

@q ***** (5) handle_item: TTL_TYPE_ZZ INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{TTL\_TYPE\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: TTL_TYPE_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: TTL_TYPE_ZZ INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.ttl_type = @=$2@>;

};

@q ***** (5) handle_item: TTL_ZZ INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{TTL\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: TTL_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

 #if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: TTL_ZZ INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.ttl = @=$2@>;

};

@q ***** (5) handle_item: TIMESTAMP_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{TIMESTAMP\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: TIMESTAMP_ZZ UNSIGNED_INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: TIMESTAMP_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.timestamp = @=$2@>;

};


@q ***** (5) handle_item: REFS_ZZ STRING_ZZ @>

@ \<handle item> $\longrightarrow$ \.{REFS\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: REFS_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));
#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: REFS_ZZ STRING_ZZ'."
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.refs = new char[strlen(@=$2@>) + 1];
   memset(param->handle_value.refs, 0, strlen(@=$2@>) + 1);
   strcpy(param->handle_value.refs, @=$2@>);

};

@q ***** (5) handle_item: REFS_LENGTH_ZZ INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{REFS\_LENGTH\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: REFS_LENGTH_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: REFS_LENGTH_ZZ INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.refs_length = @=$2@>;

};

@q ***** (5) handle_item: REFS_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ @>

@ \<handle item> $\longrightarrow$ \.{REFS\_HEXL\_ENCODED\_ZZ} \.{HEXL\_ENCODED\_STRING\_ZZ}.
\initials{LDF 2013.04.26.}

\LOG
\initials{LDF 2013.04.28.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: REFS_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ @>
{
@q ****** (6) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: REFS_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ'."
             << endl;

        cerr << "`HEXL_ENCODED_STRING_ZZ' == " << static_cast<char*>(@=$2@>) 
             << endl;

        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

    string temp_str = static_cast<char*>(@=$2@>); 

    delete[] static_cast<char*>(@=$2@>);

    string dest;
    unsigned int dest_length;

    status = hexl_decode(temp_str, dest, dest_length);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "ERROR!  In `zzparse', "
             << "rule `handle_item: REFS_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ':"
             << endl
             << "`hexl_decode' failed, returning " << status << "."
             << endl
             << "Failed to decode hexadecimal-encoded string:"
             << endl
             << temp_str
             << endl
             << "Leaving refs field of handle unset.  Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        ++param->errors_occurred;

    }  /* |if (status != 0)|  */

@q ****** (6) @>

    else /* |status == 0|  */
    {
@q ******* (7) @>

#if DEBUG_COMPILE 
        if (param->PARSER_DEBUG)
        {
            cerr << "[Thread " << param->thread_ctr << "] "
                 << "In `zzparse', "
                 << "rule `handle_item: REFS_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ':"
                 << endl
                 << "`hexl_decode' succeeded, returning 0."
                 << endl
                 << "Decoded hexadecimal-encoded string successfully."
                 << endl
                 << "`dest_length' == " << dest_length
                 << endl 
                 << "param->handle_value.refs_length == " << param->handle_value.refs_length
                 << endl 
                 << "`buffer' == " << endl;

            fwrite(dest.c_str(), 1, dest_length, stderr);

            cerr << endl
                 << "Setting `refs' field of handle to `buffer'."
                 << endl;

            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

        if (   param->handle_value.refs_length > 0 
            && param->handle_value.refs_length != dest_length)
        {
            cerr << "[Thread " << param->thread_ctr << "] "
                 << "WARNING!  In `zzparse', "
                 << "rule `handle_item: REFS_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ':"
                 << endl
                 << "`param->handle_value.refs_length' == " << param->handle_value.refs_length
                 << endl
                 << "`dest_length' == " << dest_length
                 << endl 
                 << "`param->handle_value.refs_length' is not 0 and not equal to `dest_length'."
                 << endl
                 << "This shouldn't happen.  Resetting `param->handle_value.refs_length' "
                 << "to `dest_length' == " << dest_length << "."
                 << endl
                 << "Will try to continue."  
                 << endl;

             param->handle_value.refs_length = dest_length; 

             ++param->warnings_occurred;
    
        }  /* |if|  */

@q ******* (7) @>

#if DEBUG_COMPILE

@q ******** (8) @>

        else if (   param->PARSER_DEBUG
                 && param->handle_value.refs_length > 0 
                 && param->handle_value.refs_length == dest_length)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] "
                 << "In `zzparse', "
                 << "rule `handle_item: REFS_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ':"
                 << endl
                 << "`param->handle_value.refs_length' == `dest_length' == " << dest_length
                 << endl
                 << "This is as it should be."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if|  */

@q ******** (8) @>

        else if (   param->PARSER_DEBUG
                 && param->handle_value.refs_length ==  0)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] "
                 << "In `zzparse', "
                 << "rule `handle_item: REFS_HEXL_ENCODED_ZZ HEXL_ENCODED_STRING_ZZ':"
                 << endl
                 << "`param->handle_value.refs_length' == 0.  It may be set later."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if|  */

@q ******** (8) @>

#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

        param->handle_value.refs = new char[dest_length]; 
        memset(param->handle_value.refs, 0, dest_length);
        memcpy(param->handle_value.refs, dest.c_str(), dest_length);

@q ******* (7) @>

    }  /* |else| (|status == 0|)  */

@q ****** (6) @>

};



@q ***** (5) handle_item: ADMIN_READ_ZZ INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{ADMIN\_READ\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: ADMIN_READ_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: ADMIN_READ_ZZ INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.admin_read = @=$2@>;

};

@q ***** (5) handle_item: ADMIN_WRITE_ZZ INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{ADMIN\_WRITE\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: ADMIN_WRITE_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: ADMIN_WRITE_ZZ INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.admin_write = @=$2@>;

};


@q ***** (5) handle_item: PUB_READ_ZZ INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{PUB\_READ\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: PUB_READ_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: PUB_READ_ZZ INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.pub_read = @=$2@>;

};

@q ***** (5) handle_item: PUB_WRITE_ZZ INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{PUB\_WRITE\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: PUB_WRITE_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

 #if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: PUB_WRITE_ZZ INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.pub_write = @=$2@>;

};

@q ***** (5) handle_item: HANDLE_ID_ZZ UNSIGNED_LONG_INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{HANDLE\_ID\_ZZ} \.{UNSIGNED\_LONG\_INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: HANDLE_ID_ZZ UNSIGNED_LONG_INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: HANDLE_ID_ZZ UNSIGNED_LONG_INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.handle_id = @=$2@>;

};


@q ***** (5) handle_item: HANDLE_VALUE_ID_ZZ UNSIGNED_LONG_INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{HANDLE\_VALUE\_ID\_ZZ} 
\.{UNSIGNED\_LONG\_INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: HANDLE_VALUE_ID_ZZ UNSIGNED_LONG_INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: HANDLE_VALUE_ID_ZZ UNSIGNED_LONG_INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 


    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.handle_value_id = @=$2@>;

};

@q ***** (5) handle_item: IRODS_OBJECT_ID_ZZ UNSIGNED_LONG_INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{IRODS\_OBJECT\_ID\_ZZ} 
\.{UNSIGNED\_LONG\_INTEGER\_ZZ}.
\initials{LDF 2013.08.26.}

\LOG
\initials{LDF 2013.08.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: IRODS_OBJECT_ID_ZZ UNSIGNED_LONG_INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: IRODS_OBJECT_ID_ZZ UNSIGNED_LONG_INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 


    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.irods_object_id = @=$2@>;

};


@q ***** (5) handle_item: CREATED_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{CREATED\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: CREATED_ZZ UNSIGNED_INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: CREATED_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.created = @=$2@>;

};

@q ***** (5) handle_item: LAST_MODIFIED_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{LAST\_MODIFIED\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2012.10.16.}

\LOG
\initials{LDF 2012.10.16.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: LAST_MODIFIED_ZZ UNSIGNED_INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: LAST_MODIFIED_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.last_modified = @=$2@>;

};

@q ***** (5) handle_item: DELETE_FROM_DATABASE_TIMESTAMP_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{DELETE\_FROM\_DATABASE\_TIMESTAMP\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.08.26.}

\LOG
\initials{LDF 2013.08.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: DELETE_FROM_DATABASE_TIMESTAMP_ZZ UNSIGNED_INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: "
             << "DELETE_FROM_DATABASE_TIMESTAMP_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.delete_from_database_timestamp = @=$2@>;

};


@q ***** (5) handle_item: CREATED_BY_USER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ @>

@ \<handle item> $\longrightarrow$ \.{CREATED\_BY\_USER\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.02.28.}

\LOG
\initials{LDF 2013.02.28.}
Added this rule.
\ENDLOG

@<Rules@>=

@=handle_item: CREATED_BY_USER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: CREATED_BY_USER_ZZ "
             << "UNSIGNED_INTEGER_ZZ STRING_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.created_by_user_id   = @=$2@>;
   param->handle_value.created_by_user_name = @=$3@>;

};

@q ***** (5) handle_item: MARKED_FOR_DELETION_ZZ INTEGER_ZZ @>

@ \<handle item> $\longrightarrow$ \.{MARKED\_FOR\_DELETION\_ZZ} 
\.{INTEGER\_ZZ}.
\initials{LDF 2013.07.15.}

\LOG
\initials{LDF 2013.07.15.}
Added this rule.

\initials{LDF 2013.08.22.}
Changed \.{DELETED\_ZZ} to \.{MARKED\_FOR\_DELETION\_ZZ}.
\ENDLOG

@<Rules@>=

@=handle_item: MARKED_FOR_DELETION_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `handle_item: MARKED_FOR_DELETION_ZZ INTEGER_ZZ'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   param->handle_value.marked_for_deletion = static_cast<bool>(@=$2@>); 

};

@q ***** (5) statement: SEND_ZZ FILE_ZZ STRING_ZZ REFERENCE_ZZ INTEGER_ZZ @>

@ \<statement> $\longrightarrow$ \.{SEND\_ZZ} \.{FILE\_ZZ} \.{STRING\_ZZ} 
\.{REFERENCE\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2012.11.21.}

\LOG
\initials{LDF 2012.11.21.}
Added this rule.

\initials{LDF 2014.01.07.}
Added \.{UNSIGNED\_INTEGER\_ZZ}.  It contains options.
\ENDLOG

@<Rules@>=

@=statement: SEND_ZZ FILE_ZZ STRING_ZZ REFERENCE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ @>
{
@q ****** (6) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

    Response_Type response;

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `statement: SEND_ZZ FILE_ZZ STRING_ZZ "
             << "REFERENCE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "`STRING_ZZ' (filename) == " << @=$3@>
             << endl 
             << "`INTEGER_ZZ' (reference for server) == " << @=$5@>
             << endl
             << "`UNSIGNED_INTEGER_ZZ' (options) == " << @=$6@> << " == " 
             << oct << @=$6@> << " (octal)" << dec
             << endl
             << "`param->gpg_key_fingerprint' == " << param->gpg_key_fingerprint
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
\LOG
\initials{LDF 2014.01.23.}
Added this section.
\ENDLOG

@<Rules@>=

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
          lock_cerr_mutex(); 
          cerr << "$3 == " << @=$3@> << endl;
          unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */     

    struct stat stat_buffer;

    errno = 0;
    status = stat(@=$3@>, &stat_buffer);

    if (status == -1)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "ERROR!  In `zzparse', rule `statement: SEND_ZZ FILE_ZZ STRING_ZZ "
             << "REFERENCE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ':"
             << endl
             << "`stat' failed, returning -1:"
             << endl
             << strerror(errno)
             << endl
             << "Failed to retrieve file system information about `" << @=$3@> << "'."
             << endl
             << "Can't send file.  Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        ++param->errors_occurred; 

        goto END_SEND_FILE_RULE;

    }  /* |if (status == -1)|  */

@q ****** (6) @>
@
@<Rules@>=

#if DEBUG_COMPILE 
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `statement: SEND_ZZ FILE_ZZ STRING_ZZ "
             << "REFERENCE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ':"
             << endl
             << "`stat' succeeded, returning 0."
             << endl
             << "Retrieved file system information about `" << @=$3@> << "' successfully."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */     

@q ****** (6) @>
@
@<Rules@>=

    if (stat_buffer.st_mode & S_IFDIR && !(@=$6@> & 4096U || @=$6@> & 8192U))
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "WARNING!  In `zzparse', rule `statement: SEND_ZZ FILE_ZZ STRING_ZZ "
             << "REFERENCE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ':"
             << endl
             << "`" << @=$3@> << "' is a directory,"
             << endl 
             <<"but compression has not been specified."
             << endl 
             << "This is not permitted."
             << endl
             << "Not sending directory.  Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        ++param->warnings_occurred; 

        goto END_SEND_FILE_RULE;

    }  /* |if (stat_buffer.st_mode & S_IFDIR && !(@=$6@> & 4096U || @=$6@> & 8192U))|  */

@q ****** (6) @>
@
@<Rules@>=

    else if (stat_buffer.st_mode & S_IFDIR)
    {
#if DEBUG_COMPILE 
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] "
                 << "In `zzparse', rule `statement: SEND_ZZ FILE_ZZ STRING_ZZ "
                 << "REFERENCE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ':"
                 << endl
                 << "`" << @=$3@> << "' is a directory and compression has been specified."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */     

        response.int_val = 1;  /* |response.int_val| is used to set the local 
                                  variable |bool is_directory| in 
                                  |Scan_Parse_Parameter_Type::client_action_send_file|.
                                  \initials{LDF 2014.01.23.}  */
                                  

    }  /* |else if (stat_buffer.st_mode & S_IFDIR)|  */

@q ****** (6) @>
@
@<Rules@>=

#if DEBUG_COMPILE 
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `statement: SEND_ZZ FILE_ZZ STRING_ZZ "
             << "REFERENCE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ':"
             << endl
             << "`" << @=$3@> << "' is not a directory."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */     

@q ****** (6) @>
@
@<Rules@>=

   response.type = Response_Type::SEND_FILE_TYPE;
   response.local_filename = @=$3@>;

   temp_strm.str("");

   temp_strm << "CLIENT SENDING FILE ";
 
@q ****** (6) @>

   if (@=$6@> & (32U | 128U | 512U))
   {
@q ******* (7) @>

        if (param->gpg_key_fingerprint.empty())
        {

#if DEBUG_COMPILE 
            if (param->PARSER_DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << param->thread_ctr << "] "
                     << "In `zzparse', rule `statement: SEND_ZZ FILE_ZZ STRING_ZZ "
                     << "REFERENCE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ':"
                     << endl
                     << "Encryption option used but `param->gpg_key_fingerprint' is empty."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

        }  /* |if (param->gpg_key_fingerprint.empty())|  */

@q ******* (7) @>

        else
        {

#if DEBUG_COMPILE 
            if (param->PARSER_DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << param->thread_ctr << "] "
                     << "In `zzparse', rule `statement: SEND_ZZ FILE_ZZ STRING_ZZ "
                     << "REFERENCE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ':"
                     << endl
                     << "Encryption option used and `param->gpg_key_fingerprint' is non-empty:"
                     << endl
                     << "`param->gpg_key_fingerprint' == " << param->gpg_key_fingerprint
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

        }  /* |if (param->gpg_key_fingerprint.empty())|  */

@q ******* (7) @>
@
@<Rules@>=
         

@q ******* (7) @>

   }  /* |if|  */

@q ****** (6) @>


   if (@=$6@> & 32U)  /* Encrypt  */
   {
      response.remote_filename = @=$3@>;
      response.remote_filename += ".gpg";

      temp_strm << "\"" << response.remote_filename << "\" REFERENCE " 
                << @=$5@> << " "
                << "GPG_KEY_FINGERPRINT \"" << param->gpg_key_fingerprint << "\"";
   }
   else if (@=$6@> & 128U)
   {
      response.remote_filename = @=$3@>;
      response.remote_filename += ".asc";
      temp_strm << "\"" << response.remote_filename << "\" REFERENCE " << @=$5@> << " "
                << "GPG_KEY_FINGERPRINT \"" << param->gpg_key_fingerprint << "\"";
   }
   else if (@=$6@> & 512U)  /* Signature file */
   {
      temp_strm << "\"" << @=$3@> << "\" REFERENCE " << @=$5@> << " " 
                << "GPG_KEY_FINGERPRINT \"" << param->gpg_key_fingerprint << "\"";
   }
   else 
      temp_strm << "\"" << @=$3@> << "\" REFERENCE " << @=$5@>;

   if (response.int_val > 0)
      temp_strm << " COMPRESSED_TAR_FILE";

   if (@=$6@> & 4096U)
      temp_strm << " GZIP";
  
   else if (@=$6@> & 8192U)
      temp_strm << " BZIP2";

   response.command = temp_strm.str();
   response.options = @=$6@>;

   param->response_deque.push_back(response);   

   temp_strm.str("");

#if DEBUG_COMPILE 
   if (param->PARSER_DEBUG)
   {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `statement: SEND_ZZ FILE_ZZ STRING_ZZ "
             << "REFERENCE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ':"
             << endl;

        response.show();

        unlock_cerr_mutex(); 

   }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


END_SEND_FILE_RULE:
   
   param->PARSER_DEBUG = save_PARSER_DEBUG; 


};

@q **** (4) statement --> CD_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ@>

@ \<statement> $\longrightarrow$ \.{CD\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ} 
\.{STRING\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.11.23.}

Integer:  Status code.  0 for success, non-zero for failure.\hfil\break
%
First string:  Requested directory.  May be a single directory or a path 
containing more than one directory.\hfil\break 
%
Second string:  Previous working directory.  Will be complete path.
%
Third string:  Current working directory.    Will be complete path.
%
Fourth string:  If |icommands == true|, the output of the \.{icd} command.
@:NOTE@> !! PLEASE NOTE: This is the only case that has been implemented 
as of this date.
\initials{LDF 2012.11.23.}

\LOG
\initials{LDF 2012.11.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: CD_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: CD_ZZ RESPONSE_ZZ INTEGER_ZZ "
             << "STRING_ZZ STRING_ZZ STRING_ZZ STRING_ZZ':"
             << endl
             << "`INTEGER_ZZ' (status code) == " << @=$3@> 
             << endl 
             << "`STRING_ZZ' (requested directory) == " << @=$4@> 
             << endl 
             << "`STRING_ZZ' (previous working directory) == " << @=$5@> 
             << endl 
             << "`STRING_ZZ' (current working directory) == " << @=$6@> 
             << endl
             << "`STRING_ZZ' (command output or response from server) == " << @=$7@> 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    string temp_str = @=$7@>;

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "cd -->" 
         << endl 
         << "Exit status:                       " << @=$3@> 
         << endl 
         << "Requested directory:               " << @=$4@> 
         << endl 
         << "Previous iRODS working directory:  " << @=$5@> 
         << endl 
         << "Current iRODS working directory:   " << @=$6@> 
         << endl 
         << "Response:                          " << temp_str
         << endl;

    if (temp_str.empty() || temp_str[temp_str.size() - 1] != '\n')
        cout << endl;

    if (@=$3@> == 4)
    {
       cout << "ERROR!  `cd' command failed.  "
            << "Server-side current iRODS working directory is in an undefined state." 
            << endl
            << "Try resetting using `cd' with no argument, or with a valid directory "
            << "as the argument."
            << endl;

       ++param->errors_occurred;
    }

    else if (@=$3@> != 0)
    {
       cout << "ERROR!  `cd' command failed.  "
            << "Server-side current iRODS working directory unchanged." 
            << endl
            << "Will try to continue."
            << endl;

       ++param->errors_occurred;
    }

    else 
    {
       param->irods_current_dir = @=$6@>;

       cout << "`cd' command succeeded.  Server-side current iRODS working directory changed to " 
            << "`" << param->irods_current_dir << "'."
            << endl;
    }

    cout << endl << endl;

    unlock_cerr_mutex(); 
    unlock_cout_mutex();

};

@q **** (4) statement --> MKDIR_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ@>

@ \<statement> $\longrightarrow$ \.{MKDIR\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ} 
\.{STRING\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.11.29.}

Integer:  Status code.  0 for success, non-zero for failure.\hfil\break
\initials{LDF 2012.11.29.}

\LOG
\initials{LDF 2012.11.29.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: MKDIR_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: MKDIR_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_Z':"
             << endl
             << "`INTEGER_ZZ' (status code) == " << @=$3@> 
             << endl 
             << "`STRING_ZZ' == " << @=$4@>
             << endl 
             << "`STRING_ZZ' == " << @=$4@>
             << endl 
             << "`STRING_ZZ' == " << @=$6@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "mkdir -->" 
         << endl 
         << "Exit status:            " << @=$3@> 
         << endl 
         << "Requested directories:  " << @=$4@> 
         << endl
         << "Command output:         ";

    if (strlen(@=$5@>) > 0)
       cout << @=$5@> << endl;
    else
       cout << "(None)" << endl;

    cout << "Server message:         " << @=$6@> 
         << endl;

    unlock_cerr_mutex();
    unlock_cout_mutex();


};

@q **** (4) statement --> RM_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ@>

@ \<statement> $\longrightarrow$ \.{RM\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ} 
\.{STRING\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.11.30.}

Integer:  Status code.  0 for success, non-zero for failure.\hfil\break
\initials{LDF 2012.11.30.}

\LOG
\initials{LDF 2012.11.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: RM_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: RM_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_Z':"
             << endl
             << "`INTEGER_ZZ' (status code) == " << @=$3@> 
             << endl 
             << "`STRING_ZZ' == " << @=$4@>
             << endl 
             << "`STRING_ZZ' == " << @=$4@>
             << endl 
             << "`STRING_ZZ' == " << @=$6@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "rm -->" 
         << endl 
         << "Exit status:                              " << @=$3@> 
         << endl 
         << "Files and directories in delete request:  " << @=$4@> 
         << endl
         << "Command output:                           ";

    if (strlen(@=$5@>) > 0)
       cout << @=$5@> << endl;
    else
       cout << "(None)" << endl;

    cout << "Server message:                           " << @=$6@> 
         << endl
         << endl;

    unlock_cout_mutex();
    unlock_cerr_mutex();

    if (@=$3@> != 0)
       ++param->errors_occurred;


};

@q **** (4) statement --> SERVER_ZZ SENDING_ZZ METADATA_ZZ FILE_ZZ STRING_ZZ @>
@q **** (4) UNSIGNED_INTEGER_ZZ.                                             @>

@ \<statement> $\longrightarrow$ \.{SERVER\_ZZ} \.{SENDING\_ZZ} \.{METADATA\_ZZ}
\.{FILE\_ZZ} \.{STRING\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2012.12.13.}

\LOG
\initials{LDF 2012.12.13.}
Added this rule.

\initials{LDF 2012.12.31.}
Added \.{UNSIGNED\_INTEGER\_ZZ}.
\ENDLOG

@<Rules@>=

@=statement: SERVER_ZZ SENDING_ZZ METADATA_ZZ FILE_ZZ STRING_ZZ UNSIGNED_INTEGER_ZZ@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));


    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse',"
             << endl 
             << "rule `statement: SERVER_ZZ SENDING_ZZ METADATA_ZZ FILE_ZZ STRING_ZZ "
             << "UNSIGNED_INTEGER_ZZ':"
             << endl
             << "`STRING_ZZ' == " << @=$5@>
             << endl
             << "`UNSIGNED_INTEGER_ZZ' == " << @=$6@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    string temp_filename;

    status = param->receive_file("", "", true, 0, &temp_filename);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] ERROR!  In `zzparse', rule"
             << endl 
             << "`statement: SERVER_ZZ SENDING_ZZ METADATA_ZZ FILE_ZZ "
             << "STRING_ZZ UNSIGNED_INTEGER_ZZ':"
             << endl         
             << "`Scan_Parse_Parameter_Type::receive_file' failed, returning "
             << status << "." 
             << endl
             << "Failed to receive or store metadata file."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        ++param->errors_occurred;

    }  /* |if (status != 0)|  */

    else  /* |status == 0|  */
    {
        lock_cout_mutex();
        lock_cerr_mutex(); 
        cout << "Received metadata for iRODS object `" << @=$5@> << "'."
             << endl 
             << "Stored in file:  " << temp_filename 
             << endl << endl;

        unlock_cerr_mutex();
        unlock_cout_mutex();

    }  /* |else| (|status == 0|)  */

@q ***** (5) @>
@
\LOG
\initials{LDF 2012.12.31.}
Added this section.
\ENDLOG
@<Rules@>=


    if (@=$6@> & 1U)  /* output option set  \initials{LDF 2012.12.31.}  */
    {
@q ****** (6) @>
 
         lock_cout_mutex();
         lock_cerr_mutex(); 
         cout << "Outputting file `" << temp_filename << "':"
              << endl;

         temp_strm << "cat " << temp_filename;

         errno = 0;
         status = system(temp_strm.str().c_str());
         cout << endl;
         unlock_cerr_mutex(); 
         unlock_cout_mutex();

         temp_strm.str("");

         if (status != 0)
         {
              lock_cerr_mutex(); 
              cerr << "[Thread " << param->thread_ctr << "] ERROR! In `zzparse',"
                   << endl 
                   << "rule `statement: SERVER_ZZ SENDING_ZZ METADATA_ZZ FILE_ZZ STRING_ZZ "
                   << "UNSIGNED_INTEGER_ZZ':"
                   << endl 
                   << "`system' failed, returning " << status << ":"
                   << endl
                   << strerror(errno)
                   << endl;

              if (WIFEXITED(status))
              {
                cerr << "WEXITSTATUS(" << status << ") == " 
                     << WEXITSTATUS(status) << endl;
              }
              else
              {
                cerr << "Process didn't exit." << endl;

              }
              unlock_cerr_mutex();     

         }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
         else if (param->PARSER_DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "[Thread " << param->thread_ctr << "] In `zzparse',"
                  << endl 
                  << "rule `statement: SERVER_ZZ SENDING_ZZ METADATA_ZZ FILE_ZZ STRING_ZZ "
                  << "UNSIGNED_INTEGER_ZZ':"
                  << endl 
                  << "`system' succeeded." 
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

    }  /* |if (@=$6@> & 1U)|  */

@q ***** (5) @>

#if DEBUG_COMPILE 
    else if (param->PARSER_DEBUG)
    {

         lock_cerr_mutex();
         cerr << "[Thread " << param->thread_ctr << "] In `zzparse',"
              << endl 
              << "rule `statement: SERVER_ZZ SENDING_ZZ METADATA_ZZ FILE_ZZ STRING_ZZ "
              << "UNSIGNED_INTEGER_ZZ':"
              << endl  
              << "Not outputting file `" << temp_filename << "':"
              << endl;
         unlock_cerr_mutex(); 
         
    }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<Rules@>=


    param->PARSER_DEBUG = save_PARSER_DEBUG; 


};

@q **** (4) statement --> ADD_ZZ METADATA_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ@>

@ \<statement> $\longrightarrow$ \.{ADD\_ZZ} \.{METADATA\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ} 
\.{STRING\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2012.12.14.}

Integer:  Status code.  0 for success, non-zero for failure.\hfil\break
\initials{LDF 2012.12.14.}

\LOG
\initials{LDF 2012.12.14.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: ADD_ZZ METADATA_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: ADD_ZZ METADATA_ZZ RESPONSE_ZZ INTEGER_ZZ "
             << "STRING_ZZ STRING_ZZ STRING_Z':"
             << endl
             << "`INTEGER_ZZ' (status code) == " << @=$4@> 
             << endl 
             << "`STRING_ZZ' == " << @=$5@>
             << endl 
             << "`STRING_ZZ' == " << @=$6@>
             << endl 
             << "`STRING_ZZ' == " << @=$7@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "add metadata-->" 
         << endl 
         << "Exit status:                              " << @=$4@> 
         << endl 
         << "Metadata file                             " << @=$5@> 
         << endl
         << "iRODS object                              " << @=$6@> 
         << endl
         << "Server message:";

    if (strlen(@=$7@>) > 0)
       cout << endl << "   " << @=$7@> << endl;
    else
       cout << "  (None)" << endl;

    cout << endl;
   
    unlock_cerr_mutex();
    unlock_cout_mutex();

};

@q **** (4) statement --> STORE_ZZ METADATA_ZZ RESPONSE_ZZ INTEGER_ZZ  @>
@q **** (4)               STRING_ZZ STRING_ZZ STRING_ZZ                @>

@ \<statement> $\longrightarrow$ \.{STORE\_ZZ} \.{METADATA\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ} 
\.{STRING\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.03.07.}

Integer:  Status code.  0 for success, non-zero for failure.\hfil\break
\initials{LDF 2013.03.07.}

\LOG
\initials{LDF 2013.03.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: STORE_ZZ METADATA_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: STORE_ZZ METADATA_ZZ RESPONSE_ZZ INTEGER_ZZ "
             << "STRING_ZZ STRING_ZZ STRING_Z':"
             << endl
             << "`INTEGER_ZZ' (status code) == " << @=$4@> 
             << endl 
             << "`STRING_ZZ' == " << @=$5@>
             << endl 
             << "`STRING_ZZ' == " << @=$6@>
             << endl 
             << "`STRING_ZZ' == " << @=$7@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "store metadata-->" 
         << endl 
         << "Exit status:                              " << @=$4@> 
         << endl 
         << "Dublin Core metadata/iRODS object file:   " << @=$5@> 
         << endl
         << "iRODS object referred to:                 " << @=$6@> 
         << endl
         << "Server message:";

    if (strlen(@=$7@>) > 0)
       cout << endl << "   " << @=$7@> << endl;
    else
       cout << "  (None)" << endl;

    cout << endl;

    unlock_cerr_mutex(); 
    unlock_cout_mutex();

};

@q **** (4) statement --> END_SERVER_ZZ RESPONSE_ZZ INTEGER_ZZ  @>

@ \<statement> $\longrightarrow$ \.{END\_SERVER\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2013.04.03.}

\LOG
\initials{LDF 2013.04.03.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: END_SERVER_ZZ RESPONSE_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: END_SERVER_ZZ RESPONSE_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER_ZZ' == " << @=$3@> 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 

    cout << "end_server response -->" 
         << endl
         << "Response code:  " << @=$3@>;

    if (@=$3@> == 0)
        cout << " (Success)";
    else if (@=$3@> == 1)
        cout << endl << "ERROR!  `END_SERVER' command not enabled.";
    else 
        cout << endl << "ERROR!  `END_SERVER' command failed.";

    cout << endl;

    unlock_cerr_mutex(); 
    unlock_cout_mutex();

    if (@=$3@> == 0)
    {
        lock_cout_mutex();
        lock_cerr_mutex(); 
        cerr << "Server and client will both exit.  "
             << "Exiting `zzparse' successfully with return value 2."
             << endl;
        unlock_cerr_mutex(); 
        unlock_cout_mutex();

        return 2;

    }  /* |if (@=$3@> == 0)|  */


};

@q **** (4) statement --> SLEEP_ZZ INTEGER_ZZ @>

@ \<statement> $\longrightarrow$ \.{SLEEP\_ZZ}
\.{INTEGER\_ZZ}.
\initials{LDF 2013.05.02.}

\LOG
\initials{LDF 2013.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SLEEP_ZZ INTEGER_ZZ @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzlex', rule "
             << "`statement: SLEEP_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    if (sleep_client_enabled)
    {
#if DEBUG_COMPILE 
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] In `zzlex', rule "
                 << "`statement: SLEEP_ZZ INTEGER_ZZ':"
                 << endl
                 << "`sleep_client_enabled' == `true'.  Will go to sleep for " 
                 << @=$2@> << " seconds."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */         

        lock_cout_mutex(); 
        lock_cerr_mutex(); 
        cout << "Sleep -->" 
             << endl 
             << "Sleep value:  " << @=$2@>
             << endl
             << "Going to sleep for " << @=$2@> << " seconds ..." << flush;
        unlock_cerr_mutex(); 
        unlock_cout_mutex(); 

        status = sleep(@=$2@>);

        
        lock_cout_mutex(); 
        lock_cerr_mutex(); 

        cout << endl;

        if (status == 0)
            cout << "Woke up after " << @=$2@> << " seconds." << endl;
        else
            cout << "Woke up after " << @=$2@> << " - " << status 
                 << " == " << (@=$2@> - status) << " seconds."
                 << endl 
                 << "Unslept seconds:  " << status 
                 << endl;

        unlock_cerr_mutex(); 
        unlock_cout_mutex(); 

    }  /* |if (sleep_client_enabled)|  */

@q ***** (5) @>

    else  /* |!sleep_client_enabled|  */
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] WARNING!  In `zzlex', rule "
             << "`statement: SLEEP_ZZ INTEGER_ZZ':"
             << endl
             << "`sleep_client_enabled' == `false'.  Not going to sleep for " 
             << @=$2@> << " seconds."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex(); 

        ++param->warnings_occurred;  


    }  /* |else| (|!sleep_client_enabled|)  */


@q ***** (5) @>

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) statement --> SLEEP_ZZ RESPONSE_ZZ INTEGER_ZZ INTEGER_ZZ @>

@ \<statement> $\longrightarrow$ \.{SLEEP\_ZZ} \.{RESPONSE\_ZZ} 
\.{INTEGER\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2013.04.19.}

\LOG
\initials{LDF 2013.04.19.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SLEEP_ZZ RESPONSE_ZZ INTEGER_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: SLEEP_ZZ RESPONSE_ZZ INTEGER_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER_ZZ' 1 == " << @=$3@>
             << endl  
             << "`INTEGER_ZZ' 2 == " << @=$4@> 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


    lock_cout_mutex(); 
    lock_cerr_mutex(); 
    cout << "Sleep response -->" 
         << endl 
         << "Response code:  " << @=$3@>
         << endl
         << "Sleep value:    " << @=$4@>
         << endl;

    if (@=$3@> == 0)
         cout << "Server thread will sleep for " << @=$4@> << " seconds." << endl;
    else if (@=$3@> == 1)
    {
         cout << "ERROR!  Server not put to sleep.  Continuing." << endl;

         ++param->errors_occurred;
    }
    else if (@=$3@> == 3)
    {
        cout << "WARNING!  `sleep_client_enabled' == `false' on the server-side."
             << endl
             << "Server not sending `SLEEP " << @=$4@> << "' command to client."
             << endl;

         ++param->warnings_occurred;

    }
    else 
    {
         cout << "ERROR!  Unknown server-side error."
              << endl;

         ++param->errors_occurred;
    }

    unlock_cerr_mutex(); 
    unlock_cout_mutex(); 

};

@q **** (4) statement --> SIGNAL_ZZ INTEGER_ZZ @>

@ \<statement> $\longrightarrow$ \.{SIGNAL\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2013.05.02.}

We don't bother checking that |@=$2@>| is a valid signal number here, because the server
already does this in the rules that tell it to send this command back to the client.
\initials{LDF 2013.05.02.}

\LOG
\initials{LDF 2013.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SIGNAL_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "        
             << "`statement: SIGNAL_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER_ZZ' == " << @=$2@>
             << endl;

        if (signal_client_enabled)
           cerr  << "`signal_client_enabled' == `true'."
                 << endl
                 << "Calling `pthread_kill(pthread_self(), " << @=$2@> << ")'."
                 << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


    if (signal_client_enabled)
    {

         lock_cout_mutex(); 
         lock_cerr_mutex(); 
         cout << "Sending signal " << signal_name_map[@=$2@>] << " (" << @=$2@> << ") to self."
              << endl;
         unlock_cerr_mutex();
         unlock_cout_mutex(); 

         pthread_kill(pthread_self(), @=$2@>);
    }
    else
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] WARNING!  In `zzparse', rule "        
             << "`statement: SIGNAL_ZZ INTEGER_ZZ':"
             << endl
             << "`signal_client_enabled' == `false'.  Not sending signal " 
             << signal_name_map[@=$2@>] << " (" << @=$2@> << ") to self."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex(); 

        ++param->warnings_occurred;

    }  /* |else|  */
    
    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> SHOW_ZZ CERTIFICATE_ZZ RESPONSE_ZZ INTEGER_ZZ @>
@q **** (4)               certificate_item_list                         @>

@ \<statement> $\longrightarrow$ \.{SHOW\_ZZ} \.{CERTIFICATE\_ZZ} \.{RESPONSE\_ZZ}
\.{INTEGER\_ZZ} \<certificate item list>.
\initials{LDF 2013.05.03.}

\LOG
\initials{LDF 2013.05.03.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement: SHOW_ZZ CERTIFICATE_ZZ RESPONSE_ZZ INTEGER_ZZ certificate_item_list @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: SHOW_ZZ CERTIFICATE_ZZ RESPONSE_ZZ INTEGER_ZZ certificate_item_list'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    temp_strm.str("");

    if (@=$4@> == 0 && param->cert_ptr != 0)
       param->cert_ptr->show("X.509 Certificate:", &temp_strm, false);

    lock_cerr_mutex(); 
    lock_cout_mutex();
    cout << "Certificate response -->"
         << endl
         << "Response code:  " << @=$4@>
         << endl;

    if (@=$4@> == 3)
    {
       cout << "WARNING!  User not authorized to show all certificates."
            << endl;

       ++param->warnings_occurred;
    }
    else if (@=$4@> != 0)
    {
        cout << "ERROR!  Server failed to retrieve certificate(s)."
             << endl;

       ++param->errors_occurred;

    }
  
    if (!temp_strm.str().empty())
        cout << temp_strm.str();

    cout << endl;

    unlock_cout_mutex();
    unlock_cerr_mutex(); 

    temp_strm.str("");

    delete param->cert_ptr;
    param->cert_ptr = 0;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) certificate_item_list @>
@ \<certificate item list>.

@=%type <int_value> certificate_item_list@>

@=%type <int_value> certificate_item@>

@q ***** (5) certificate_item_list: /* Empty  */@>

@ \<certificate item list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2013.05.03.}

\LOG
\initials{LDF 2013.05.03.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item_list: /* Empty  */ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item_list: /* Empty */'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    if (param->cert_ptr)
       param->cert_ptr->clear();
    else
       param->cert_ptr = new X509_Cert_Type;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) certificate_item_list: certificate_item_list certificate_item  @>

@ \<certificate item list> $\longrightarrow$ \<certificate item list> \<certificate item>.
\initials{LDF 2013.05.15.}

\LOG
\initials{LDF 2013.05.15.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item_list: certificate_item_list certificate_item @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item_list: certificate_item_list certificate_item'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) certificate_item  @>

@ \<certificate item>.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this section.
\ENDLOG

@q ***** (5) certificate_item: CERTIFICATE_ID_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{CERTIFICATE\_ID\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.05.15.}

\LOG
\initials{LDF 2013.05.15.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: CERTIFICATE_ID_ZZ UNSIGNED_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: CERTIFICATE_ID_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->certificate_id = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) certificate_item: USER_ID_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{USER\_ID\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.05.15.}

\LOG
\initials{LDF 2013.05.15.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: USER_ID_ZZ UNSIGNED_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: USER_ID_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->user_id = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) certificate_item: USER_NAME_ZZ STRING_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{USER\_NAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.15.}

\LOG
\initials{LDF 2013.05.15.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: USER_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: USER_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->user_name = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) certificate_item: ISSUER_CERT_ID_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{ISSUER\_CERT\_ID\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: ISSUER_CERT_ID_ZZ UNSIGNED_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: ISSUER_CERT_ID_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->issuer_cert_id = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) certificate_item: IS_CA_ZZ INTEGER_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{IS\_CA\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: IS_CA_ZZ INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: IS_CA_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->is_ca = static_cast<bool>(@=$2@>);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) certificate_item: IS_PROXY_ZZ INTEGER_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{IS\_PROXY\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: IS_PROXY_ZZ INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: IS_PROXY_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->is_proxy = static_cast<bool>(@=$2@>); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) certificate_item: ORGANIZATION_ZZ STRING_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{ORGANIZATION\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: ORGANIZATION_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: ORGANIZATION_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->organization = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) certificate_item: ORGANIZATIONAL_UNIT_NAME_ZZ STRING_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{ORGANIZATIONAL\_UNIT\_NAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: ORGANIZATIONAL_UNIT_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: ORGANIZATIONAL_UNIT_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->organizationalUnitName = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) certificate_item: COMMON_NAME_ZZ STRING_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{COMMON\_NAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: COMMON_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: COMMON_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->commonName = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) certificate_item: COUNTRY_NAME_ZZ STRING_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{COUNTRY\_NAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: COUNTRY_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: COUNTRY_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->countryName = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) certificate_item: LOCALITY_NAME_ZZ STRING_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{LOCALITY\_NAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: LOCALITY_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: LOCALITY_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->localityName = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) certificate_item: STATE_OR_PROVINCE_NAME_ZZ STRING_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{STATE\_OR\_PROVINCE\_NAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: STATE_OR_PROVINCE_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: STATE_OR_PROVINCE_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->stateOrProvinceName = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) certificate_item: SERIAL_NUMBER_ZZ UNSIGNED_LONG_INTEGER_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{SERIAL\_NUMBER\_ZZ} 
\.{UNSIGNED\_LONG\_INTEGER\_ZZ}.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: SERIAL_NUMBER_ZZ UNSIGNED_LONG_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: SERIAL_NUMBER_ZZ UNSIGNED_LONG_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_LONG_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->serialNumber = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) certificate_item: VALIDITY_NOT_BEFORE_ZZ UNSIGNED_LONG_INTEGER_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{VALIDITY\_NOT\_BEFORE\_ZZ} 
\.{UNSIGNED\_LONG\_INTEGER\_ZZ}.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: VALIDITY_NOT_BEFORE_ZZ UNSIGNED_LONG_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: VALIDITY_NOT_BEFORE_ZZ UNSIGNED_LONG_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_LONG_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->Validity_notBefore = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) certificate_item: VALIDITY_NOT_AFTER_ZZ UNSIGNED_LONG_INTEGER_ZZ @>

@ \<certificate item list> $\longrightarrow$ \.{VALIDITY\_NOT\_AFTER\_ZZ} 
\.{UNSIGNED\_LONG\_INTEGER\_ZZ}.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=certificate_item: VALIDITY_NOT_AFTER_ZZ UNSIGNED_LONG_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`certificate_item: VALIDITY_NOT_AFTER_ZZ UNSIGNED_LONG_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_LONG_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->cert_ptr->Validity_notAfter = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: VALIDITY_NOT_BEFORE_ZZ UNSIGNED_LONG_INTEGER_ZZ @>

@ \<user info item> $\longrightarrow$ \.{VALIDITY\_NOT\_BEFORE\_ZZ} 
\.{UNSIGNED\_LONG\_INTEGER\_ZZ}.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: VALIDITY_NOT_BEFORE_ZZ UNSIGNED_LONG_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: VALIDITY_NOT_BEFORE_ZZ UNSIGNED_LONG_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_LONG_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->certificate.Validity_notBefore = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: VALIDITY_NOT_AFTER_ZZ UNSIGNED_LONG_INTEGER_ZZ @>

@ \<user info item> $\longrightarrow$ \.{VALIDITY\_NOT\_AFTER\_ZZ} 
\.{UNSIGNED\_LONG\_INTEGER\_ZZ}.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: VALIDITY_NOT_AFTER_ZZ UNSIGNED_LONG_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: VALIDITY_NOT_AFTER_ZZ UNSIGNED_LONG_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_LONG_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->certificate.Validity_notAfter = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) @>

@q **** (4) statement --> SHOW_ZZ GROUPS_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ group_item_list @>

@ \<statement> $\longrightarrow$ \.{SHOW\_ZZ} \.{GROUPS\_ZZ} \.{RESPONSE\_ZZ}
\.{INTEGER\_ZZ} \.{STRING\_ZZ} \<group item list>.
\initials{LDF 2013.06.05.}

\LOG
\initials{LDF 2013.06.05.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement: SHOW_ZZ GROUPS_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ group_item_list @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: SHOW_ZZ GROUPS_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ "
             << "group_item_list'."
             << endl
             << "`INTEGER_ZZ' (4) == " << @=$4@>
             << endl
             << "`STRING_ZZ'  (5) == " << @=$5@>
             << endl
             << "`param->group_vector.size()' == " << param->group_vector.size()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    temp_strm.str("");

    lock_cerr_mutex(); 
    lock_cout_mutex();
    cout << "Show groups response -->"
         << endl
         << "Response code:  " << @=$4@>
         << endl;

    if (@=$4@> == 3)
    {
       cout << "WARNING!  User not authorized to show all groups."
            << endl;

       ++param->warnings_occurred;
    }
    else if (@=$4@> != 0)
    {
        cout << "ERROR!  Server failed to retrieve groups(s)."
             << endl;

       ++param->errors_occurred;

    }

    else if (param->group_vector.size() == 0)
       cout << "No group info to show."
            << endl;

    else
    {
       cout << "Group info for " << param->group_vector.size() << " groups:"
            << endl;

       for (vector<Group_Type>::iterator iter = param->group_vector.begin();
            iter != param->group_vector.end();
            ++iter)
       {
           iter->show("", &temp_strm);
       }
       
    }

    cout << temp_strm.str();
  
    unlock_cout_mutex();
    unlock_cerr_mutex(); 

    temp_strm.str("");

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) |group_item| and |group_item_list|.  @>

@ |group_item| and |group_item_list|.
\initials{LDF 2013.06.05.}

\LOG
\initials{LDF 2013.06.05.}
Added this section.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> group_item@>
@=%type <int_value> group_item_list@>

@q ***** (5) group_item_list: /* Empty */  @>

@ \<group item list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2013.06.05.}

\LOG
\initials{LDF 2013.06.05.}
Added this rule.
\ENDLOG

@<Rules@>=
@=group_item_list: /* Empty  */@>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`group_item_list: /* Empty  */'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->group_vector.clear();

    param->group_vector.push_back(Group_Type());

};

@q ***** (5) group_item_list: group_item_list group_item  @>

@ \<group item list> $\longrightarrow$ \<group item list> \<group item>
\initials{LDF 2013.06.05.}

\LOG
\initials{LDF 2013.06.05.}
Added this rule.
\ENDLOG

@<Rules@>=
@=group_item_list: group_item_list group_item@>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`group_item_list: group_item_list group_item'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

};

@q ***** (5) group_item: GROUP_ID_ZZ INTEGER_ZZ  @>

@ \<group item> $\longrightarrow$ \.{GROUP\_ID\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2013.06.05.}

\LOG
\initials{LDF 2013.06.05.}
Added this rule.
\ENDLOG

@<Rules@>=
@=group_item: GROUP_ID_ZZ INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`group_item: GROUP_ID_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER' (2) == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    if (!(   param->group_vector.back().group_id == 0
          || param->group_vector.back().group_id == @=$2@>))
    {
        param->group_vector.push_back(Group_Type());
    }

    param->group_vector.back().group_id = @=$2@>;    

};

@q ***** (5) group_item: GROUP_NAME_ZZ STRING_ZZ  @>

@ \<group item> $\longrightarrow$ \.{GROUP\_NAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.06.05.}

\LOG
\initials{LDF 2013.06.05.}
Added this rule.
\ENDLOG

@<Rules@>=
@=group_item: GROUP_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`group_item: GROUP_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING' (2) == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->group_vector.back().group_name = @=$2@>;    

};

@q ***** (5) group_item: CREATOR_ID_ZZ INTEGER_ZZ  @>

@ \<group item> $\longrightarrow$ \.{CREATOR\_ID\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2013.06.05.}

\LOG
\initials{LDF 2013.06.05.}
Added this rule.
\ENDLOG

@<Rules@>=
@=group_item: CREATOR_ID_ZZ INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`group_item: CREATOR_ID_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER' (2) == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->group_vector.back().creator_id = @=$2@>;    

};


@q ***** (5) group_item: CREATOR_USERNAME_ZZ STRING_ZZ  @>

@ \<group item> $\longrightarrow$ \.{CREATOR\_USERNAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.06.05.}

\LOG
\initials{LDF 2013.06.05.}
Added this rule.
\ENDLOG

@<Rules@>=
@=group_item: CREATOR_USERNAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`group_item: CREATOR_USERNAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING' (2) == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->group_vector.back().creator_username = @=$2@>;    

};

@q ***** (5) group_item: CREATED_ZZ UNSIGNED_INTEGER_ZZ  @>

@ \<group item> $\longrightarrow$ \.{CREATED\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.06.05.}

\LOG
\initials{LDF 2013.06.05.}
Added this rule.
\ENDLOG

@<Rules@>=
@=group_item: CREATED_ZZ UNSIGNED_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`group_item: CREATED_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_INTEGER' (2) == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->group_vector.back().created = static_cast<time_t>(@=$2@>); 

};



@q ***** (5) group_item: USER_ID_ZZ INTEGER_ZZ USER_NAME_ZZ STRING_ZZ @>
@q ***** (5)             PRIVILEGES_ZZ UNSIGNED_INTEGER_ZZ            @>

@ \<group item> $\longrightarrow$ \.{USER\_ID\_ZZ} \.{INTEGER\_ZZ}
\.{USER\_NAME\_ZZ} \.{STRING\_ZZ} \.{PRIVILEGES\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.06.05.}

\LOG
\initials{LDF 2013.06.05.}
Added this rule.
\ENDLOG

@<Rules@>=
@=group_item: USER_ID_ZZ INTEGER_ZZ USER_NAME_ZZ STRING_ZZ PRIVILEGES_ZZ UNSIGNED_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`group_item: USER_ID_ZZ INTEGER_ZZ USER_NAME_ZZ STRING_ZZ "
             << "PRIVILEGES_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "`INTEGER_ZZ'          (2) (user ID)    == " << @=$2@>
             << endl 
             << "`STRING_ZZ'           (4) (username)   == " << @=$4@>
             << endl 
             << "`UNSIGNED_INTEGER_ZZ' (6) (privileges) == " << @=$6@> << " == " 
             << oct << @=$6@> << " (octal)" << dec
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->group_vector.back().member_id_map.insert(
         make_pair(@=$2@>, make_pair(@=$4@>, @=$6@>)));


};


@q **** (4) statement --> AUTHENTICATION_ZZ ERROR_ZZ INTEGER_ZZ @>

@ \<statement> $\longrightarrow$ \.{AUTHENTICATION\_ZZ} \.{ERROR\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2013.05.10.}

\LOG
\initials{LDF 2013.05.10.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: AUTHENTICATION_ZZ ERROR_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: AUTHENTICATION_ZZ ERROR_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex(); 
    lock_cerr_mutex(); 
    cout << "Authentication error -->" 
         << endl
         << "Error code:  " << @=$3@>
         << endl
         << "Exiting."
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex(); 

    if (@=$3@> == 1)
    {
        lock_cerr_mutex();   
        cerr << "Unauthenticated connection and \"DISTINGUISHED_NAME\" command was either not "
             << "sent to server, or failed."
             << endl
             << "Please note that unauthenticated connections are only for testing purposes!"
             << endl
             << "Exiting."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (@=$3@> == 1)|  */

    else if (@=$3@> == 2)
    {
        lock_cerr_mutex();   
        cerr << "Server failed to verify user certificate."
             << endl
             << "Exiting."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (@=$3@> == 2)|  */

    param->response_deque.clear();
    param->client_finished = param->server_finished = true;
    return 0;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> DISTINGUISHED_NAME_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ @>
@q **** (4)               INTEGER_ZZ STRING_ZZ                                   @>

@ \<statement> $\longrightarrow$ \.{DISTINGUISHED\_NAME\_ZZ} \.{RESPONSE\_ZZ} 
\.{INTEGER\_ZZ} \.{STRING\_ZZ} \.{INTEGER\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.14.}

\LOG
\initials{LDF 2013.05.14.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DISTINGUISHED_NAME_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ INTEGER_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DISTINGUISHED_NAME_ZZ RESPONSE_ZZ "
             << "INTEGER_ZZ STRING_ZZ INTEGER_ZZ STRING_ZZ '."
             << endl
             << "`INTEGER_ZZ' (Response code) ==     " << @=$3@>
             << endl 
             << "`STRING_ZZ' (Distinguished Name) == " << @=$4@>
             << endl
             << "`INTEGER_ZZ' (User ID) ==           " << @=$5@>
             << endl 
             << "`STRING_ZZ' (Username) ==           " << @=$6@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "Distinguished Name response -->" 
         << endl
         << "Response code:       " << @=$3@>
         << endl 
         << "Distinguished Name:  " << @=$4@>
         << endl
         << "User ID:             " << @=$5@>
         << endl 
         << "Username:            " << @=$6@>
         << endl << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex();



    param->PARSER_DEBUG = save_PARSER_DEBUG; 


};


@q **** (4) statement: GET_USER_ZZ RESPONSE_ZZ INTEGER_ZZ @>
@q **** (4) USER_ID_ZZ INTEGER_ZZ USER_NAME_ZZ STRING_ZZ  @>

@ \<statement> $\longrightarrow$ \.{GET\_USER\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ}
\.{USER\_ID\_ZZ} \.{INTEGER\_ZZ} \.{USER\_NAME\_ZZ} \.{STRING\_ZZ} 
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this rule.
\ENDLOG 

@<Rules@>=

@=statement: GET_USER_ZZ RESPONSE_ZZ INTEGER_ZZ USER_ID_ZZ INTEGER_ZZ USER_NAME_ZZ STRING_ZZ @>
@=PRIVILEGES_ZZ UNSIGNED_INTEGER_ZZ                                                          @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule"
             << endl 
             << "`statement: GET_USER_ZZ RESPONSE_ZZ INTEGER_ZZ "
             << "USER_ID_ZZ INTEGER_ZZ USER_NAME_ZZ STRING_ZZ PRIVILEGES_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "Response code:  " << @=$3@>
             << endl 
             << "User ID:  " << @=$5@>
             << endl 
             << "Username:  " << @=$7@>
             << endl 
             << "Privileges:  " << @=$9@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    if (@=$3@> != 0)  
    {

        /* This conditional suppresses output in the ``normal'' case.
           It was getting annoying, seeing it all the time.
           \initials{LDF 2013.08.07.}  */

        lock_cout_mutex();
        lock_cerr_mutex(); 
        cout << "Get user response -->" 
             << endl
             << "Response code:  " << @=$3@>
             << endl;

        if (@=$3@> == 0)
        {
            param->user_id    = @=$5@>;
            param->username   = @=$7@>;
            param->privileges = @=$9@>;

            cout << "User ID:        " << param->user_id
                 << endl 
                 << "Username:       " << param->username
                 << endl;
 
#if 0 
            Scan_Parse_Parameter_Type::show_privileges(param->privileges, &cout);
#endif 

            cout << endl;
        }

        unlock_cerr_mutex(); 
        unlock_cout_mutex();


    }  /* |if (@=$3@> != 0)|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule"
             << endl 
             << "`statement: GET_USER_ZZ RESPONSE_ZZ INTEGER_ZZ "
             << "USER_ID_ZZ INTEGER_ZZ USER_NAME_ZZ STRING_ZZ PRIVILEGES_ZZ UNSIGNED_INTEGER_ZZ':"
             << endl
             << "`param->user_id' == " << param->user_id
             << endl 
             << "`param->username' == " << param->username
             << endl 
             << "`param->privileges' == " << param->privileges << " == " 
             << oct << param->privileges << " (octal)" << dec
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q **** (4) statement: GET_USER_INFO_ZZ RESPONSE_ZZ INTEGER_ZZ user_info_item_list  @>
@q **** (4) and                                                                     @>
@q **** (4) statement: WHOAMI_ZZ RESPONSE_ZZ INTEGER_ZZ user_info_item_list         @>

@ \<statement> $\longrightarrow$ \.{GET\_USER\_INFO\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ}
\<user info item list>
and
\<statement> $\longrightarrow$ \.{WHOAMI\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ}
\<user info item list>
\initials{LDF 2013.05.17.}
\initials{LDF 2013.05.19.}

These rules share an action.
\initials{LDF 2013.05.19.}

\LOG
\initials{LDF 2013.05.17.}
Added this rule.

\initials{LDF 2013.05.19.}
Added the \.{WHOAMI\_ZZ} rule.
\ENDLOG 

@<Rules@>=

@=statement: GET_USER_INFO_ZZ RESPONSE_ZZ INTEGER_ZZ user_info_item_list @>
@<Get user info action@>@;@/

@=statement: WHOAMI_ZZ RESPONSE_ZZ INTEGER_ZZ user_info_item_list @>
@<Get user info action@>@;@/

@q ***** (5) @>
@
@<Get user info action@>=
{
@q ****** (6) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

    string temp_str;
    string temp_str_1;

    if (@=$1@> ==  GET_USER_INFO_ZZ)
    {
       temp_str = "GET_USER_INFO_ZZ";
       temp_str_1 = "Get user info";
    }
    else
    {
       temp_str = "WHOAMI_ZZ";
       temp_str_1 = "Whoami";
    }

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule"
             << endl 
             << "`statement: " << temp_str << " RESPONSE_ZZ INTEGER_ZZ "
             << "user_info_item_list'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << temp_str_1 << " response -->" 
         << endl
         << "Response code:  " << @=$3@>
         << endl;


@q ****** (6) @>
@
@<Get user info action@>=

    if (@=$3@> == 0 && param->user_info_ptr != 0)
    {

        bool brief = (@=$1@> == WHOAMI_ZZ) ? true : false;

        param->user_info_ptr->distinguished_name = param->user_info_ptr->certificate;

        temp_strm.str("");

        param->user_info_ptr->show("User Info:", &temp_strm, brief);

        cout << temp_strm.str();

        temp_strm.str("");

    }  /* |if (@=$3@> == 0 && param->user_info_ptr != 0)|  */

@q ****** (6) @>
@
\LOG
\initials{LDF 2013.10.23.}
Added this section.
\ENDLOG
@<Get user info action@>=

    if (@=$3@> != 0 && @=$1@> ==  GET_USER_INFO_ZZ)
    {
        cerr << "Server-side error:  \"get_user_info\" command failed." << endl;

    }  /* |if (@=$3@> != 0)|  */


    cout << endl;

    unlock_cerr_mutex(); 
    unlock_cout_mutex();



@
@<Get user info action@>=

#if 0 
    if (@=$3@> == 0 && param->user_info_ptr != 0)
    {

        /* Show |*param->user_info_ptr|.  
           This can be a lot of information, so it will mostly be best
           to comment-out this conditional.

           \initials{LDF 2013.05.19.}  

        */       

#if DEBUG_COMPILE 
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule"
                 << endl 
                 << "`statement: " << temp_str << " RESPONSE_ZZ INTEGER_ZZ "
                 << "user_info_item_list':"
                 << endl;
#if 0 
            param->user_info_ptr->show("*param->user_info_ptr:");
#endif 

            unlock_cerr_mutex(); 


        }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    }  /* |if (@=$3@> == 0 && param->user_info_ptr != 0)|  */
#endif 

@q ****** (6) @>
@
@<Get user info action@>=


    if (param->user_info_ptr)
    {
        delete param->user_info_ptr;
        param->user_info_ptr = 0;
    }
       
    param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ****** (6) @>

};

@q **** (4) user_info_item_list @>
@ \<user info item list>.

\LOG
\initials{LDF 2013.05.17.}
Added these type declarations.
\ENDLOG 

@=%type <int_value> user_info_item_list@>

@=%type <int_value> user_info_item@>

@q ***** (5) user_info_item_list: /* Empty  */@>

@ \<user info item list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2013.05.17.}

\LOG
\initials{LDF 2013.05.17.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item_list: /* Empty  */ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item_list: /* Empty */'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    if (param->user_info_ptr)
       param->user_info_ptr->clear();
    else
       param->user_info_ptr = new User_Info_Type;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item_list: user_info_item_list user_info_item  @>

@ \<user info item list> $\longrightarrow$ \<user info item list> \<user info item>.
\initials{LDF 2013.05.17.}

\LOG
\initials{LDF 2013.05.17.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item_list: user_info_item_list user_info_item @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item_list: user_info_item_list user_info_item'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) user_info_item  @>

@ \<user info item>.
\initials{LDF 2013.05.17.}

\LOG
\initials{LDF 2013.05.17.}
Added this section.
\ENDLOG

@q ***** (5) user_info_item: USER_ID_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<user info item list> $\longrightarrow$ \.{USER\_ID\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.05.17.}

\LOG
\initials{LDF 2013.05.17.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: USER_ID_ZZ UNSIGNED_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: USER_ID_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->user_id = param->user_info_ptr->certificate.user_id = @=$2@>;


    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: USER_NAME_ZZ STRING_ZZ @>

@ \<user info item list> $\longrightarrow$ \.{USER\_NAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.17.}

\LOG
\initials{LDF 2013.05.17.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: USER_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: USER_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->username = param->user_info_ptr->certificate.user_name = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: CERTIFICATE_ID_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<user info item list> $\longrightarrow$ \.{CERTIFICATE\_ID\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.05.17.}

\LOG
\initials{LDF 2013.05.17.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: CERTIFICATE_ID_ZZ UNSIGNED_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: CERTIFICATE_ID_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->certificate.certificate_id = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: SERIAL_NUMBER_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<user info item list> $\longrightarrow$ \.{SERIAL\_NUMBER\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.05.17.}

\LOG
\initials{LDF 2013.05.17.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: SERIAL_NUMBER_ZZ UNSIGNED_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: SERIAL_NUMBER_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->certificate.serialNumber = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: ISSUER_CERT_ID_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<user info item list> $\longrightarrow$ \.{ISSUER\_CERT\_ID\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.05.17.}

\LOG
\initials{LDF 2013.05.17.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: ISSUER_CERT_ID_ZZ UNSIGNED_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: ISSUER_CERT_ID_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->certificate.issuer_cert_id = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};



@q ***** (5) user_info_item: COMMON_NAME_ZZ STRING_ZZ @>

@ \<user info item list> $\longrightarrow$ \.{COMMON\_NAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.17.}

\LOG
\initials{LDF 2013.05.17.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: COMMON_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: COMMON_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->certificate.commonName = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) user_info_item: LOCALITY_NAME_ZZ STRING_ZZ @>

@ \<user info item list> $\longrightarrow$ \.{LOCALITY\_NAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.19.}

\LOG
\initials{LDF 2013.05.19.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: LOCALITY_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: LOCALITY_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->certificate.localityName = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: STATE_OR_PROVINCE_NAME_ZZ STRING_ZZ @>

@ \<user info item list> $\longrightarrow$ \.{STATE\_OR\_PROVINCE\_NAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.19.}

\LOG
\initials{LDF 2013.05.19.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: STATE_OR_PROVINCE_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: STATE_OR_PROVINCE_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->certificate.stateOrProvinceName = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: COUNTRY_NAME_ZZ STRING_ZZ @>

@ \<user info item list> $\longrightarrow$ \.{COUNTRY\_NAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.19.}

\LOG
\initials{LDF 2013.05.19.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: COUNTRY_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: COUNTRY_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->certificate.countryName = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: ORGANIZATION_ZZ STRING_ZZ @>

@ \<user info item list> $\longrightarrow$ \.{ORGANIZATION\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.19.}

\LOG
\initials{LDF 2013.05.19.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: ORGANIZATION_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: ORGANIZATION_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->certificate.organization = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: ORGANIZATIONAL_UNIT_NAME_ZZ STRING_ZZ @>

@ \<user info item list> $\longrightarrow$ \.{ORGANIZATIONAL\_UNIT\_NAME\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.19.}

\LOG
\initials{LDF 2013.05.19.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: ORGANIZATIONAL_UNIT_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: ORGANIZATIONAL_UNIT_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->certificate.organizationalUnitName = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: IS_CA_ZZ INTEGER_ZZ @>

@ \<user info item> $\longrightarrow$ \.{IS\_CA\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: IS_CA_ZZ INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: IS_CA_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->certificate.is_ca = static_cast<bool>(@=$2@>);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) user_info_item: IS_PROXY_ZZ INTEGER_ZZ @>

@ \<user info item> $\longrightarrow$ \.{IS\_PROXY\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: IS_PROXY_ZZ INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: IS_PROXY_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->certificate.is_proxy = static_cast<bool>(@=$2@>); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: PRIVILEGES_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<user info item> $\longrightarrow$ \.{PRIVILEGES\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: PRIVILEGES_ZZ UNSIGNED_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: PRIVILEGES_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->privileges = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: IRODS_HOMEDIR_ZZ STRING_ZZ @>

@ \<user info item> $\longrightarrow$ \.{IRODS\_HOMEDIR\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: IRODS_HOMEDIR_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: IRODS_HOMEDIR_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->irods_homedir = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: IRODS_CURRENT_DIR_ZZ STRING_ZZ @>

@ \<user info item> $\longrightarrow$ \.{IRODS\_CURRENT\_DIR\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: IRODS_CURRENT_DIR_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: IRODS_CURRENT_DIR_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->irods_current_dir = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) user_info_item: IRODS_ZONE_ZZ STRING_ZZ @>

@ \<user info item> $\longrightarrow$ \.{IRODS\_ZONE\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: IRODS_ZONE_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: IRODS_ZONE_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->irods_zone = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: IRODS_DEFAULT_RESOURCE_ZZ STRING_ZZ @>

@ \<user info item> $\longrightarrow$ \.{IRODS\_DEFAULT\_RESOURCE\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: IRODS_DEFAULT_RESOURCE_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: IRODS_DEFAULT_RESOURCE_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->irods_default_resource = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: DEFAULT_HANDLE_PREFIX_ZZ STRING_ZZ @>

@ \<user info item> $\longrightarrow$ \.{DEFAULT\_HANDLE\_PREFIX\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: DEFAULT_HANDLE_PREFIX_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: DEFAULT_HANDLE_PREFIX_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->default_handle_prefix = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: DEFAULT_HANDLE_PREFIX_ID_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<user info item> $\longrightarrow$ \.{DEFAULT\_HANDLE\_PREFIX\_ID\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: DEFAULT_HANDLE_PREFIX_ID_ZZ UNSIGNED_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: DEFAULT_HANDLE_PREFIX_ID_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->default_handle_prefix_id = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: DEFAULT_INSTITUTE_NAME_ZZ STRING_ZZ @>

@ \<user info item> $\longrightarrow$ \.{DEFAULT\_INSTITUTE\_NAME\_ZZ} 
\.{STRING\_ZZ}.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: DEFAULT_INSTITUTE_NAME_ZZ STRING_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: DEFAULT_INSTITUTE_NAME_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->default_institute_name = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) user_info_item: DEFAULT_INSTITUTE_ID_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<user info item> $\longrightarrow$ \.{DEFAULT\_INSTITUTE\_ID\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=user_info_item: DEFAULT_INSTITUTE_ID_ZZ UNSIGNED_INTEGER_ZZ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`user_info_item: DEFAULT_INSTITUTE_ID_ZZ UNSIGNED_INTEGER_ZZ'."
             << endl
             << "`UNSIGNED_INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->user_info_ptr->default_institute_id = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) @>

@q **** (4) @>

@q **** (4) statement: PROCESS_ZZ PENDING_ZZ OPERATIONS_ZZ RESPONSE_ZZ INTEGER_ZZ @>

@ \<statement> $\longrightarrow$ \.{PROCESS\_ZZ} \.{PENDING\_ZZ}
\.{OPERATIONS\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2013.05.23.}

\LOG
\initials{LDF 2013.05.23.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: PROCESS_ZZ PENDING_ZZ OPERATIONS_ZZ RESPONSE_ZZ INTEGER_ZZ @>
{
@q ***** (5) @>

     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

     bool save_PARSER_DEBUG = param->PARSER_DEBUG;
     param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] "
              << "In `zzparse', rule `statement: PROCESS_ZZ PENDING_ZZ OPERATIONS_ZZ "
              << "RESPONSE_ZZ INTEGER_ZZ'."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

     lock_cout_mutex(); 
     lock_cerr_mutex();
     cout << "process pending operations response -->"
          << endl
          << "Response code:  " << @=$5@>
          << endl << endl;
     unlock_cerr_mutex(); 
     unlock_cout_mutex(); 


     param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q **** (4) statement --> CREATE_ZZ HANDLE_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ @>

@ \<statement> $\longrightarrow$ \.{CREATE\_ZZ} \.{HANDLE\_ZZ} \.{RESPONSE\_ZZ} 
\.{INTEGER\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.05.24.}

\LOG
\initials{LDF 2013.05.24.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: CREATE_ZZ HANDLE_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: CREATE_ZZ HANDLE_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ'."
             << endl
             << "`INTEGER_ZZ' (4) (Response code) == " << @=$4@>
             << endl 
             << "`STRING_ZZ'  (5) (Handle) ==        " << @=$5@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cerr_mutex();
    lock_cout_mutex();
    cout << "Create handle response -->"
         << endl
         << "Response code:  " << @=$4@>
         << endl
         << "Handle:         " << @=$5@>
         << endl;
    unlock_cerr_mutex();
    unlock_cout_mutex(); 
   
    if (@=$4@> != 0)
    {
        lock_cerr_mutex(); 
        cerr << "Failed to create handle " << @=$5@> << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        ++param->errors_occurred;

    }

};

@q **** (4) statement --> ADD_ZZ HANDLE_VALUE_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ @>
@q **** (4)               INTEGER_ZZ STRING_ZZ STRING_ZZ                          @>

@ \<statement> $\longrightarrow$ \.{ADD\_ZZ} \.{HANDLE\_VALUE\_ZZ} \.{RESPONSE\_ZZ} 
\.{INTEGER\_ZZ} \.{STRING\_ZZ} \.{INTEGER\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.06.15.}

\LOG
\initials{LDF 2013.06.15.}
Added this rule.

\initials{LDF 2013.07.03.}
Added \.{INTEGER\_ZZ} for the index, \.{STRING\_ZZ} for the type of the handle value and
\.{STRING\_ZZ} for the data string or |"(binary)"|, if the latter is binary.
\ENDLOG

@<Rules@>=

@=statement: ADD_ZZ HANDLE_VALUE_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ @>
@=INTEGER_ZZ STRING_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

    string temp_str;

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: ADD_ZZ HANDLE_VALUE_ZZ RESPONSE_ZZ "
             << "INTEGER_ZZ STRING_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ'."
             << endl
             << "`INTEGER_ZZ' (4) (Response code) == " << @=$4@>
             << endl 
             << "`STRING_ZZ'  (5) (Handle)        == " << @=$5@>
             << endl 
             << "`INTEGER_ZZ' (6) (idx)           == " << @=$6@>
             << endl 
             << "`STRING_ZZ'  (7) (type)          == " << @=$7@>
             << endl 
             << "`STRING_ZZ'  (8) (data)          == " << @=$8@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cerr_mutex();
    lock_cout_mutex();
    cout << "Add handle value response -->"
         << endl
         << "Response code:  " << @=$4@>;

    if (@=$4@> == 0)
        cout << " (Success)";

    cout << endl
         << "Handle:         " << @=$5@>
         << endl;

    if (@=$6@> > 0)
    {
        cout << "Index:          " << @=$6@>;

        temp_str = Handle_Value_Type::idx_type_map[@=$6@>];

        if (!temp_str.empty())
           cout << " (" << temp_str << ")";

        cout << endl;

    }

    else
        cout << "Index == 0" << endl; 

    if (strlen(@=$7@>) > 0)
        cout << "Type:           " << @=$7@> << endl;
    else
        cout << "Type:           (Empty)" << endl << endl;

    if (strlen(@=$8@>) > 0)
        cout << "Data:           " << @=$8@> << endl;
    else
        cout << "Data:           (Empty)" << endl;

    if (@=$4@> == 2)
    {
        cerr << "WARNING!  Handle value with type == " 
             << @=$6@>; 

        if (!temp_str.empty())
           cerr << " (" << temp_str << ")";

        cerr << " already exists in handle " 
             << @=$5@> << "."
             << endl
             << "Not added.  Continuing."
             << endl << endl;

         ++param->warnings_occurred;

    }
  
    else if (@=$4@> != 0)
    {

        cerr << "ERROR!  Failed to add handle value to handle " << @=$5@> << "."
             << endl
             << "Will try to continue."
             << endl << endl;

        ++param->errors_occurred;

    }
    else
       cout << endl;
 

    unlock_cerr_mutex();
    unlock_cout_mutex(); 


};

@q **** (4) statement --> DELETE_ZZ HANDLE_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ @>

@ \<statement> $\longrightarrow$ \.{DELETE\_ZZ} \.{HANDLE\_VALUE\_ZZ} \.{RESPONSE\_ZZ} 
\.{INTEGER\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.07.04.}

\LOG
\initials{LDF 2013.07.04.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DELETE_ZZ HANDLE_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

    string temp_str;

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DELETE_ZZ HANDLE_ZZ RESPONSE_ZZ "
             << "INTEGER_ZZ STRING_ZZ STRING_ZZ'."
             << endl
             << "`INTEGER_ZZ' (4) (Response code) == " << @=$4@>
             << endl 
             << "`STRING_ZZ'  (5) (Handle)        == " << @=$5@>
             << endl 
             << "`STRING_ZZ'  (6) (Message)       == " << @=$6@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cerr_mutex();
    lock_cout_mutex();
    cout << "Delete handle response -->"
         << endl
         << "Response code:  " << @=$4@>;

    if (@=$4@> == 0)
        cout << " (Success)";

    cout << endl
         << "Handle:         " << @=$5@>
         << endl;

    if (strlen(@=$6@>) > 0)
    {
        cout << "Message:        " << @=$6@>
             << endl;
    }

    else
        cout << "(No message)" << endl; 

    cout << endl;
 
    unlock_cerr_mutex();
    unlock_cout_mutex(); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) statement --> UNDELETE_ZZ HANDLE_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ@>

@ \<statement> $\longrightarrow$ \.{UNDELETE\_ZZ} \.{HANDLE\_ZZ} \.{RESPONSE\_ZZ} 
\.{INTEGER\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.08.21.}

\LOG
\initials{LDF 2013.08.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: UNDELETE_ZZ HANDLE_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`statement: UNDELETE_ZZ HANDLE_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ':"
             << endl
             << "`INTEGER_ZZ' (response code) ($4) == " << @=$4@> 
             << endl
             << "`STRING_ZZ' (handle) ($5) == " << @=$5@> 
             << endl
             << "`STRING_ZZ' (message) ($6) == " << @=$6@> 
             << endl;
         unlock_cerr_mutex();
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cerr_mutex(); 
    lock_cout_mutex(); 
    cout << "Undelete handle response-->" 
         << endl 
         << "Response code:  " << @=$4@>;

    if (@=$4@> != 0)
       cout << " (" << gwstrerror(@=$4@>) << ")";

    cout << endl
         << "Handle:         " << @=$5@>
         << endl 
         << "Message:        " << @=$6@>
         << endl << endl;
    unlock_cout_mutex(); 
    unlock_cerr_mutex(); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};



@q **** (4) statement: DELETE_ZZ HANDLE_VALUE_ZZ RESPONSE_ZZ INTEGER_ZZ  @>
@q **** (4) STRING_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ           @>
@q **** (4) UNSIGNED_LONG_INTEGER_ZZ UNSIGNED_INTEGER_ZZ                 @>


@ \<statement> $\longrightarrow$ \.{DELETE\_ZZ} \.{HANDLE\_VALUE\_ZZ} 
\.{RESPONSE\_ZZ} \.{INTEGER\_ZZ} \.{STRING\_ZZ} 
\.{INTEGER\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ} 
\.{INTEGER\_ZZ } \.{UNSIGNED\_LONG\_INTEGER\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ}.
\initials{LDF 2013.07.17.}

\LOG
\initials{LDF 2013.07.17.}
Added this rule.

\initials{LDF 2013.09.11.}
Added \.{INTEGER\_ZZ}, \.{UNSIGNED\_LONG\_INTEGER\_ZZ} and \.{UNSIGNED\_INTEGER\_ZZ}.
\ENDLOG

@<Rules@>=

@=statement: DELETE_ZZ HANDLE_VALUE_ZZ RESPONSE_ZZ INTEGER_ZZ @>
@=STRING_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ @>
@=INTEGER_ZZ UNSIGNED_LONG_INTEGER_ZZ UNSIGNED_INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "]"
             << endl 
             << "Rule:  `statement: DELETE_ZZ HANDLE_VALUE_ZZ RESPONSE_ZZ INTEGER_ZZ"
             << endl 
             << "STRING_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ"
             << endl 
             << "INTEGER_ZZ UNSIGNED_LONG_INTEGER_ZZ UNSIGNED_INTEGER_ZZ':"
             << endl
             << "`INTEGER_ZZ' (Response code)                    == " << @=$4@>
             << endl 
             << "`STRING_ZZ' (Handle value specifier)            == " << @=$5@>
             << endl 
             << "`INTEGER_ZZ' (Index)                            == " << @=$6@>
             << endl 
             << "`STRING_ZZ' (Type)                              == " << @=$7@>
             << endl 
             << "`STRING_ZZ' (Data)                              == " << @=$8@>
             << endl 
             << "`STRING_ZZ' (Message)                           == " << @=$9@>
             << endl
             << "`INTEGER_ZZ' (\"Immediate\")                    == " << @=$10@>
             << endl 
             << "`UNSIGNED_LONG_INTEGER_ZZ' (Deletion timestamp) == " << @=$11@>
             << endl 
             << "`UNSIGNED_INTEGER_ZZ' (`purge_database_limit')  == " << @=$12@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


    string temp_str = gwstrerror(@=$4@>, true);

    if (!temp_str.empty())
    {
       temp_str.insert(0, " (");
       temp_str += ")";
    }
 
    lock_cerr_mutex(); 
    lock_cout_mutex(); 
    cout << "Delete handle value response -->" 
         << endl
         << "Response code:                " << @=$4@>
         << temp_str
         << endl 
         << "Handle value specifier:       " << @=$5@>
         << endl
         << "Index:                        " << @=$6@>
         << endl 
         << "Type:                         " << @=$7@>
         << endl 
         << "Data:                         " << @=$8@>
         << endl 
         << "Immediate deletion (or not):  " << @=$10@>
         << endl 
         << "Deletion timestamp:           " << @=$11@>;

    if (@=$11@> > 0)
       cout << " " << convert_seconds(@=$11@>);

    cout << endl 
         << "`purge_database_limit':       " << @=$12@>
         << endl 
         << "Message:                      " << @=$9@>
         << endl << endl;
    unlock_cout_mutex(); 
    unlock_cerr_mutex(); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement: UNDELETE_ZZ HANDLE_VALUE_ZZ RESPONSE_ZZ INTEGER_ZZ  @>
@q **** (4) STRING_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ             @>

@ \<statement> $\longrightarrow$ \.{UNDELETE\_ZZ} \.{HANDLE\_VALUE\_ZZ} 
\.{RESPONSE\_ZZ} \.{INTEGER\_ZZ} \.{STRING\_ZZ} 
\.{INTEGER\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.09.11.}

\LOG
\initials{LDF 2013.09.11.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: UNDELETE_ZZ HANDLE_VALUE_ZZ RESPONSE_ZZ INTEGER_ZZ @>
@=STRING_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: UNDELETE_ZZ HANDLE_VALUE_ZZ RESPONSE_ZZ "
             << "INTEGER_ZZ STRING_ZZ INTEGER_ZZ "
             << "STRING_ZZ STRING_ZZ STRING_ZZ'."
             << endl
             << "`INTEGER_ZZ' (Response code) ==         " << @=$4@>
             << endl 
             << "`STRING_ZZ' (Handle value specifier) == " << @=$5@>
             << endl 
             << "`INTEGER_ZZ' (Index) ==                 " << @=$6@>
             << endl 
             << "`STRING_ZZ' (Type) ==                   " << @=$7@>
             << endl 
             << "`STRING_ZZ' (Data) ==                   " << @=$8@>
             << endl 
             << "`STRING_ZZ' (Message) ==                " << @=$9@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex(); 
    lock_cerr_mutex(); 
    cout << "Undelete handle value response -->" 
         << endl
         << "Response code:           " << @=$4@>
         << endl 
         << "Handle value specifier:  " << @=$5@>
         << endl
         << "Index:                   " << @=$6@>
         << endl 
         << "Type:                    " << @=$7@>
         << endl 
         << "Data:                    " << @=$8@>
         << endl 
         << "Message:                 " << @=$9@>
         << endl << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex(); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) statement --> SEND_ZZ TAN_ZZ LIST_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ @>

@ \<statement> $\longrightarrow$ \.{SEND\_ZZ} \.{TAN\_ZZ} \.{LIST\_ZZ} \.{RESPONSE\_ZZ} 
\.{INTEGER\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.06.01.}

\LOG
\initials{LDF 2013.06.01.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SEND_ZZ TAN_ZZ LIST_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: SEND_ZZ TAN_ZZ LIST_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ'."
             << endl
             << "`INTEGER_ZZ' (5) (Response code) == " << @=$5@>
             << endl 
             << "`STRING_ZZ'  (6) (Message) ==       " << @=$6@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cerr_mutex();
    lock_cout_mutex();
    cout << "Send tan list response -->"
         << endl
         << "Response code:  " << @=$5@>
         << endl
         << "Message:        " << @=$6@>
         << endl;
    unlock_cerr_mutex();
    unlock_cout_mutex(); 

    if (@=$5@> == 3)
       ++param->warnings_occurred;
   
};

@q **** (4) statement --> MARK_ZZ IRODS_OBJECT_ZZ FOR_ZZ DELETION_ZZ RESPONSE_ZZ  @>
@q **** (4)               INTEGER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ                @>
@q **** (4)               UNSIGNED_LONG_INTEGER_ZZ STRING_ZZ  @>

@ \<statement> $\longrightarrow$ \.{MARK\_ZZ} \.{IRODS\_OBJECT\_ZZ} 
\.{FOR\_ZZ} \.{DELETION\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ} \.{STRING\_ZZ} \.{UNSIGNED\_LONG\_INTEGER\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.08.07.}

\LOG
\initials{LDF 2013.08.07.}
Added this rule.

\initials{LDF 2013.08.08.}
Added \.{UNSIGNED\_LONG\_INTEGER\_ZZ}.  It refers to the timestamp for the ``delay'' value.

\initials{LDF 2013.08.21.}
Added \.{UNSIGNED\_INTEGER\_ZZ}.  It contains the deletion options used, i.e., 0 for archive only, 
1 for archive and database or 2 for the database only.
\ENDLOG

@<Rules@>=

@=statement: MARK_ZZ IRODS_OBJECT_ZZ FOR_ZZ DELETION_ZZ RESPONSE_ZZ @>
@=INTEGER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ UNSIGNED_LONG_INTEGER_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: MARK_ZZ IRODS_OBJECT_ZZ FOR_ZZ DELETION_ZZ"
             << endl 
             << "RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ "
             << "UNSIGNED_LONG_INTEGER_ZZ STRING_ZZ'."
             << endl
             << "`INTEGER_ZZ' ($6) Response code ==           " << @=$6@>
             << endl
             << "`UNSIGNED_INTEGER_ZZ' ($7) Options ==        " << @=$7@>
             << endl
             << "`STRING_ZZ'  ($8) iRODS object path ==       " << @=$8@>
             << endl
             << "`UNSIGNED_LONG_INTEGER_ZZ' ($9) timestamp == " << @=$9@>;

        if (@=$9@> > 0UL)
           cerr << " == " << convert_seconds(@=$9@>, true);

        cerr << endl 
             << "`STRING_ZZ'  ($10) Message ==                 " << @=$10@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "Mark iRODS object for deletion response -->" 
         << endl
         << "iRODS object path(s):          " << @=$8@>
         << endl 
         << "Response code:                 " << @=$6@>
         << endl
         << "Options:                       " << @=$7@>
         << endl;
      
    if (@=$6@> != 0)
        cout << "Error:                         " << gwstrerror(@=$6@>) 
             << endl;
    else
    {
       if (@=$7@> & 2U)
           cout << "Marked for deletion from archive and `gwirdsif' database."
                << endl;
       else if (@=$7@> & 4U)
           cout << "Marked for deletion from `gwirdsif' database."
                << endl;
       else 
           cout << "Marked for deletion from archive."
                << endl;
    }

    if (@=$9@> > 0UL)
        cout << "Timestamp (deletion time):     " << @=$9@> << " == " 
             << convert_seconds(@=$9@>, true)
             << endl;

    cout << "Message:                       " << @=$10@>
         << endl
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex();

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> DELAY_ZZ OPTION_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ @>

@ \<statement> $\longrightarrow$ \.{DELAY\_ZZ} \.{OPTION\_ZZ} \.{RESPONSE\_ZZ} 
\.{INTEGER\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.08.08.}

\LOG
\initials{LDF 2013.08.08.}
Added this rule.  
\ENDLOG

@<Rules@>=

@=statement: DELAY_ZZ OPTION_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DELAY_ZZ OPTION_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ'."
             << endl
             << "`INTEGER_ZZ' == " << @=$4@>
             << endl 
             << "`STRING_ZZ' == " << @=$5@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "Delay option response -->" 
         << endl
         << "Code number:  " << @=$4@>
         << endl
         << "Message:      " << @=$5@>
         << endl
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex();

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> DATABASE_ZZ OPTION_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ @>

@ \<statement> $\longrightarrow$ \.{DATABASE\_ZZ} \.{OPTION\_ZZ} \.{RESPONSE\_ZZ} 
\.{INTEGER\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.08.12.}

\LOG
\initials{LDF 2013.08.12.}
Added this rule.  
\ENDLOG

@<Rules@>=

@=statement: DATABASE_ZZ OPTION_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DATABASE_ZZ OPTION_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ'."
             << endl
             << "`INTEGER_ZZ' == " << @=$4@>
             << endl 
             << "`STRING_ZZ' == " << @=$5@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "Database option response -->" 
         << endl
         << "Code number:  " << @=$4@>
         << endl
         << "Message:      " << @=$5@>
         << endl
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex();

    if (@=$4@> == 1)
      ++param->errors_occurred;

    else if (@=$4@> == 2)
      ++param->warnings_occurred;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> UNDELETE_ZZ RESPONSE_ZZ INTEGER_ZZ       @>
@q **** (4)               UNSIGNED_INTEGER_ZZ STRING_ZZ STRING_ZZ  @>

@ \<statement> $\longrightarrow$ \.{UNDELETE\_ZZ} \.{RESPONSE\_ZZ} 
\.{INTEGER\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.08.15.}

\LOG
\initials{LDF 2013.08.15.}
Added this rule.

\initials{LDF 2013.08.19.}
Added \.{UNSIGNED\_INTEGER\_ZZ} (option counter).
\ENDLOG

@<Rules@>=

@=statement: UNDELETE_ZZ RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: UNDELETE_ZZ RESPONSE_ZZ INTEGER_ZZ "
             << "UNSIGNED_INTEGER_ZZ STRING_ZZ STRING_ZZ'."
             << endl
             << "`INTEGER_ZZ' (response code) == " << @=$3@>
             << endl
             << "`UNSIGNED_INTEGER_ZZ' (option counter) == " << @=$4@>
             << endl
             << "`STRING_ZZ' (filename) == " << @=$5@>
             << endl
             << "`STRING_ZZ' (message) == " << @=$6@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "Undelete response -->" 
         << endl
         << "Response code:         " << @=$3@>
         << endl
         << "iRODS object name(s):  " << @=$5@>
         << endl;

    if (@=$3@> == 0)
    {
         if (@=$4@> & 1U)
            cout << "iRODS object(s) undeleted from archive"
                 << endl;

         if (@=$4@> & 2U)
            cout << "iRODS object(s) undeleted from `gwirdsif' database"
                 << endl;
    }

    else 
    {
         if (@=$4@> & 1U)
            cout << "Failed to undelete iRODS object(s) from archive"
                 << endl;

         if (@=$4@> & 2U)
            cout << "Failed to undelete iRODS object(s) from `gwirdsif' database"
                 << endl;
    }

    cout << "Message:               " << @=$6@>
         << endl
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex();

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement: DELETE_ZZ METADATA_ZZ RESPONSE_ZZ INTEGER_ZZ  @>
@q **** (4) STRING_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ                  @>

@ \<statement> $\longrightarrow$ \.{DELETE\_ZZ} \.{METADATA\_ZZ} 
\.{RESPONSE\_ZZ} \.{INTEGER\_ZZ} \.{STRING\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ}. \.{STRING\_ZZ}.
\initials{LDF 2013.10.31.}

\LOG
\initials{LDF 2013.10.31.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DELETE_ZZ METADATA_ZZ RESPONSE_ZZ INTEGER_ZZ @>
@=STRING_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DELETE_ZZ METADATA_ZZ RESPONSE_ZZ "
             << "INTEGER_ZZ STRING_ZZ "
             << "UNSIGNED_INTEGER_ZZ STRING_ZZ':"
             << endl
             << "`INTEGER_ZZ' (Response code)                    == " << @=$4@>
             << endl 
             << "`STRING_ZZ' (filename (iRODS object path)       == " << @=$5@>
             << endl 
             << "`UNSIGNED_INTEGER_ZZ' (options)                 == " << @=$6@>
             << endl 
             << "`STRING_ZZ' (Message)                           == " << @=$7@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    string temp_str = gwstrerror(@=$4@>, true);

    if (!temp_str.empty())
    {
       temp_str.insert(0, " (");
       temp_str += ")";
    }
 
    bitset<8> b(@=$6@>);

    lock_cerr_mutex(); 
    lock_cout_mutex(); 
    cout << "Delete metadata value response -->" 
         << endl
         << "Response code:                " << @=$4@>
         << temp_str
         << endl 
         << "Filename (iRODS object path): " << @=$5@>
         << endl
         << "Options:                      " << dec << @=$6@> << " (" << b << ")"
         << endl 
         << "Message:                      " << @=$7@>
         << endl << endl;
    unlock_cout_mutex(); 
    unlock_cerr_mutex(); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement: UNDELETE_ZZ METADATA_ZZ RESPONSE_ZZ INTEGER_ZZ  @>
@q **** (4) STRING_ZZ STRING_ZZ                                        @>

@ \<statement> $\longrightarrow$ \.{UNDELETE\_ZZ} \.{METADATA\_ZZ} 
\.{RESPONSE\_ZZ} \.{INTEGER\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.11.21.}

\LOG
\initials{LDF 2013.11.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: UNDELETE_ZZ METADATA_ZZ RESPONSE_ZZ INTEGER_ZZ @>
@=STRING_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: UNDELETE_ZZ METADATA_ZZ RESPONSE_ZZ "
             << "INTEGER_ZZ STRING_ZZ "
             << "STRING_ZZ':"
             << endl
             << "`INTEGER_ZZ' (Response code)              == " << @=$4@>
             << endl 
             << "`STRING_ZZ' (filename (iRODS object path) == " << @=$5@>
             << endl 
             << "`STRING_ZZ' (Message)                     == " << @=$6@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    string temp_str = gwstrerror(@=$4@>, true);

    if (!temp_str.empty())
    {
       temp_str.insert(0, " (");
       temp_str += ")";
    }
 
    lock_cerr_mutex(); 
    lock_cout_mutex(); 
    cout << "Undelete metadata value response -->" 
         << endl
         << "Response code:                " << @=$4@>
         << temp_str
         << endl 
         << "Filename (iRODS object path): " << @=$5@>
         << endl
         << "Message:                      " << @=$6@>
         << endl << endl;
    unlock_cout_mutex(); 
    unlock_cerr_mutex(); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};
@q **** (4) statement --> FETCH_ZZ METADATA_ZZ RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ @>
@q **** (4)               STRING_ZZ dublin_core_metadata_list                             @>

@ \<statement> $\longrightarrow$ \.{FETCH\_ZZ} \.{METADATA\_ZZ} \.{RESPONSE\_ZZ}
\.{INTEGER\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ} \.{STRING\_ZZ} \<dublin core metadata list>.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement: FETCH_ZZ METADATA_ZZ RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ @>
@=STRING_ZZ dublin_core_metadata_list @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

    vector<Dublin_Core_Metadata_Type> *dc_metadata_vector 
       = static_cast<vector<Dublin_Core_Metadata_Type>*>(@=$7@>);

@q ***** (5) @>

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule"
             << endl 
             << "`statement: FETCH_ZZ METADATA_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ "
             << "dublin_core_metadata_list':"
             << endl
             << "`INTEGER_ZZ'          ($4) (Response code) == " << @=$4@>
             << endl 
             << "`UNSIGNED_INTEGER_ZZ' ($5) (Options)       == " << @=$5@>
             << endl 
             << "`STRING'              ($6) (Message)       == " << @=$6@>
             << endl
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "Fetch metadata response -->" 
         << endl
         << "Response code number:  " << @=$4@>
         << endl
         << "Options:               " << @=$5@>
         << endl
         << "Message:               " << @=$6@>
         << endl
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex();

     if (dc_metadata_vector == 0 || dc_metadata_vector->size() == 0)
     {
         lock_cerr_mutex(); 
         cerr << "WARNING!  Failed to retrieve Dublin Core metadata from server."
              << endl 
              << "Will try to continue."
              << endl;
         unlock_cerr_mutex(); 

         ++param->warnings_occurred; 

     }

@q ***** (5) @>

     else
     {
@q ****** (6) @>

        lock_cout_mutex();
        lock_cerr_mutex(); 

         if (@=$5@> & 16U)  /* Show  */
         {

             cout << "dc_metadata_vector->size() == " << dc_metadata_vector->size() << endl;

             for (vector<Dublin_Core_Metadata_Type>::iterator iter = dc_metadata_vector->begin();
                  iter != dc_metadata_vector->end();
                  ++iter)
             {
                 iter->show("", true, &cout);

             }

         }   /* |if (@=$5@> & 16U)| Show  */
         else
            cout << "Not showing."
                 << endl;

        unlock_cerr_mutex(); 
        unlock_cout_mutex();


@q ****** (6) @>

         if (@=$5@> & 32U)  /* Store  */
         {
@q ******* (7) @>

             lock_cout_mutex();
             lock_cerr_mutex(); 
             cout << "dc_metadata_vector->size() == " << dc_metadata_vector->size() << endl
                  << "Storing."
                  << endl;
             unlock_cerr_mutex(); 
             unlock_cout_mutex();

@q ******* (7) @>

             for (vector<Dublin_Core_Metadata_Type>::iterator iter = dc_metadata_vector->begin();
                  iter != dc_metadata_vector->end();
                  ++iter)
             {
@q ******** (8) @>
                
                  status = iter->write_dc_metadata_to_database(param->mysql_ptr,
                                                   iter->irods_object_ref_id,
                                                   true,
                                                   "gwirdcli");


@q ******** (8) @>

                  if (status != 0)
                  {
                     lock_cerr_mutex(); 
                     cerr << "ERROR!  `Dublin_Core_Metadata_Type::write_dc_metadata_to_database' "
                          << "failed, returning " << status << ":"
                          << endl
                          << "Failed to store Dublin Core metadata item in "
                          << "`gwirdcli.Dublin_Core_Metadata' database table."
                          << endl
                          << "Will try to continue."
                          << endl;
                      unlock_cerr_mutex(); 

                      continue;
 
                  }

@q ******** (8) @>

#if DEBUG_COMPILE 
                  else if (param->PARSER_DEBUG)
                  {
                     lock_cerr_mutex(); 
                     cerr << "`Dublin_Core_Metadata_Type::write_dc_metadata_to_database' "
                          << "succeeded, returning 0."
                          << endl
                          << "Stored Dublin Core metadata item in "
                          << "`gwirdcli.Dublin_Core_Metadata' database table successfully."
                          << endl;
                     unlock_cerr_mutex(); 

                  }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

             }  /* |for|  */

@q ******* (7) @>

         }   /* |if (@=$5@> & 32U)| Store  */
         else
         {

            lock_cout_mutex();
            lock_cerr_mutex();

            cout << "Not storing."
                 << endl;

            unlock_cerr_mutex(); 
            unlock_cout_mutex();
         }

@q ****** (6) @>

     }  /* |else|  */

@q ***** (5) @>

    delete dc_metadata_vector;
    dc_metadata_vector = 0;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q **** (4) @>
@ \<dublin core metadata list> and \<dublin core metadata item>.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added these type declarations.
\ENDLOG

@<Token and type declarations@>=

%type<pointer_value> dublin_core_metadata_list
%type<pointer_value> dublin_core_metadata_item
%type<pointer_value> dublin_core_metadata_sub_list
%type<pointer_value> dublin_core_metadata_sub_item
%type<pointer_value> dublin_core_metadata_sub_attribute_list

@q ***** (5) dublin_core_metadata_list: /* Empty  */ @>
@ \<dublin core metadata list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=dublin_core_metadata_list: /* Empty  */@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`dublin_core_metadata_list: /* Empty  */'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    @=$$@> = static_cast<void*>(new vector<Dublin_Core_Metadata_Type>); 


@q ***** (5) @>

};

@q ***** (5) dublin_core_metadata_list: dublin_core_metadata_list dublin_core_metadata_item @>
@ \<dublin core metadata list> $\longrightarrow$ \<dublin core metadata list> 
\<dublin core metadata item>.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=dublin_core_metadata_list: dublin_core_metadata_list dublin_core_metadata_item @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`dublin_core_metadata_list: dublin_core_metadata_list dublin_core_metadata_item'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    vector<Dublin_Core_Metadata_Type> *dc_metadata_vector 
       = static_cast<vector<Dublin_Core_Metadata_Type>*>(@=$1@>);

    Dublin_Core_Metadata_Type *dc_metadata 
       = static_cast<Dublin_Core_Metadata_Type*>(@=$2@>);

    dc_metadata_vector->push_back(*dc_metadata);

    delete dc_metadata;
    dc_metadata = 0;

    @=$$@> = static_cast<void*>(dc_metadata_vector); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q ***** (5) dublin_core_metadata_item: DUBLIN_CORE_METADATA_ZZ UNSIGNED_LONG_INTEGER_ZZ ... @>
@ \<dublin core metadata item> $\longrightarrow$ \.{DUBLIN\_CORE\_METADATA\_ZZ} 
\.{UNSIGNED\_LONG\_INTEGER\_ZZ} $\ldots$ \<dublin core metadata sub list>.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=dublin_core_metadata_item: DUBLIN_CORE_METADATA_ZZ UNSIGNED_LONG_INTEGER_ZZ   @>
@=UNSIGNED_LONG_INTEGER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ STRING_ZZ              @>
@=UNSIGNED_LONG_INTEGER_ZZ UNSIGNED_LONG_INTEGER_ZZ UNSIGNED_LONG_INTEGER_ZZ    @>
@=STRING_ZZ UNSIGNED_LONG_INTEGER_ZZ STRING_ZZ UNSIGNED_LONG_INTEGER_ZZ         @>
@=INTEGER_ZZ INTEGER_ZZ STRING_ZZ UNSIGNED_LONG_INTEGER_ZZ                      @>
@=dublin_core_metadata_sub_list                                                 @>
{

@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`dublin_core_metadata_item: DUBLIN_CORE_METADATA_ZZ "
             << "UNSIGNED_LONG_INTEGER_ZZ"
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ" 
             << endl 
             << "UNSIGNED_INTEGER_ZZ" 
             << endl 
             << "STRING_ZZ"
             << endl 
             << "STRING_ZZ"     
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ" 
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ" 
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ"
             << endl 
             << "STRING_ZZ" 
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ" 
             << endl 
             << "STRING_ZZ" 
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ"
             << endl 
             << "INTEGER_ZZ"
             << endl 
             << "INTEGER_ZZ" 
             << endl 
             << "STRING_ZZ" 
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ"
             << endl
             << endl;

        cerr << "UNSIGNED_LONG_INTEGER_ZZ  (2) `id'                                 == " << @=$2@>
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ  (3) `user_id'                            == " << @=$3@>
             << endl 
             << "UNSIGNED_INTEGER_ZZ       (4) `irods_server_id'                    == " << @=$4@> 
             << endl 
             << "STRING_ZZ                 (5) `irods_object_path'                  == " << @=$5@> 
             << endl 
             << "STRING_ZZ                 (6) `dc_metadata_irods_object_path'      == " << @=$6@>
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ  (7) `handle_id'                          == " << @=$7@> 
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ  (8) `irods_object_ref_id'                == " << @=$8@> 
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ  (9) `irods_object_self_id'               == " << @=$9@>
             << endl 
             << "STRING_ZZ                (10) `created_str'                        == " << @=$10@>
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ (11) `created'                            == " << @=$11@>
             << endl 
             << "STRING_ZZ                (12) `last_modified_str'                  == " << @=$12@>
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ (13) `last_modified'                      == " << @=$13@>
             << endl 
             << "INTEGER_ZZ               (14) `marked_for_deletion'                == " << @=$14@>
             << endl 
             << "INTEGER_ZZ               (15) `delete_file'                        == " << @=$15@>
             << endl 
             << "STRING_ZZ                (16) `delete_from_database_timestamp_str' == " << @=$16@>
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ (17) `delete_from_database_timestamp'     == " << @=$17@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Dublin_Core_Metadata_Type *dc_metadata = new Dublin_Core_Metadata_Type;
    
    dc_metadata->set(@=$2@>, @=$3@>, @=$4@>, @=$5@>, @=$6@>, @=$7@>, @=$8@>, @=$9@>,
                     @=$10@>, @=$11@>, @=$12@>, @=$13@>, @=$14@>, @=$15@>, @=$16@>, @=$17@>);


    multimap<unsigned int, Dublin_Core_Metadata_Sub_Type>* sub_map_ptr 
       = static_cast<multimap<unsigned int, Dublin_Core_Metadata_Sub_Type>*>(@=$18@>);

    if (sub_map_ptr != 0)
    {
        dc_metadata->metadata_sub_map = *sub_map_ptr;        

        delete sub_map_ptr;
        sub_map_ptr = 0;

    }  /* |if (sub_map_ptr != 0)|  */
    
    @=$$@> = static_cast<void*>(dc_metadata); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};


@q ***** (5) dublin_core_metadata_sub_list: /* Empty  */ @>
@ \<dublin core metadata sub list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2013.12.16.}

\LOG
\initials{LDF 2013.12.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=dublin_core_metadata_sub_list: /* Empty  */@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`dublin_core_metadata_sub_list: /* Empty  */'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    @=$$@> = static_cast<void*>(new multimap<unsigned int, Dublin_Core_Metadata_Sub_Type>); 

@q ***** (5) @>

};

@q ***** (5) dublin_core_metadata_sub_list: dublin_core_metadata_sub_list @>
@q ***** (5) dublin_core_metadata_sub_item                                @>

@ \<dublin core metadata sub list> $\longrightarrow$ \<dublin core metadata sub list>
\<dublin core metadata sub item>.
\initials{LDF 2013.12.16.}

\LOG
\initials{LDF 2013.12.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=dublin_core_metadata_sub_list: dublin_core_metadata_sub_list dublin_core_metadata_sub_item @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`dublin_core_metadata_sub_list: dublin_core_metadata_sub_list "
             << "dublin_core_metadata_sub_item'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    multimap<unsigned int, Dublin_Core_Metadata_Sub_Type>* map_ptr = 
       static_cast<multimap<unsigned int, Dublin_Core_Metadata_Sub_Type>*>(@=$1@>);

    Dublin_Core_Metadata_Sub_Type *dc_sub_ptr = 
       static_cast<Dublin_Core_Metadata_Sub_Type *>(@=$2@>); 
    
    unsigned int temp_val = 0U;

@q ***** (5) @>

    if (dc_sub_ptr != 0)
    {
        temp_val = dc_sub_ptr->element_id;

        if (temp_val == 0)
           temp_val = dc_sub_ptr->term_id;

        if (temp_val > 0)
           map_ptr->insert(make_pair(temp_val, *dc_sub_ptr));

        delete dc_sub_ptr;
        dc_sub_ptr = 0;

    }  /* |if (dc_sub_ptr != 0)|  */
    
@q ***** (5) @>

    @=$$@> = static_cast<void*>(map_ptr);

    @=$1@> = 0;
    @=$2@> = 0;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q ***** (5) dublin_core_metadata_sub_item: DUBLIN_CORE_METADATA_SUB_ZZ ... @>

@ \<dublin core metadata sub item> $\longrightarrow$ \.{DUBLIN\_CORE\_METADATA\_SUB\_ZZ}
\.{UNSIGNED\_LONG\_INTEGER\_ZZ} \.{UNSIGNED\_LONG\_INTEGER\_ZZ}
\.{UNSIGNED\_INTEGER\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ} \.{UNSIGNED\_INTEGER\_ZZ}
\.{STRING\_ZZ} \<dublin core metadata sub attribute list>.
\initials{LDF 2013.12.16.}

\LOG
\initials{LDF 2013.12.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=dublin_core_metadata_sub_item: DUBLIN_CORE_METADATA_SUB_ZZ UNSIGNED_LONG_INTEGER_ZZ  @>
@=UNSIGNED_LONG_INTEGER_ZZ UNSIGNED_INTEGER_ZZ UNSIGNED_INTEGER_ZZ UNSIGNED_INTEGER_ZZ @> 
@=STRING_ZZ dublin_core_metadata_sub_attribute_list                                    @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

@q ***** (5) @>

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `zzparse', rule "
             << "`dublin_core_metadata_sub_item': DUBLIN_CORE_METADATA_SUB_ZZ"
             << "UNSIGNED_LONG_INTEGER_ZZ "
             << "UNSIGNED_LONG_INTEGER_ZZ"
             << endl 
             << "UNSIGNED_INTEGER_ZZ "
             << "UNSIGNED_INTEGER_ZZ "
             << "UNSIGNED_INTEGER_ZZ "
             << "STRING_ZZ'"
             << endl 
             << "dublin_core_metadata_sub_attribute_list'."
             << endl
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ (2) `id'           == " << @=$2@> 
             << endl 
             << "UNSIGNED_LONG_INTEGER_ZZ (3) `metadata_id'  == " << @=$3@> 
             << endl 
             << "UNSIGNED_INTEGER_ZZ      (4) `element_id'   == " << @=$4@> 
             << endl 
             << "UNSIGNED_INTEGER_ZZ      (5) `qualifier_id' == " << @=$5@> 
             << endl 
             << "UNSIGNED_INTEGER_ZZ      (6) `term_id'      == " << @=$6@> 
             << endl 
             << "STRING_ZZ                (7) `value'        == " << @=$7@> 
             << endl
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>

     Dublin_Core_Metadata_Sub_Type *dcm_sub = new Dublin_Core_Metadata_Sub_Type;

@q ***** (5) @>

    multimap<string, string> *map_ptr = static_cast<multimap<string, string>*>(@=$8@>); 

    if (map_ptr->size() > 0)
    {
@q ****** (6) @>

#if DEBUG_COMPILE
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "`map_ptr->size()' == " << map_ptr->size()
                 << endl;
            unlock_cerr_mutex(); 

        }  /*|if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>
    }

@q ***** (5) @>

#if DEBUG_COMPILE 
    else if (param->PARSER_DEBUG)
    {
            cerr << "`map_ptr->size()' == 0."
                 << endl;
    }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    status = dcm_sub->set(@=$2@>, 
                          @=$3@>, 
                          @=$4@>, 
                          @=$5@>, 
                          @=$6@>, 
                          string(@=$7@>), 
                          static_cast<multimap<string, string>*>(@=$8@>));

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] ERROR!  In `zzparse', rule "
             << "`dublin_core_metadata_sub_item': DUBLIN_CORE_METADATA_SUB_ZZ"
             << "UNSIGNED_LONG_INTEGER_ZZ "
             << "UNSIGNED_LONG_INTEGER_ZZ"
             << endl 
             << "UNSIGNED_INTEGER_ZZ "
             << "UNSIGNED_INTEGER_ZZ "
             << "UNSIGNED_INTEGER_ZZ "
             << "STRING_ZZ':"
             << endl 
             << "`Dublin_Core_Metadata_Sub_Type::set' failed, returning " << status << ":"
             << endl 
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        delete dcm_sub; 
        dcm_sub = 0;

        delete map_ptr;
        map_ptr = 0;

        ++param->errors_occurred;

        @=$$@> = 0;

    }  /* |if (status != 0)|  */

@q ***** (5) @>

    else
    {

        @=$$@> = static_cast<void*>(dcm_sub); 

    }

@q ***** (5) @>

    @=$8@> = 0; 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q dublin_core_metadata_sub_attribute_list: /* Empty  */ @>
@ \<dublin core metadata sub attribute list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2013.12.17.}

\LOG
\initials{LDF 2013.12.17.}
Added this rule.
\ENDLOG

@<Rules@>=

@=dublin_core_metadata_sub_attribute_list: /* Empty  */ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`dublin_core_metadata_sub_attribute_list: /* Empty  */'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = static_cast<void*>(new multimap<string, string>);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q dublin_core_metadata_sub_attribute_list: dublin_core_metadata_sub_attribute_list  @>
@q STRING_ZZ STRING_ZZ                                                               @>

@ \<dublin core metadata sub attribute list> $\longrightarrow$ 
\<dublin core metadata sub attribute list> \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.12.17.}

\LOG
\initials{LDF 2013.12.17.}
Added this rule.
\ENDLOG

@<Rules@>=

@=dublin_core_metadata_sub_attribute_list: dublin_core_metadata_sub_attribute_list @>
@=STRING_ZZ STRING_ZZ                                                              @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`dublin_core_metadata_sub_attribute_list: "
             << "dublin_core_metadata_sub_attribute_list "
             << "STRING_ZZ STRING_ZZ'"
             << endl
             << endl
             << "`STRING_ZZ' (2) `attribute' == " << @=$2@>
             << endl 
             << "`STRING_ZZ' (3) `value'     == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    multimap<string, string> *map_ptr = static_cast<multimap<string, string>*>(@=$1@>);

    map_ptr->insert(make_pair(@=$2@>, @=$3@>));

    @=$1@> = 0;

    @=$$@> = static_cast<void*>(map_ptr);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> CHECKSUM_ZZ RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ @>
@q **** (4)               STRING_ZZ STRING_ZZ STRING_ZZ                          @>

@ \<statement> $\longrightarrow$ \.{CHECKSUM\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ}
\.{UNSIGNED\_INTEGER\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2013.12.24.}

\LOG
\initials{LDF 2013.12.24.}
Added this rule.  
\ENDLOG

@<Rules@>=

@=statement: CHECKSUM_ZZ RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: CHECKSUM_ZZ RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ "
             << "STRING_ZZ STRING_ZZ STRING_ZZ'."
             << endl
             << "`INTEGER_ZZ'          (3) (Response code) == " << @=$3@> << " " 
             << "(" << gwstrerror(@=$3@>) << ")"
             << endl 
             << "`UNSIGNED_INTEGER_ZZ' (4) (Options)       == " << @=$4@>
             << endl 
             << "`STRING_ZZ'           (5) (Filename)      == " << @=$5@>
             << endl 
             << "`STRING_ZZ'           (6) (Checksum)      == " << @=$6@>
             << endl 
             << "`STRING_ZZ'           (7) (Message)       == " << @=$7@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    string checksum_type_str;

    if (@=$4@> & 32U)
       checksum_type_str = "SHA512";
    else if (@=$4@> & 16U)
       checksum_type_str = "SHA384";
    else if (@=$4@> & 8U)
       checksum_type_str = "SHA256";
    else if (@=$4@> & 4U)
       checksum_type_str = "SHA224";
    else if (@=$4@> & 2U)
       checksum_type_str = "SHA1";
    else
       checksum_type_str = "MD5";


    lock_cout_mutex(); 
    lock_cerr_mutex(); 
    cout << "Checksum response -->" 
         << endl
         << "Response code:  " << @=$3@> << " (" << gwstrerror(@=$3@>) << ")"
         << endl
         << "Options:        " << @=$4@>
         << endl
         << "Filename:       " << @=$5@>
         << endl
         << "Checksum:       " << @=$6@>
         << endl
         << "Checksum type:  " << checksum_type_str
         << endl
         << "Message:        " << @=$7@>
         << endl
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex(); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> VERIFY_ZZ CHECKSUM_ZZ RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ @>
@q **** (4)               STRING_ZZ STRING_ZZ STRING_ZZ STRING_ZZ                          @>

@ \<statement> $\longrightarrow$ \.{VERIFY\_ZZ} \.{CHECKSUM\_ZZ} \.{RESPONSE\_ZZ} \.{INTEGER\_ZZ}
\.{UNSIGNED\_INTEGER\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2014.01.03.}

\LOG
\initials{LDF 2014.01.03.}
Added this rule.  
\ENDLOG

@<Rules@>=

@=statement: VERIFY_ZZ CHECKSUM_ZZ RESPONSE_ZZ INTEGER_ZZ @>
@=UNSIGNED_INTEGER_ZZ STRING_ZZ STRING_ZZ STRING_ZZ STRING_ZZ@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: VERIFY_ZZ CHECKSUM_ZZ RESPONSE_ZZ INTEGER_ZZ UNSIGNED_INTEGER_ZZ "
             << "STRING_ZZ STRING_ZZ STRING_ZZ STRING_ZZ'."
             << endl
             << "`INTEGER_ZZ'          (4) (Response code)                     == " << @=$4@> 
             << " (" << gwstrerror(@=$4@>) << ")"
             << endl 
             << "`UNSIGNED_INTEGER_ZZ' (5) (Options)                           == " << @=$5@>
             << endl 
             << "`STRING_ZZ'           (6) (Filename)                          == " << @=$6@>
             << endl 
             << "`STRING_ZZ'           (7) (Checksum 1, sent by client)        == " << @=$7@>
             << endl 
             << "`STRING_ZZ'           (8) (Checksum 2, retrieved from server) == " << @=$8@>
             << endl 
             << "`STRING_ZZ'           (9) (Message)                           == " << @=$9@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    string checksum_type_str;

    if (@=$5@> & 32U)
       checksum_type_str = "SHA512";
    else if (@=$5@> & 16U)
       checksum_type_str = "SHA384";
    else if (@=$5@> & 8U)
       checksum_type_str = "SHA256";
    else if (@=$5@> & 4U)
       checksum_type_str = "SHA224";
    else if (@=$5@> & 2U)
       checksum_type_str = "SHA1";
    else
       checksum_type_str = "MD5";


    lock_cout_mutex(); 
    lock_cerr_mutex(); 
    cout << "Verify checksum response -->" 
         << endl
         << "Response code:                       " << @=$4@> 
         << " (" << gwstrerror(@=$4@>) << ")"
         << endl
         << "Options:                             " << @=$5@>
         << endl
         << "Filename:                            " << @=$6@>          
         << endl
         << "Checksum 1 (sent by client):         " << @=$7@>
         << endl
         << "Checksum 2 (retrieved from server):  " << @=$8@>
         << endl
         << "Checksum type:                       " << checksum_type_str
         << endl
         << "Message:                             " << @=$9@>          
         << endl
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex(); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) statement: SEND_ZZ PUBLIC_KEY_ZZ INTEGER_ZZ STRING_ZZ UNSIGNED_INTEGER_ZZ @>

@ \<statement> $\longrightarrow$ \.{SEND\_ZZ} \.{PUBLIC\_KEY\_ZZ} \.{INTEGER\_ZZ} \.{STRING\_ZZ} 
\.{UNSIGNED\_INTEGER\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2014.01.21.}

\LOG
\initials{LDF 2014.01.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SEND_ZZ PUBLIC_KEY_ZZ INTEGER_ZZ STRING_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ@>
{
@q ****** (6) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `zzparse', rule `statement: SEND_ZZ PUBLIC_KEY_ZZ "
             << "INTEGER_ZZ STRING_ZZ UNSIGNED_INTEGER_ZZ STRING_ZZ'."
             << endl
             << "`INTEGER_ZZ'          (3) (Response code) == " << @=$3@>
             << endl 
             << "`STRING_ZZ'           (4) (Public key)    == " << @=$4@>
             << endl
             << "`UNSIGNED_INTEGER_ZZ' (5) (Options)       == " << @=$5@> 
             << " == " << oct << @=$5@> << " (octal)" << dec
             << endl
             << "`STRING_ZZ'           (6) (Message)       == " << @=$6@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;
    response.type = Response_Type::SEND_PUBLIC_KEY_TYPE;   

    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 


};

@q **** (4) statement --> STORE_ZZ PUBLIC_KEY_ZZ RESPONSE_ZZ INTEGER_ZZ  @>
@q **** (4)               STRING_ZZ STRING_ZZ                            @>

@ \<statement> $\longrightarrow$ \.{STORE\_ZZ} \.{PUBLIC\_KEY\_ZZ} \.{RESPONSE\_ZZ} 
\.{INTEGER\_ZZ} \.{STRING\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2014.01.22.}

\LOG
\initials{LDF 2014.01.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: STORE_ZZ PUBLIC_KEY_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: STORE_ZZ PUBLIC_KEY_ZZ RESPONSE_ZZ INTEGER_ZZ "
             << "STRING_ZZ STRING_ZZ':"
             << endl
             << "`INTEGER_ZZ' (4) (Status code) == " << @=$4@> 
             << " (" << gwstrerror(@=$4@>) << ")"
             << endl 
             << "`STRING_ZZ'  (5) (Fingerprint) == " << @=$5@>
             << endl 
             << "`STRING_ZZ'  (6) (Message)     == " << @=$6@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "Store public key response -->" 
         << endl 
         << "Response code:  " << @=$4@> 
         << " (" << gwstrerror(@=$4@>) << ")"
         << endl 
         << "Fingerprint:    " << @=$5@> 
         << endl
         << "Message:        " << @=$6@>;

     if (strlen(@=$6@>) == 0)
        cout << "(None)";

    cout << endl << endl;

    unlock_cerr_mutex(); 
    unlock_cout_mutex();

    if (@=$4@> == GW_ERROR || @=$4@> == GW_SERVER_SIDE_DATABASE_ERROR)
       ++param->errors_occurred; 
    else if (@=$4@> == GW_WARNING)
       ++param->warnings_occurred; 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> REGISTER_ZZ PULL_ZZ RESPONSE_ZZ STRING_ZZ @>

@ \<statement> $\longrightarrow$ \.{REGISTER\_ZZ} \.{PULL\_ZZ} 
\.{INTEGER\_ZZ} \.{STRING\_ZZ}.
\initials{LDF 2014.01.31.}

\LOG
\initials{LDF 2014.01.31.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: REGISTER_ZZ PULL_ZZ RESPONSE_ZZ INTEGER_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: REGISTER_ZZ PULL_ZZ INTEGER_ZZ STRING_ZZ'."
             << endl
             << "`INTEGER_ZZ' (4) (Response code):  " << @=$4@> 
             << " (" << gwstrerror(@=$4@>) << ")"
             << endl
             << "`STRING_ZZ'  (5) (Message):        " << @=$5@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex(); 
    lock_cerr_mutex(); 
    cout << "Register pull response -->"
         << endl 
         << "Response code:  " << @=$4@> << " (" << gwstrerror(@=$4@>) << ")"
         << endl
         << "Message:        " << @=$5@>
         << endl;
    unlock_cout_mutex(); 
    unlock_cerr_mutex(); 

    if (@=$4@> == GW_ERROR)
    {
       ++param->errors_occurred; 
    }
    else if (@=$4@> == GW_WARNING)
    {
       ++param->warnings_occurred; 
    }

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};



@q **** (4) statement --> DUMMY_STATEMENT_ZZ INTEGER_ZZ @>

@ \<statement> $\longrightarrow$ \.{DUMMY\_STATEMENT\_ZZ} \.{INTEGER\_ZZ}.
\initials{LDF 2013.04.05.}

\LOG
\initials{LDF 2013.04.05.}
Added this rule.  It's used for testing.
\ENDLOG

@<Rules@>=

@=statement: DUMMY_STATEMENT_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DUMMY_STATEMENT_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER_ZZ' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "Dummy statement -->" 
         << endl
         << "Code number:  " << @=$2@>
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex();


    Response_Type response;

    response.type = Response_Type::COMMAND_ONLY_TYPE;

    temp_strm.str("");

    temp_strm << "DUMMY_STATEMENT RESPONSE " << @=$2@>;

    response.command = temp_strm.str();

    param->response_deque.push_back(response);

    temp_strm.str("");

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> DUMMY_STATEMENT_ZZ RESPONSE_ZZ INTEGER_ZZ @>

@ \<statement> $\longrightarrow$ \.{DUMMY\_STATEMENT\_ZZ} \.{RESPONSE\_ZZ} 
\.{INTEGER\_ZZ}.
\initials{LDF 2013.04.19.}

\LOG
\initials{LDF 2013.04.19.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DUMMY_STATEMENT_ZZ RESPONSE_ZZ INTEGER_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DUMMY_STATEMENT_ZZ RESPONSE_ZZ INTEGER_ZZ'."
             << endl
             << "`INTEGER_ZZ' == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "Dummy statement response -->" 
         << endl
         << "Response code:  " << @=$3@>
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex();

    Response_Type response;

    response.type = Response_Type::COMMAND_ONLY_TYPE;

    temp_strm.str("");

    temp_strm << "DUMMY_STATEMENT RESPONSE " << @=$3@>;

    response.command = temp_strm.str();

    param->response_deque.push_back(response);

    temp_strm.str("");

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> DUMMY_STATEMENT_ZZ RESPONSE_ZZ STRING_ZZ @>

@ \<statement> $\longrightarrow$ \.{DUMMY\_STATEMENT\_ZZ} \.{RESPONSE\_ZZ} 
\.{STRING\_ZZ}.
\initials{LDF 2013.08.19.}

\LOG
\initials{LDF 2013.08.19.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DUMMY_STATEMENT_ZZ RESPONSE_ZZ STRING_ZZ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(zzget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DUMMY_STATEMENT_ZZ RESPONSE_ZZ STRING_ZZ'."
             << endl
             << "`STRING_ZZ' == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex();
    lock_cerr_mutex(); 
    cout << "Dummy statement response -->" 
         << endl
         << "Response string:" 
         << endl 
         << @=$3@>
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex();

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) @>

@q *** (3) @>

@q ** (2) @>

@
@<Garbage@>=
/* Empty  */

@q ** (2) @>

@ Putting parser together.
@c
@=%{@>
@<Include files@>@;@/
using namespace std;
using namespace gwrdifpk;
static stringstream temp_strm;
static int status;
static char buffer[BUFFER_SIZE];
@<Declarations of additional functions@>@;@/
#if 0 
@<Garbage@>@;@/
#endif 
@=%}@>
@<Options@>@;@/
@<|union| declaration@>@;@/
@<Token and type declarations@>@;@/
@=%%@>
@q Rules @>
@<Rules@>@;@/

@q ** (2) @>

@q * (1) Emacs-Lisp code for use in indirect buffers  @>

@q (progn (cweb-mode) (outline-minor-mode) (setq abbrev-mode t)        @>

@q * (1) Local variables for Emacs @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q abbrev-mode:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>

