@q dcmtdttp.web  @>
@q Created by Laurence D. Finston (LDF) Thu Dec  6 16:06:23 CET 2012 @>

@q * (1) Copyright and License.@>

@q This file is part of gwrdifpk, a package for long-term archiving.  @>
@q Copyright (C) 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021 Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen @>

@q gwrdifpk is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q gwrdifpk is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License          @>
@q along with gwrdifpk; if not, write to the Free Software                    @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q gwrdifpk is available for downloading via Git from @>
@q https://github.com/gwdg/gwrdifpk.git    @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de@>

@q Laurence D. Finston                                                   @>
@q Kreuzbergring 41         					         @>
@q 37075 Goettingen              					 @>
@q Germany                           					 @>                                

@q Laurence.Finston@@gmx.de (@@ stands for a single "at" sign.)@>



@q ** (2)  dcmtdttp.web  @>
@* {\bf class Dublin\_Core\_Metadata\_Type}.

\LOG
\initials{LDF 2012.12.06.}
Added this file.
\ENDLOG

@q ** (2) Include files  @>

@ Include files.

@<Include files@>=
#include <stdlib.h>  /* Standard Library for C  */
#include <stdio.h>
#include <string.h>

#include <limits.h>
#include <errno.h>


#include <expat.h>

#include <fstream> /* Standard Template Library (STL) for C++  */
#include <iomanip>
#include <ios>
#include <iostream>

#include <bitset>

#include <map>
#include <vector>
#include <stack>

#include <string>

#if 0 
#include <time.h>
#include <math.h>
#endif 

#include <sstream>  

#include <pthread.h>  /* POSIX threads  */

#include <mysql.h>

#if HAVE_CONFIG_H
#include <config.h>
#endif 

#include "glblcnst.h++"
#include "glblvrbl.h++"
#include "utilfncs.h++"
#include "parser.h++"
#include "scanner.h++"
#include "hndlvltp.h++"
#include "rspnstp.h++"
#include "rspercds.h++"
#include "dcmdsbtp.h++"

@q ** (2) Preprocessor macro definitions.  @>

@ Preprocessor macro definitions.
\initials{LDF 2012.12.14.}

\LOG
\initials{LDF 2013.03.14.}
Removed the definition of |BUFFSIZE|.
\ENDLOG 

@<Preprocessor macro definitions@>=

#ifdef XML_LARGE_SIZE
#if defined(XML_USE_MSC_EXTENSIONS) && _MSC_VER < 1400
#define XML_FMT_INT_MOD "I64"
#else
#define XML_FMT_INT_MOD "ll"
#endif
#else
#define XML_FMT_INT_MOD "l"
#endif

@q ** (2) @>
@
\LOG
\initials{LDF 2013.03.14.}
Removed the declaration of |static char Buff|.
\ENDLOG 
@<File-local variables@>=

static int Depth;

static stringstream last_value;


@q ** (2) |class Dublin_Core_Metadata_Type|. @>
@ {\bf class Dublin\_Core\_Metadata\_Type}.
\initials{LDF 2012.12.06.}

\LOG
\initials{LDF 2012.12.06.}
Added this type declaration.

\initials{LDF 2013.11.22.}
Added the following data members:\hfil\break 
|unsigned int irods_server_id|,
|string created_str|,
|time_t created|,
|string last_modified_str|,
|time_t last_modified|,
|bool marked_for_deletion|,
|int delete_file|,
|string delete_from_database_timestamp_str|
and
|time_t delete_from_database_timestamp|.

\initials{LDF 2013.11.25.}
Added |friend| declaration for |purge_dc_metadata|.

\initials{LDF 2013.11.25.}
Added |unsigned long int irods_object_ref_id| and 
|unsigned long int irods_object_self_id|.
\ENDLOG

@q *** (3) Declaration  @>

@<|class Dublin_Core_Metadata_Type| declaration@>=

class Dublin_Core_Metadata_Type
{
   friend int yyparse(yyscan_t parameter);
                               
   friend class Scan_Parse_Parameter_Type;

   friend int exchange_data_with_server(Scan_Parse_Parameter_Type&);
   friend int exchange_data_with_client(Scan_Parse_Parameter_Type&);

   friend void* purge_dc_metadata(void *v);

   private:

   unsigned long int id;     
   unsigned int user_id;
   unsigned int irods_server_id;
   string irods_object_path;
   string dc_metadata_irods_object_path;
   unsigned long int handle_id;

   unsigned long int irods_object_ref_id;
   unsigned long int irods_object_self_id;

   string created_str;
   time_t created;
   string last_modified_str;
   time_t last_modified;
   bool marked_for_deletion;
   int delete_file;
   string delete_from_database_timestamp_str;
   time_t delete_from_database_timestamp;

   multimap<unsigned int, Dublin_Core_Metadata_Sub_Type> metadata_sub_map;

   stack<Dublin_Core_Metadata_Sub_Type> metadata_sub_stack;

   public:

   static map<unsigned int, string> element_map;
   static map<string, unsigned int> element_ctr_map;

   static map<unsigned int, string> qualifier_map;
   static map<string, unsigned int> qualifier_ctr_map;

   static const unsigned int DUBLIN_CORE_NULL_TYPE;
   static const unsigned int DUBLIN_CORE_ELEMENT_TYPE;
   static const unsigned int DUBLIN_CORE_QUALIFIER_TYPE;
   static const unsigned int DUBLIN_CORE_ATTRIBUTE_TYPE;

   static const unsigned int DUBLIN_CORE_NULL_ELEMENT;
   static const unsigned int DUBLIN_CORE_TITLE_ELEMENT;
   static const unsigned int DUBLIN_CORE_CREATOR_ELEMENT;
   static const unsigned int DUBLIN_CORE_SUBJECT_ELEMENT;
   static const unsigned int DUBLIN_CORE_DESCRIPTION_ELEMENT;
   static const unsigned int DUBLIN_CORE_PUBLISHER_ELEMENT;
   static const unsigned int DUBLIN_CORE_CONTRIBUTOR_ELEMENT;
   static const unsigned int DUBLIN_CORE_DATE_ELEMENT;
   static const unsigned int DUBLIN_CORE_TYPE_ELEMENT;
   static const unsigned int DUBLIN_CORE_FORMAT_ELEMENT;
   static const unsigned int DUBLIN_CORE_IDENTIFIER_ELEMENT;
   static const unsigned int DUBLIN_CORE_SOURCE_ELEMENT;
   static const unsigned int DUBLIN_CORE_LANGUAGE_ELEMENT;
   static const unsigned int DUBLIN_CORE_RELATION_ELEMENT;
   static const unsigned int DUBLIN_CORE_COVERAGE_ELEMENT;
   static const unsigned int DUBLIN_CORE_RIGHTS_ELEMENT;

   static const unsigned int DUBLIN_CORE_NULL_TERM;
   static const unsigned int DUBLIN_CORE_ABSTRACT_TERM;
   static const unsigned int DUBLIN_CORE_ACCESSRIGHTS_TERM;
   static const unsigned int DUBLIN_CORE_ACCRUALMETHOD_TERM;
   static const unsigned int DUBLIN_CORE_ACCRUALPERIODICITY_TERM;
   static const unsigned int DUBLIN_CORE_ACCRUALPOLICY_TERM;
   static const unsigned int DUBLIN_CORE_ALTERNATIVE_TERM;
   static const unsigned int DUBLIN_CORE_AUDIENCE_TERM;
   static const unsigned int DUBLIN_CORE_AVAILABLE_TERM;
   static const unsigned int DUBLIN_CORE_BIBLIOGRAPHICCITATION_TERM;
   static const unsigned int DUBLIN_CORE_CONFORMSTO_TERM;
   static const unsigned int DUBLIN_CORE_CONTRIBUTOR_TERM;
   static const unsigned int DUBLIN_CORE_COVERAGE_TERM;
   static const unsigned int DUBLIN_CORE_CREATED_TERM;
   static const unsigned int DUBLIN_CORE_CREATOR_TERM;
   static const unsigned int DUBLIN_CORE_DATE_TERM;
   static const unsigned int DUBLIN_CORE_DATEACCEPTED_TERM;
   static const unsigned int DUBLIN_CORE_DATECOPYRIGHTED_TERM;
   static const unsigned int DUBLIN_CORE_DATESUBMITTED_TERM;
   static const unsigned int DUBLIN_CORE_DESCRIPTION_TERM;
   static const unsigned int DUBLIN_CORE_EDUCATIONLEVEL_TERM;
   static const unsigned int DUBLIN_CORE_EXTENT_TERM;
   static const unsigned int DUBLIN_CORE_FORMAT_TERM;
   static const unsigned int DUBLIN_CORE_HASFORMAT_TERM;
   static const unsigned int DUBLIN_CORE_HASPART_TERM;
   static const unsigned int DUBLIN_CORE_HASVERSION_TERM;
   static const unsigned int DUBLIN_CORE_IDENTIFIER_TERM;
   static const unsigned int DUBLIN_CORE_INSTRUCTIONALMETHOD_TERM;
   static const unsigned int DUBLIN_CORE_ISFORMATOF_TERM;
   static const unsigned int DUBLIN_CORE_ISPARTOF_TERM;
   static const unsigned int DUBLIN_CORE_ISREFERENCEDBY_TERM;
   static const unsigned int DUBLIN_CORE_ISREPLACEDBY_TERM;
   static const unsigned int DUBLIN_CORE_ISREQUIREDBY_TERM;
   static const unsigned int DUBLIN_CORE_ISSUED_TERM;
   static const unsigned int DUBLIN_CORE_ISVERSIONOF_TERM;
   static const unsigned int DUBLIN_CORE_LANGUAGE_TERM;
   static const unsigned int DUBLIN_CORE_LICENSE_TERM;
   static const unsigned int DUBLIN_CORE_MEDIATOR_TERM;
   static const unsigned int DUBLIN_CORE_MEDIUM_TERM;
   static const unsigned int DUBLIN_CORE_MODIFIED_TERM;
   static const unsigned int DUBLIN_CORE_PROVENANCE_TERM;
   static const unsigned int DUBLIN_CORE_PUBLISHER_TERM;
   static const unsigned int DUBLIN_CORE_REFERENCES_TERM;
   static const unsigned int DUBLIN_CORE_RELATION_TERM;
   static const unsigned int DUBLIN_CORE_REPLACES_TERM;
   static const unsigned int DUBLIN_CORE_REQUIRES_TERM;
   static const unsigned int DUBLIN_CORE_RIGHTS_TERM;
   static const unsigned int DUBLIN_CORE_RIGHTSHOLDER_TERM;
   static const unsigned int DUBLIN_CORE_SOURCE_TERM;
   static const unsigned int DUBLIN_CORE_SPATIAL_TERM;
   static const unsigned int DUBLIN_CORE_SUBJECT_TERM;
   static const unsigned int DUBLIN_CORE_TABLEOFCONTENTS_TERM;
   static const unsigned int DUBLIN_CORE_TEMPORAL_TERM;
   static const unsigned int DUBLIN_CORE_TITLE_TERM;
   static const unsigned int DUBLIN_CORE_TYPE_TERM;
   static const unsigned int DUBLIN_CORE_VALID_TERM;

   @<|Dublin_Core_Metadata_Type| function declarations@>@;


};


@q **** (4) @>
@
\LOG
\initials{LDF 2012.12.12.}
Added this section.
\ENDLOG
@<Initialize |static| |Dublin_Core_Metadata_Type| data members@>=

   map<unsigned int, string> Dublin_Core_Metadata_Type::element_map;
   map<string, unsigned int> Dublin_Core_Metadata_Type::element_ctr_map;

   map<unsigned int, string> Dublin_Core_Metadata_Type::qualifier_map;
   map<string, unsigned int> Dublin_Core_Metadata_Type::qualifier_ctr_map;

   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_NULL_TYPE      = 0;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ELEMENT_TYPE   = 1;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_QUALIFIER_TYPE = 2;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ATTRIBUTE_TYPE = 3;

   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_NULL_ELEMENT                 =   0;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_TITLE_ELEMENT                =   1;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_CREATOR_ELEMENT              =   2;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_SUBJECT_ELEMENT              =   3;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_DESCRIPTION_ELEMENT          =   4;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_PUBLISHER_ELEMENT            =   5;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_CONTRIBUTOR_ELEMENT          =   6;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_DATE_ELEMENT                 =   7;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_TYPE_ELEMENT                 =   8;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_FORMAT_ELEMENT               =   9;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_IDENTIFIER_ELEMENT           =  10;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_SOURCE_ELEMENT               =  11;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_LANGUAGE_ELEMENT             =  12;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_RELATION_ELEMENT             =  13;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_COVERAGE_ELEMENT             =  14;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_RIGHTS_ELEMENT               =  15; 

   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_NULL_TERM                    = 100; 
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ABSTRACT_TERM                = 101;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ACCESSRIGHTS_TERM            = 102;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ACCRUALMETHOD_TERM           = 103;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ACCRUALPERIODICITY_TERM      = 104;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ACCRUALPOLICY_TERM           = 105;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ALTERNATIVE_TERM             = 106;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_AUDIENCE_TERM                = 107;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_AVAILABLE_TERM               = 108;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_BIBLIOGRAPHICCITATION_TERM   = 109;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_CONFORMSTO_TERM              = 110;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_CONTRIBUTOR_TERM             = 111;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_COVERAGE_TERM                = 112;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_CREATED_TERM                 = 113;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_CREATOR_TERM                 = 114;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_DATE_TERM                    = 115;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_DATEACCEPTED_TERM            = 116;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_DATECOPYRIGHTED_TERM         = 117;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_DATESUBMITTED_TERM           = 118;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_DESCRIPTION_TERM             = 119;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_EDUCATIONLEVEL_TERM          = 120;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_EXTENT_TERM                  = 121;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_FORMAT_TERM                  = 122;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_HASFORMAT_TERM               = 123;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_HASPART_TERM                 = 124;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_HASVERSION_TERM              = 125;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_IDENTIFIER_TERM              = 126;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_INSTRUCTIONALMETHOD_TERM     = 127;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ISFORMATOF_TERM              = 128;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ISPARTOF_TERM                = 129;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ISREFERENCEDBY_TERM          = 130;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ISREPLACEDBY_TERM            = 131;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ISREQUIREDBY_TERM            = 132;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ISSUED_TERM                  = 133;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_ISVERSIONOF_TERM             = 134;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_LANGUAGE_TERM                = 135;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_LICENSE_TERM                 = 136;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_MEDIATOR_TERM                = 137;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_MEDIUM_TERM                  = 138;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_MODIFIED_TERM                = 139;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_PROVENANCE_TERM              = 140;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_PUBLISHER_TERM               = 141;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_REFERENCES_TERM              = 142;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_RELATION_TERM                = 143;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_REPLACES_TERM                = 144;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_REQUIRES_TERM                = 145;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_RIGHTS_TERM                  = 146;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_RIGHTSHOLDER_TERM            = 147;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_SOURCE_TERM                  = 148;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_SPATIAL_TERM                 = 149;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_SUBJECT_TERM                 = 150; 
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_TABLEOFCONTENTS_TERM         = 151;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_TEMPORAL_TERM                = 152;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_TITLE_TERM                   = 153;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_TYPE_TERM                    = 154;
   const unsigned int Dublin_Core_Metadata_Type::DUBLIN_CORE_VALID_TERM                   = 155;
                                                                                          
@q **** (4) Default constructor.  @>                                                      
@ Default constructor.                                                                    
\initials{LDF 2012.12.06.}

@q ***** (5) Declaration  @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
Dublin_Core_Metadata_Type(void);

@q ***** (5) Definition  @>
@
@<|Dublin_Core_Metadata_Type| constructor definition@>=

Dublin_Core_Metadata_Type::Dublin_Core_Metadata_Type(void)
{

   id = user_id = irods_server_id = handle_id = delete_file = 0;

   irods_object_ref_id = irods_object_self_id = 0UL;

   created = last_modified = delete_from_database_timestamp 
      = static_cast<time_t>(0);

   marked_for_deletion = false;

   return;
}
@q **** (4) Set.  @>
@ Set (|set|).
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this function.
\ENDLOG

@q ***** (5) Declaration @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
int
set(unsigned long int iid = 0UL,
    unsigned long int uuser_id = 0UL,
    unsigned int iirods_server_id = 0U,
    string iirods_object_path = "",
    string ddc_metadata_irods_object_path = "",
    unsigned long int hhandle_id = 0UL,
    unsigned long int iirods_object_ref_id = 0UL,
    unsigned long int iirods_object_self_id = 0UL,
    string ccreated_str = "",         
    time_t ccreated = static_cast<time_t>(0),
    string llast_modified_str = "",
    time_t llast_modified = static_cast<time_t>(0),
    bool mmarked_for_deletion = false,
    int ddelete_file = 0,
    string ddelete_from_database_timestamp_str = "",
    time_t ddelete_from_database_timestamp = static_cast<time_t>(0),
    string thread_str = "");

@q ***** (5) Definition  @>
@
@<|Dublin_Core_Metadata_Type::set| definition@>=
int
Dublin_Core_Metadata_Type::set(unsigned long int iid,
                               unsigned long int uuser_id,
                               unsigned int iirods_server_id,
                               string iirods_object_path,
                               string ddc_metadata_irods_object_path,
                               unsigned long int hhandle_id,
                               unsigned long int iirods_object_ref_id,
                               unsigned long int iirods_object_self_id,
                               string ccreated_str,
                               time_t ccreated,
                               string llast_modified_str,
                               time_t llast_modified,
                               bool mmarked_for_deletion,
                               int ddelete_file,
                               string ddelete_from_database_timestamp_str,
                               time_t ddelete_from_database_timestamp,
                               string thread_str)
{
@q ****** (6) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Dublin_Core_Metadata_Type::set'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

   clear();

   id                                 = iid;
   user_id                            = uuser_id;
   irods_server_id                    = iirods_server_id;
   irods_object_path                  = iirods_object_path;
   dc_metadata_irods_object_path      = ddc_metadata_irods_object_path;
   handle_id                          = hhandle_id;
   irods_object_ref_id                = iirods_object_ref_id;
   irods_object_self_id               = iirods_object_self_id;
   created_str                        = ccreated_str;
   created                            = ccreated;
   last_modified_str                  = llast_modified_str;
   last_modified                      = llast_modified;
   marked_for_deletion                = mmarked_for_deletion;
   delete_file                        = ddelete_file;
   delete_from_database_timestamp_str = ddelete_from_database_timestamp_str;
   delete_from_database_timestamp     = ddelete_from_database_timestamp;

@q ****** (6) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Dublin_Core_Metadata_Type::set':"
            << endl;

       show();

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   
@q ****** (6) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Exiting `Dublin_Core_Metadata_Type::set' successfully with "
            << "return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 



   return 0;

}  /* End of |Dublin_Core_Metadata_Type::set| definition  */


@q **** (4) Destructor.  @>
@ Destructor.
\initials{LDF 2012.12.06.}

\LOG
\initials{LDF 2012.12.06.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
~Dublin_Core_Metadata_Type(void);

@q ***** (5) Definition  @>
@
@<|Dublin_Core_Metadata_Type| destructor definition@>=

Dublin_Core_Metadata_Type::~Dublin_Core_Metadata_Type(void)
{

   return;
}

@q **** (4) Clear.  @>
@ Clear.
\initials{LDF 2012.12.06.}

\LOG
\initials{LDF 2012.12.06.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
void
clear(void);

@q ***** (5) Definition  @>
@
@<|Dublin_Core_Metadata_Type::clear| definition@>=
void
Dublin_Core_Metadata_Type::clear(void)
{

   id = handle_id = 0UL;     
   user_id = irods_server_id = 0U;

   irods_object_ref_id = irods_object_self_id = 0UL;

   delete_file = 0;

   irods_object_path = dc_metadata_irods_object_path = created_str = last_modified_str 
      = delete_from_database_timestamp_str = "";

   created = last_modified = delete_from_database_timestamp = static_cast<time_t>(0); 

   marked_for_deletion = false;

   metadata_sub_map.clear();

   while (!metadata_sub_stack.empty())
      metadata_sub_stack.pop();

   return;

} /* |Dublin_Core_Metadata_Type::clear|  */

@q **** (4) Equality operator.  @>
@ Equality operator.
\initials{LDF 2012.12.21.}

\LOG
\initials{LDF 2012.12.21.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
bool
operator==(const Dublin_Core_Metadata_Type& d) const;

@q ***** (5) Definition  @>
@
@<|Dublin_Core_Metadata_Type::operator==| definition@>=

bool
Dublin_Core_Metadata_Type::operator==(const Dublin_Core_Metadata_Type& d) const
{

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG, 0, 0);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `Dublin_Core_Metadata_Type::operator=='."
            << endl
            << "user_id   == " << user_id << endl
            << "d.user_id == " << d.user_id << endl
            << "irods_object_path   == " << irods_object_path << endl
            << "dc_metadata_irods_object_path   == " << dc_metadata_irods_object_path << endl
            << "d.irods_object_path == " << d.irods_object_path << endl
            << "d.dc_metadata_irods_object_path == " << d.dc_metadata_irods_object_path << endl
            << "metadata_sub_map.size()   == " << metadata_sub_map.size() << endl
            << "d.metadata_sub_map.size() == " << d.metadata_sub_map.size() 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */    

    if (!(   user_id == d.user_id && irods_object_path == d.irods_object_path
          && dc_metadata_irods_object_path == d.dc_metadata_irods_object_path
          && metadata_sub_map.size() == d.metadata_sub_map.size()))
    {

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
             cerr << "Returning false."  << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        return false;

    }

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Will check maps." << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


    multimap<unsigned int, Dublin_Core_Metadata_Sub_Type>::const_iterator iter
       = metadata_sub_map.begin();

    multimap<unsigned int, Dublin_Core_Metadata_Sub_Type>::const_iterator iter_1
       = d.metadata_sub_map.begin();

    for (; iter != metadata_sub_map.end() && iter_1 != d.metadata_sub_map.end();
         ++iter, ++iter_1)
    {

         if (iter->second != iter_1->second)
         {
#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << "Subtype objects don't match:"
                      << endl
                      << "`iter->second' == " << endl;

                 iter->second.show();


                 cerr << endl 
                      << "`iter_1->second' == " << endl;

                 iter_1->second.show();

                 cerr << endl 
                      << "Returning false." << endl;

                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

             return false;
         }

#if DEBUG_COMPILE
         else if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "Subtype objects match.  Continuing." << endl;
             unlock_cerr_mutex(); 

         }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    }  /* |for|  */

    return true;

}  /* End of |Dublin_Core_Metadata_Type::operator==| definition  */


@q **** (4) Show.  @>
@ Show.
\initials{LDF 2012.12.06.}

\LOG
\initials{LDF 2012.12.06.}
Added this function.

\initials{LDF 2013.12.19.}
Added optional argument |show_sub_map = true|.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
int
show(string s = "", bool show_sub_map = true, ostream *out_strm = &cerr) const;

@q ***** (5) Definition  @>
@
@<|Dublin_Core_Metadata_Type::show| definition@>=
int
Dublin_Core_Metadata_Type::show(string s, bool show_sub_map, ostream *out_strm) const
{

   if (s.size() == 0)
      s = "Dublin_Core_Metadata_Type:";

   *out_strm << s 
            << endl
            << "id                                 == " << id      
            << endl 
            << "user_id                            == " << user_id
            << endl
            << "irods_server_id                    == " << irods_server_id
            << endl
            << "irods_object_path                  == " << irods_object_path
            << endl
            << "dc_metadata_irods_object_path      == " << dc_metadata_irods_object_path
            << endl
            << "handle_id                          == " << handle_id
            << endl
            << "created_str                        == " << created_str
            << endl
            << "created                            == " << created
            << endl
            << "last_modified_str                  == " << last_modified_str
            << endl
            << "last_modified                      == " << last_modified
            << endl
            << "marked_for_deletion                == " << marked_for_deletion
            << endl
            << "delete_file                        == " << delete_file
            << endl
            << "delete_from_database_timestamp_str == " << delete_from_database_timestamp_str
            << endl
            << "delete_from_database_timestamp     == " << delete_from_database_timestamp
            << endl 
            << "irods_object_ref_id                == " << irods_object_ref_id
            << endl 
            << "irods_object_self_id               == " << irods_object_self_id
            << endl;

   if (metadata_sub_map.size() == 0)
      *out_strm << "metadata_sub_map is empty." << endl;
   else
   {
       if (show_sub_map)
       {
           *out_strm << "metadata_sub_map:" << endl;

           for (multimap<unsigned int, Dublin_Core_Metadata_Sub_Type>::const_iterator iter 
                   = metadata_sub_map.begin();
                iter != metadata_sub_map.end();
                ++iter)
           {
               iter->second.show();
           }
       }
       else if (metadata_sub_map.size() > 0)
           *out_strm << "metadata_sub_map.size() == " << metadata_sub_map.size() << " "
                     << "(Not showing)"; 
    
   }

   *out_strm << endl;

   return 0;

} /* |Dublin_Core_Metadata_Type::show|  */

@q **** (4) Initialize maps.  @>
@ Initialize maps.
\initials{LDF 2012.12.06.}

\LOG
\initials{LDF 2012.12.06.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
static
int
initialize_maps(void);

@q ***** (5) Definition  @>
@
@<|Dublin_Core_Metadata_Type::initialize_maps| definition@>=
int
Dublin_Core_Metadata_Type::initialize_maps(void)
{

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `Dublin_Core_Metadata_Type::initialize_maps'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   element_map[0]  = "NULL_DUBLIN_CORE_ELEMENT";
   element_map[1]  = "title";
   element_map[2]  = "creator";
   element_map[3]  = "subject";
   element_map[4]  = "description";
   element_map[5]  = "publisher";
   element_map[6]  = "contributor";
   element_map[7]  = "date";
   element_map[8]  = "type";
   element_map[9]  = "format";
   element_map[10] = "identifier";
   element_map[11] = "source";
   element_map[12] = "language";
   element_map[13] = "relation";
   element_map[14] = "coverage";
   element_map[15] = "rights";


   element_ctr_map["NULL_DUBLIN_CORE_ELEMENT"]  = 0;
   element_ctr_map["title"]                     = 1;
   element_ctr_map["creator"]                   = 2;
   element_ctr_map["subject"]                   = 3;
   element_ctr_map["description"]               = 4;
   element_ctr_map["publisher"]                 = 5;
   element_ctr_map["contributor"]               = 6;
   element_ctr_map["date"]                      = 7;
   element_ctr_map["type"]                      = 8;
   element_ctr_map["format"]                    = 9;
   element_ctr_map["identifier"]                = 10;
   element_ctr_map["source"]                    = 11;
   element_ctr_map["language"]                  = 12;
   element_ctr_map["relation"]                  = 13;
   element_ctr_map["coverage"]                  = 14;            
   element_ctr_map["rights"]                    = 15;



   qualifier_map[0]  = qualifier_map[100]  = "NULL_DUBLIN_CORE_TERM";
   qualifier_map[1]  = qualifier_map[101]  = "abstract";
   qualifier_map[2]  = qualifier_map[102]  = "accessRights";
   qualifier_map[3]  = qualifier_map[103]  = "accrualMethod";
   qualifier_map[4]  = qualifier_map[104]  = "accrualPeriodicity";
   qualifier_map[5]  = qualifier_map[105]  = "accrualPolicy";
   qualifier_map[6]  = qualifier_map[106]  = "alternative";
   qualifier_map[7]  = qualifier_map[107]  = "audience";
   qualifier_map[8]  = qualifier_map[108]  = "available";
   qualifier_map[9]  = qualifier_map[109]  = "bibliographicCitation";
   qualifier_map[10] = qualifier_map[110]  = "conformsTo";
   qualifier_map[11] = qualifier_map[111]  = "contributor";
   qualifier_map[12] = qualifier_map[112]  = "coverage";
   qualifier_map[13] = qualifier_map[113]  = "created";
   qualifier_map[14] = qualifier_map[114]  = "creator";
   qualifier_map[15] = qualifier_map[115]  = "date";
   qualifier_map[16] = qualifier_map[116]  = "dateAccepted";
   qualifier_map[17] = qualifier_map[117]  = "dateCopyrighted";
   qualifier_map[18] = qualifier_map[118]  = "dateSubmitted";
   qualifier_map[19] = qualifier_map[119]  = "description";
   qualifier_map[20] = qualifier_map[120]  = "educationLevel";
   qualifier_map[21] = qualifier_map[121]  = "extent";
   qualifier_map[22] = qualifier_map[122]  = "format";
   qualifier_map[23] = qualifier_map[123]  = "hasFormat";
   qualifier_map[24] = qualifier_map[124]  = "hasPart";
   qualifier_map[25] = qualifier_map[125]  = "hasVersion";
   qualifier_map[26] = qualifier_map[126]  = "identifier";
   qualifier_map[27] = qualifier_map[127]  = "instructionalMethod";
   qualifier_map[28] = qualifier_map[128]  = "isFormatOf";
   qualifier_map[29] = qualifier_map[129]  = "isPartOf";
   qualifier_map[30] = qualifier_map[130]  = "isReferencedBy";
   qualifier_map[31] = qualifier_map[131]  = "isReplacedBy";
   qualifier_map[32] = qualifier_map[132]  = "isRequiredBy";
   qualifier_map[33] = qualifier_map[133]  = "issued";
   qualifier_map[34] = qualifier_map[134]  = "isVersionOf";
   qualifier_map[35] = qualifier_map[135]  = "language";
   qualifier_map[36] = qualifier_map[136]  = "license";
   qualifier_map[37] = qualifier_map[137]  = "mediator";
   qualifier_map[38] = qualifier_map[138]  = "medium";
   qualifier_map[39] = qualifier_map[139]  = "modified";
   qualifier_map[40] = qualifier_map[140]  = "provenance";
   qualifier_map[41] = qualifier_map[141]  = "publisher";
   qualifier_map[42] = qualifier_map[142]  = "references";
   qualifier_map[43] = qualifier_map[143]  = "relation";
   qualifier_map[44] = qualifier_map[144]  = "replaces";
   qualifier_map[45] = qualifier_map[145]  = "requires";
   qualifier_map[46] = qualifier_map[146]  = "rights";
   qualifier_map[47] = qualifier_map[147]  = "rightsHolder";
   qualifier_map[48] = qualifier_map[148]  = "source";
   qualifier_map[49] = qualifier_map[149]  = "spatial";
   qualifier_map[50] = qualifier_map[150]  = "subject";
   qualifier_map[51] = qualifier_map[151]  = "tableOfContents";
   qualifier_map[52] = qualifier_map[152]  = "temporal";
   qualifier_map[53] = qualifier_map[153]  = "title";
   qualifier_map[54] = qualifier_map[154]  = "type";
   qualifier_map[55] = qualifier_map[155]  = "valid";

   qualifier_ctr_map["NULL_DUBLIN_CORE_TERM"]   =  0;
   qualifier_ctr_map["abstract"]                =  1;
   qualifier_ctr_map["accessRights"]            =  2;
   qualifier_ctr_map["accrualMethod"]           =  3;
   qualifier_ctr_map["accrualPeriodicity"]      =  4;
   qualifier_ctr_map["accrualPolicy"]           =  5;
   qualifier_ctr_map["alternative"]             =  6;
   qualifier_ctr_map["audience"]                =  7;
   qualifier_ctr_map["available"]               =  8;
   qualifier_ctr_map["bibliographicCitation"]   =  9;
   qualifier_ctr_map["conformsTo"]              = 10;
   qualifier_ctr_map["contributor"]             = 11;
   qualifier_ctr_map["coverage"]                = 12;
   qualifier_ctr_map["created"]                 = 13;
   qualifier_ctr_map["creator"]                 = 14;
   qualifier_ctr_map["date"]                    = 15;
   qualifier_ctr_map["dateAccepted"]            = 16;
   qualifier_ctr_map["dateCopyrighted"]         = 17;
   qualifier_ctr_map["dateSubmitted"]           = 18;
   qualifier_ctr_map["description"]             = 19;
   qualifier_ctr_map["educationLevel"]          = 20;
   qualifier_ctr_map["extent"]                  = 21;
   qualifier_ctr_map["format"]                  = 22;
   qualifier_ctr_map["hasFormat"]               = 23;
   qualifier_ctr_map["hasPart"]                 = 24;
   qualifier_ctr_map["hasVersion"]              = 25;
   qualifier_ctr_map["identifier"]              = 26;
   qualifier_ctr_map["instructionalMethod"]     = 27;
   qualifier_ctr_map["isFormatOf"]              = 28;
   qualifier_ctr_map["isPartOf"]                = 29;
   qualifier_ctr_map["isReferencedBy"]          = 30;
   qualifier_ctr_map["isReplacedBy"]            = 31;
   qualifier_ctr_map["isRequiredBy"]            = 32;
   qualifier_ctr_map["issued"]                  = 33;
   qualifier_ctr_map["isVersionOf"]             = 34;
   qualifier_ctr_map["language"]                = 35;
   qualifier_ctr_map["license"]                 = 36;
   qualifier_ctr_map["mediator"]                = 37;
   qualifier_ctr_map["medium"]                  = 38;
   qualifier_ctr_map["modified"]                = 39;
   qualifier_ctr_map["provenance"]              = 40;
   qualifier_ctr_map["publisher"]               = 41;
   qualifier_ctr_map["references"]              = 42;
   qualifier_ctr_map["relation"]                = 43;
   qualifier_ctr_map["replaces"]                = 44;
   qualifier_ctr_map["requires"]                = 45;
   qualifier_ctr_map["rights"]                  = 46;
   qualifier_ctr_map["rightsHolder"]            = 47;
   qualifier_ctr_map["source"]                  = 48;
   qualifier_ctr_map["spatial"]                 = 49;
   qualifier_ctr_map["subject"]                 = 50;
   qualifier_ctr_map["tableOfContents"]         = 51;
   qualifier_ctr_map["temporal"]                = 52;
   qualifier_ctr_map["title"]                   = 53;
   qualifier_ctr_map["type"]                    = 54;
   qualifier_ctr_map["valid"]                   = 55;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       stringstream s;

       lock_cerr_mutex(); 

       for (map<unsigned int, string>::const_iterator iter = element_map.begin();
            iter != element_map.end();
            ++iter)
       {
            
            s << iter->first << ":";

            cerr << setw(4) << std::left << s.str() << iter->second << endl;

            s.str("");

       }   

       cerr << endl;

       for (map<unsigned int, string>::const_iterator iter = qualifier_map.begin();
            iter != qualifier_map.end();
            ++iter)
       {
            
            s << iter->first << ":";

            cerr << setw(4) << std::left << s.str() << iter->second << endl;

            s.str("");

       }   


       cerr << "Exiting `Dublin_Core_Metadata_Type::initialize_maps' "
            << "successfully with return value 0."
            << endl;

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


   return 0;

} /* |Dublin_Core_Metadata_Type::initialize_maps|  */

@q **** (4) Output.  @>
@ Output.
\initials{LDF 2012.12.07.}

\LOG
\initials{LDF 2012.12.07.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
int
output(ofstream &out_strm) const;

@q ***** (5) Definition  @>
@
@<|Dublin_Core_Metadata_Type::output| definition@>=
int
Dublin_Core_Metadata_Type::output(ofstream &out_strm) const
{
@q ****** (6) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0);

   stringstream temp_strm;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `Dublin_Core_Metadata_Type::output'."
            << endl
            << "`metadata_sub_map.size()' == " << metadata_sub_map.size()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::output| definition@>=

   if (metadata_sub_map.size() == 0)
   {
       cerr << "WARNING!  In `Dublin_Core_Metadata_Type::output':"
            << endl
            << "`metadata_sub_map.size()' == 0.  No metadata to output."
            << endl
            << "Exiting function unsuccessfully with return value 2."
            << endl;

        return 2;

   }  /* |if (metadata_sub_map.size() == 0)|  */


   out_strm << "<metadata"
            << endl 
            << "  xmlns=\"http://example.org/myapp/\""
            << endl 
            << "  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
            << endl 
            << "  xsi:schemaLocation=\"http://example.org/myapp/ "
            << "http://example.org/myapp/schema.xsd\""
            << endl 
            << "  xmlns:dc=\"http://purl.org/dc/elements/1.1/\""
            << endl 
            << "  xmlns:dcterms=\"http://purl.org/dc/terms/\">"
            << endl << endl;

   for (multimap<unsigned int, Dublin_Core_Metadata_Sub_Type>::const_iterator iter 
           = metadata_sub_map.begin();
        iter != metadata_sub_map.end();
        ++iter)
   {
@q ******* (7) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "`iter->first' == " << iter->first << endl;
           iter->second.show();
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       temp_strm.str("");


       if (iter->second.element_id > 0)
          temp_strm << "  <dc:" << element_map[iter->second.element_id];
       else if (iter->second.qualifier_id > 0)
          temp_strm << "  <dcterms:" << qualifier_map[iter->second.qualifier_id];

       for (multimap<string, string>::const_iterator iter_1 = iter->second.attribute_map.begin();
            iter_1 != iter->second.attribute_map.end();
            ++iter_1)
          temp_strm << " " << iter_1->first << "=\"" << iter_1->second << "\"";

       if (iter->second.element_id > 0)
          temp_strm << ">" << endl;
       else if (iter->second.qualifier_id > 0)
          temp_strm << ">" << endl;


       temp_strm << "    " << iter->second.value << endl;

       if (iter->second.element_id > 0)
          temp_strm << "  </dc:" << element_map[iter->second.element_id] << ">" << endl;
       else if (iter->second.qualifier_id > 0)
          temp_strm << "  </dcterms:" << qualifier_map[iter->second.qualifier_id] << ">"  
                    << endl;
       out_strm << temp_strm.str();
       temp_strm.str("");

@q ******* (7) @>

   }  /* |for|  */
   
   out_strm << "</metadata>" << endl << endl;


@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::output| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Exiting `Dublin_Core_Metadata_Type::output' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   

   return 0;

}  /* End of |Dublin_Core_Metadata_Type::output| definition  */

@q **** (4) Parse.  @>
@ Parse.
\initials{LDF 2012.12.20.}

\LOG
\initials{LDF 2012.12.20.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
int
parse(char *buffer);

@q ***** (5) Definition  @>
@
@<|Dublin_Core_Metadata_Type::parse| definition@>=
int
Dublin_Core_Metadata_Type::parse(char *buffer)
{
@q ****** (6) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0);

   stringstream temp_strm;

   int status;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `Dublin_Core_Metadata_Type::parse'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::parse| definition@>=

  XML_Parser p = XML_ParserCreate(0);

  if (p == 0) 
  {
     cerr << "ERROR!  In `Dublin_Core_Metadata_Type::parse':"
          << endl 
          << "Couldn't allocate memory for parser."
          << endl
          << "Exiting function unsuccessfully with return value 1."
          << endl;
     
     return 1;

  }  /* |if (p == 0) |  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::parse':"
            << endl 
            << "Allocated memory for parser successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


   XML_SetElementHandler(p, start, end);
   XML_SetCharacterDataHandler(p, handle_data);
   XML_SetUserData(p, static_cast<void*>(this));

   status = XML_Parse(p, buffer, strlen(buffer), true);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "`XML_Parse' returned `status' == " << status << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   if (status == 0)
   {
       cerr << "ERROR!  In `Dublin_Core_Metadata_Type::parse':"
            << endl 
            << "`XML_Parse' failed, returning 0."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;

        XML_ParserFree(p);

        return 1;

   }

   else if (status == XML_STATUS_ERROR) 
   {
       lock_cerr_mutex(); 

       string temp_str = "Parse error at line %";
       temp_str += XML_FMT_INT_MOD;
       temp_str += "u:\n%s\n";

       fprintf(stderr, temp_str.c_str(),
               XML_GetCurrentLineNumber(p),
               XML_ErrorString(XML_GetErrorCode(p)));
       unlock_cerr_mutex(); 

       XML_ParserFree(p);

       return 1;
   }

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::parse':"
            << endl 
            << "`XML_Parse' succeeded, returning " << status << "."
            << endl;

       show("*this:");
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::parse| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Exiting `Dublin_Core_Metadata_Type::parse' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   XML_ParserFree(p);
 
   return 0;

}  /* End of |Dublin_Core_Metadata_Type::parse| definition  */


@q *** (3) Start handler (|start|).  @>
@ Start handler (|start|).  
\initials{LDF 2012.12.20.}

\LOG
\initials{LDF 2012.12.20.}
Added this function.
\ENDLOG

@q **** (4) Declaration  @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
static void XMLCALL
start(void *data, const char *el, const char **attr);

@q **** (4) Definition  @>
@
@<|Dublin_Core_Metadata_Type::start| definition@>=

void XMLCALL
Dublin_Core_Metadata_Type::start(void *data, const char *el, const char **attr)
{
@q ***** (5) @>

  bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
 
  static string item;
  static string element;
  static string qualifier;

  static size_t pos;

  static int i;

  static unsigned int element_ctr;
  static unsigned int qualifier_ctr;

  static map<string, unsigned int>::const_iterator iter;

  Dublin_Core_Metadata_Type *dcm = 0;

  static Dublin_Core_Metadata_Sub_Type dcm_sub;

  dcm = static_cast<Dublin_Core_Metadata_Type*>(data);

  dcm_sub.clear();

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `Dublin_Core_Metadata_Type::start'." << endl
            << "Depth == " << Depth << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Element:  " << el << endl;

       for (i = 0; attr[i]; i += 2) 
       {
            cerr << "Attribute:  " << attr[i] << endl << "Value:  " << attr[i + 1] 
                 << endl << endl;
       }  /* |for|  */    

       cerr << endl;

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) Determine whether |item| is an element or a qualifier.  @>

@ Determine whether |item| is an element or a qualifier.  
\initials{LDF 2012.12.20.}

@<|Dublin_Core_Metadata_Type::start| definition@>=

   element = qualifier = "";

   element_ctr = qualifier_ctr = 0;

   item = el;

@q ****** (6) @>

   pos = item.find("dc:");

   if (pos != string::npos)
   {

       element = item.substr(pos + strlen("dc:"));

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "`item' is an element:  " << item << endl
                << "`element' == " << element
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       iter = element_ctr_map.find(element);

       if (iter == element_ctr_map.end())
       {
#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "Element `" << element << "' not found in `element_ctr_map'."
                    << endl
                    << "Ignoring."
                    << endl;

               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           element = "";
           element_ctr = 0;

           goto AFTER_TESTS;

       }
       else
       {
          element_ctr = iter->second;

#if DEBUG_COMPILE
          if (DEBUG)
          {
              lock_cerr_mutex(); 
              cerr << "element_ctr == " << element_ctr << endl
                   << "element_map[" << element_ctr << "] == " 
                   << element_map[element_ctr] << endl;
              unlock_cerr_mutex(); 

          }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


       }  /* |else|  */

       goto AFTER_TESTS;

   }  /* |if|  */

@q ****** (6) @>

   pos = item.find("dcterms:");

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "pos == " << pos << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   if (pos != string::npos)
   {

       qualifier = item.substr(pos + strlen("dcterms:"));

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "`item' is a qualifier:  " << item << endl
                << "`qualifier' == " << qualifier
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       iter = qualifier_ctr_map.find(qualifier);

       if (iter == qualifier_ctr_map.end())
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "Qualifier `" << qualifier << "' not found in `qualifier_ctr_map'."
                    << endl
                    << "Ignoring."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           qualifier = "";
           qualifier_ctr = 0;

           goto AFTER_TESTS;

       }
       else
       {
          qualifier_ctr = iter->second;


#if DEBUG_COMPILE
          if (DEBUG)
          {
              lock_cerr_mutex(); 
              cerr << "qualifier_ctr == " << qualifier_ctr << endl
                   << "qualifier_map[" << qualifier_ctr << "] == " 
                   << qualifier_map[qualifier_ctr] << endl;

              unlock_cerr_mutex(); 

          }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       }  /* |else|  */

       goto AFTER_TESTS;

   }  /* |if|  */

@q ****** (6) @>

@ If namespace not specified, first test whether |item| is an element,
then if it's a qualifier.
\initials{LDF 2012.12.20.}

@<|Dublin_Core_Metadata_Type::start| definition@>=

   iter = element_ctr_map.find(item);

   if (iter != element_ctr_map.end())
   {
#if DEBUG_COMPILE
      if (DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << "`item' == " << item << " found in `element_ctr_map'."
               << endl;
          unlock_cerr_mutex(); 

      }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

      element = item;
      element_ctr = iter->second;

      goto AFTER_TESTS;
      
   }  /* |if|  */
   
@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::start| definition@>=

   iter = qualifier_ctr_map.find(item);

   if (iter != qualifier_ctr_map.end())
   {

#if DEBUG_COMPILE
      if (DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << "`item' == " << item << " found in `qualifier_ctr_map'."
               << endl;
          unlock_cerr_mutex(); 

      }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

      qualifier = item;
      qualifier_ctr = iter->second;

      goto AFTER_TESTS;
      
   }  /* |if|  */
   
AFTER_TESTS:

   if (element_ctr > 0)
   {
       dcm_sub.element_id = element_ctr;
   }   
   else if (qualifier_ctr > 0)
   {
      dcm_sub.qualifier_id = qualifier_ctr;
   }

   if (element_ctr > 0 || qualifier_ctr > 0)
   {

       for (i = 0; attr[i]; i += 2) 
       {
           dcm_sub.attribute_map.insert(make_pair(attr[i], attr[i + 1]));

       }    

   }  /* |if|  */


   dcm->metadata_sub_stack.push(dcm_sub);  /* Always push |dcm_sub| onto the stack
                                              so that the right object is processed
                                              in |Dublin_Core_Metadata_Type::end|.
                                              If |element_id| and |qualifier_id| are 
                                              both 0, it will be ignored.
                                              \initials{LDF 2012.12.20.}  */

@q ***** (5) @>

  Depth++;

  return;

}  /* |Dublin_Core_Metadata_Type::start|  */

@q *** (3) End handler (|end|).  @>
@ End handler (|end|).  
\initials{LDF 2012.12.20.}

\LOG
\initials{LDF 2012.12.20.}
Added this function.
\ENDLOG

@q **** (4) Declaration @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
static void XMLCALL
end(void *data, const char *el);


@q ***** (5) Definition @>
@
@<|Dublin_Core_Metadata_Type::end| definition@>=

void XMLCALL
Dublin_Core_Metadata_Type::end(void *data, const char *el)
{

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   static Dublin_Core_Metadata_Type *dcm = 0;
   static Dublin_Core_Metadata_Sub_Type *dcm_sub = 0;


#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `Dublin_Core_Metadata_Type::end'."
            << endl 
            << "Depth == " << Depth 
            << endl
            << "last_value.str() == `" << last_value.str() << "'" << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


   dcm = static_cast<Dublin_Core_Metadata_Type*>(data);

/* !! TODO:   LDF 2012.12.20.  Add error handling for case that 
   the stack is empty.  
*/

   dcm_sub = &dcm->metadata_sub_stack.top();  

   if (dcm_sub->element_id > 0 || dcm_sub->qualifier_id > 0)
   {
       dcm_sub->value = last_value.str();
       dcm->metadata_sub_map.insert(make_pair(0, *dcm_sub));
   }

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       dcm_sub->show("dcm_sub:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   dcm->metadata_sub_stack.pop();

   last_value.str("");

   Depth--;

@ Currently, this code is never reached, because
the character buffer passed to |XML_Parse| only ever
contains a single complete XML ``metadata'' expression.
That is, it starts and ends with a \.{<metadata>} tag and and
a \.{</metadata>}, respectively.
\par
If this might ever not be the case, I would need to throw (and catch) an exception, because 
|XML_Parse| doesn't test the return value of this function.
\initials{LDF 2012.12.20.}

@<|Dublin_Core_Metadata_Type::end| definition@>=

   if (Depth == 0)                        
   {

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "In `end':  Depth == 0.  Quitting." << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       return;

   }  /* |if (Depth == 0)|  */

@
@<|Dublin_Core_Metadata_Type::end| definition@>=

   return;

}  /* |Dublin_Core_Metadata_Type::end|  */

@q *** (3) Handle data (|handle_data|).  @>
@ Handle data (|handle_data|).
\initials{LDF 2012.12.20.}

\LOG
\initials{LDF 2012.12.20.}
Added this function.
\ENDLOG

@q **** (4) Declaration @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
static 
void
handle_data(void *data, const char *content, int length);

@q **** (4) Definition @>
@
@<|Dublin_Core_Metadata_Type::handle_data| definition@>=

void
Dublin_Core_Metadata_Type::handle_data(void *data, const char *content, int length)
{
@q ***** (5) @>

  bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `handle_data'." << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


    static stringstream temp_strm;
    static char temp_cstr[2048];
    static bool space;
    static int i;

    static string temp_str;

    temp_strm.str("");
    temp_strm.clear();

    memset(temp_cstr, 0, 2048);

    temp_str = "";

    temp_strm.write(content, length);

    memcpy(temp_cstr, content, length);

    space = true;

    i = 0;

    for (;i < strlen(temp_cstr); ++i)
    {
        if (!isspace(temp_cstr[i]))
        {
           space = false;
#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "In `Dublin_Core_Metadata_Type::handle_data':"
                    << endl 
                    << "Non-space character found:  `temp_cstr[" << i << "] == "
                    << temp_cstr[i] << ".  Breaking." << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           break;
        }

    }  /* |for|  */

    if (space)
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "Content is blank.  Exiting `handle_data'." << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       return;

    }  /* |if (space)|  */

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "After loop i == " << i << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    temp_str = temp_cstr;

    if (last_value.str().length() == 0)
       temp_str.erase(0, i);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::handle_data':" 
            << endl
            << "temp_cstr == " << temp_cstr 
            << endl
            << "temp_str  == " << temp_str 
            << endl
            << "length == " << length 
            << endl
            << "content (between single quotes) ==" << endl << "'";
       fwrite(content, 1, length, stderr);
       cerr << "'" << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    last_value << temp_str;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Exiting `handle_data'." << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    return;

@q ***** (5) @>

}  /* End of |Dublin_Core_Metadata_Type::handle_data| definition  */


@q *** (3) Write to database.  @>

@ Write to database.
\initials{LDF 2012.12.14.}

\LOG
\initials{LDF 2012.12.14.}
Added this function.

\initials{LDF 2013.01.09.}
Moved this function from |class Scan_Parse_Parameter_Type| 
to |class Dublin_Core_Metadata_Type|.

\initials{LDF 2013.11.25.}
Added optional argument |unsigned long int irods_object_ref_id = 0UL|.

\initials{LDF 2013.12.18.}
Added optional argument |string database = "gwirdsif"|.
Edited code so this function can be used on the client-side to write to tables in the 
\.{gwirdcli} database.
\ENDLOG

@q **** (4) Declaration @>

@<|Dublin_Core_Metadata_Type| function declarations@>=

int
write_dc_metadata_to_database(MYSQL *mysql_ptr, 
                              unsigned long int irods_object_ref_id = 0UL,
                              bool replace = false,
                              string database = "gwirdsif");

@q **** (4) Definition  @>
@
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

int
Dublin_Core_Metadata_Type::write_dc_metadata_to_database(MYSQL *mysql_ptr, 
                                                         unsigned long int irods_object_ref_id,
                                                         bool replace,
                                                         string database)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   int status;

   stringstream temp_strm;

   MYSQL_RES *result = 0;
   unsigned int row_ctr;
   unsigned int field_ctr;

   long affected_rows;

   MYSQL_ROW curr_row;

   stringstream sql_strm;

   int ret_val = 0;

   bool attributes_found = false;

   string comma_str;
   string comma_str_1;

   stringstream sql_strm_1;

   unsigned long dc_metadata_id;
   unsigned long dc_metadata_sub_id;
   unsigned long save_dc_metadata_id;
   unsigned long save_dc_metadata_sub_id;
   unsigned long temp_val;


#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `Dublin_Core_Metadata_Type::write_dc_metadata_to_database'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

   status = mysql_select_db(mysql_ptr, database.c_str());

   if (status == 0)
   {  

#if DEBUG_COMPILE
        
       if (DEBUG)
       {
          lock_cerr_mutex(); 
          cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':  "
               << "`mysql_select_db succeeded'."
               << endl;
          unlock_cerr_mutex();

       }  /* |if (DEBUG)|  */ 

#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |if (status == 0)| */

   else /* |status != 0| */
   {
      lock_cerr_mutex(); 
      cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':  "  
           << "`mysql_select_db' failed, returning " << status 
           << endl;
      unlock_cerr_mutex();

      return 1;

   }   /* |else| (|status != 0|) */

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

   pthread_mutex_lock(&sql_lock_tables_mutex);

   sql_strm << "lock tables Dublin_Core_Metadata write, Dublin_Core_Metadata_Sub write, "
            << "Dublin_Core_Attributes write ";

   if (is_gwirdsif)
      sql_strm << ", Irods_Objects write, Irods_Objects_Dublin_Core_Metadata write";

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   status = submit_mysql_query(sql_strm.str(), result, mysql_ptr);   

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl
            << "`submit_mysql_query' failed, returning " << status << ":"
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to lock database tables."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        pthread_mutex_unlock(&sql_lock_tables_mutex);

        return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':  Locked "
            << "database tables successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   sql_strm.str("");
   mysql_free_result(result);
   result = 0;

@q ***** (5) @>
@
\LOG
\initials{LDF 2013.12.19.}
Put the following code into the conditional |if (replace == false)|.
\ENDLOG 

@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

   if (replace == false)
   {
@q ****** (6) @>

        sql_strm << "select (select dublin_core_metadata_id from Dublin_Core_Metadata "
                 << "order by dublin_core_metadata_id desc limit 1), "
                 << "(select dublin_core_metadata_sub_id from Dublin_Core_Metadata_Sub "
                 << "order by dublin_core_metadata_sub_id desc limit 1)";

        status = submit_mysql_query(sql_strm.str(), 
                                    result, 
                                    mysql_ptr, 
                                    &row_ctr, 
                                    &field_ctr);                   

        if (status != 0)
        {
            lock_cerr_mutex(); 
            cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                 << endl 
                 << "`submit_mysql_query' failed, returning " 
                 << status << "."
                 << endl
                 << mysql_error(mysql_ptr)
                 << endl 
                 << "Failed to retrieve `Dublin_Core_Metadata.dublin_core_metadata_id' and "
                 << "`Dublin_Core_Metadata_Sub.dublin_core_metadata_sub_id'."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            if (result)
            {
                mysql_free_result(result);
                result = 0;
            }

            ret_val = 1;

            goto UNLOCK_TABLES_AND_EXIT;

        }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                 << endl 
                 << "`submit_mysql_query' succeeded."
                 << endl
                 << "`row_ctr' == " << row_ctr
                 << endl
                 << "`field_ctr' == " << field_ctr
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

        if (row_ctr == 0)
        {
            lock_cerr_mutex(); 
            cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                 << endl 
                 << "`submit_mysql_query' returned 0 rows."
                 << endl
                 << "Failed to retrieve `Dublin_Core_Metadata.dublin_core_metadata_id' and "
                 << "`Dublin_Core_Metadata_Sub.dublin_core_metadata_sub_id'."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            mysql_free_result(result);

            ret_val = 1;

            goto UNLOCK_TABLES_AND_EXIT;

        }  /* |if (row_ctr == 0)|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

        if ((curr_row = mysql_fetch_row(result)) == 0)
        {
            lock_cerr_mutex(); 
            cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                 << endl 
                 << "`mysql_fetch_row' failed:"
                 << endl
                 << mysql_error(mysql_ptr)
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            mysql_free_result(result);

            ret_val = 1;

            goto UNLOCK_TABLES_AND_EXIT;

        }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

#if DEBUG_COMPILE 
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                 << endl 
                 << "`mysql_fetch_row' succeeded."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

        if (curr_row[0] == 0 || strlen(curr_row[0]) == 0)
        {
            lock_cerr_mutex(); 
            cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                 << endl 
                 << "`curr_row[0]' is NULL or empty."
                 << endl 
                 << "Failed to retrieve `Dublin_Core_Metadata.dublin_core_metadata_id'."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            mysql_free_result(result);

            ret_val = 1;

            goto UNLOCK_TABLES_AND_EXIT;

        }  /* |if (curr_row[0] == 0 || strlen(curr_row[0]) == 0)|  */

#if DEBUG_COMPILE 
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':  "
                 << "`curr_row[0]' == " << curr_row[0] << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

        errno = 0;

        temp_val = strtoul(curr_row[0], 0, 10);

        if (temp_val == ULONG_MAX || errno != 0)
        {
            lock_cerr_mutex(); 
            cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                 << endl 
                 << "`strtoul' failed, returning " << temp_val;

            if (temp_val == ULONG_MAX)
                cerr << " (ULONG_MAX)." << endl;
            else
                cerr << "." << endl;

            if (errno != 0)
                cerr << "strtoul error:  " << strerror(errno) << endl;

            cerr << "Failed to retrieve `Dublin_Core_Metadata.dublin_core_metadata_id'."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            mysql_free_result(result);

            ret_val = 1;

            goto UNLOCK_TABLES_AND_EXIT;


        }  /* |if|  */

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "temp_val == " << temp_val << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */    

        dc_metadata_id = temp_val + 1;

        save_dc_metadata_id = dc_metadata_id;


@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

        if (curr_row[1] == 0 || strlen(curr_row[1]) == 0)
        {
            lock_cerr_mutex(); 
            cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                 << endl 
                 << "`curr_row[1]' is NULL or empty."
                 << endl 
                 << "Failed to retrieve `Dublin_Core_Metadata_Sub.dublin_core_metadata_sub_id'."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            mysql_free_result(result);

            ret_val = 1;

            goto UNLOCK_TABLES_AND_EXIT;


        }  /* |if (curr_row[1] == 0 || strlen(curr_row[1]) == 0)|  */

#if DEBUG_COMPILE 
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':  "
                 << "`curr_row[1]' == " << curr_row[1] << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

        errno = 0;
        temp_val = strtoul(curr_row[1], 0, 10);

        if (temp_val == ULONG_MAX || errno != 0)
        {
            lock_cerr_mutex(); 
            cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                 << endl 
                 << "`strtoul' failed, returning " << temp_val;

            if (temp_val == ULONG_MAX)
                cerr << " (ULONG_MAX)." << endl;
            else
                cerr << "." << endl;

            if (errno != 0)
                cerr << "strtoul error:  " << strerror(errno) << endl;

            cerr << "Failed to retrieve `Dublin_Core_Metadata_Sub.dublin_core_metadata_sub_id'."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            mysql_free_result(result);

            ret_val = 1;

            goto UNLOCK_TABLES_AND_EXIT;


        }  /* |if|  */

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "temp_val == " << temp_val << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */    

        dc_metadata_sub_id = temp_val + 1;

        save_dc_metadata_sub_id = dc_metadata_sub_id;

        sql_strm.str("");  
        mysql_free_result(result);
        result = 0;

@q ****** (6) @>
@
\LOG
\initials{LDF 2013.02.28.}
Now setting |id = dc_metadata_id|.

\initials{LDF 2013.11.25.}
Added code for |unsigned long int irods_object_ref_id| to the \.{insert} command, below.
\ENDLOG 

@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

        id = dc_metadata_id;

@q ****** (6) @>

   }  /* |if (replace == false)|  */

@q ***** (5) @>

   else
   {
      dc_metadata_id = id;
   }

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       show("*this (Dublin_Core_Metadata_Type):");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   if (replace == true)
      sql_strm << "replace ";
   else 
      sql_strm << "insert ";

   sql_strm << "into Dublin_Core_Metadata (dublin_core_metadata_id, user_id, "
            << "irods_server_id, irods_object_path, dc_metadata_irods_object_path, "
            << "handle_id, delete_file, delete_from_database_timestamp, "
            << "irods_object_self_id, "
            << "marked_for_deletion, created, last_modified, irods_object_ref_id";


   if (is_gwirdcli)
      sql_strm << ", retrieved_from_server_timestamp";

   sql_strm << ") "
            << "values ("
            << dc_metadata_id << ", " << user_id << ", 1, "
            << "'" << irods_object_path << "', '" << dc_metadata_irods_object_path << "', "
            << handle_id << ", " 
            << delete_file << ", '" << delete_from_database_timestamp_str << "', "
            << irods_object_self_id << ", "
            << marked_for_deletion << ", ";

   if (database == "gwirdcli")
      sql_strm << "'" << created_str << "', '" << last_modified_str << "', ";
   else
      sql_strm << "now(), 0, ";

   sql_strm << irods_object_ref_id;

   if (database == "gwirdcli")  /* \.{retrieved\_from\_server\_timestamp}  */
      sql_strm << ", now()";  

   sql_strm << ")";

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
   
   status = submit_mysql_query(sql_strm.str(), result, mysql_ptr, 0, 0, &affected_rows);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl 
            << "`submit_mysql_query' failed, returning " 
            << status << "."
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to insert (or replace) data into `Dublin_Core_Metadata' table."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
           mysql_free_result(result);
       }


       ret_val = 1;

       goto DELETE_DATABASE_ENTRIES_AND_EXIT;


   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl 
            << "`submit_mysql_query' succeeded."
            << endl
            << "`affected_rows' == " << affected_rows
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   sql_strm.str("");
   mysql_free_result(result);
   result = 0;


@q ***** (5) @>
@
\LOG
\initials{LDF 2013.12.05.}
Added this section.
\ENDLOG

@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

   if (is_gwirdsif)
   {

        sql_strm << "insert into Irods_Objects_Dublin_Core_Metadata "
                 << "(irods_object_id, dublin_core_metadata_id) "
                 << "values ("  << irods_object_ref_id << ", " << dc_metadata_id << ")";

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "sql_strm.str() == " << sql_strm.str() << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
   
        status = submit_mysql_query(sql_strm.str(), result, mysql_ptr, 0, 0, &affected_rows);

        if (status != 0)
        {
            lock_cerr_mutex(); 
            cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                 << endl 
                 << "`submit_mysql_query' failed, returning " 
                 << status << "."
                 << endl
                 << mysql_error(mysql_ptr)
                 << endl 
                 << "Failed to insert data into `Irods_Objects_Dublin_Core_Metadata' table."
                 << endl 
                 << "Will delete database entries and exit function unsuccessfully "
                 << "with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            if (result)
            {
                mysql_free_result(result);
            }

            ret_val = 1;

            goto DELETE_DATABASE_ENTRIES_AND_EXIT;

        }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                 << endl 
                 << "`submit_mysql_query' succeeded."
                 << endl
                 << "`affected_rows' == " << affected_rows
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

        sql_strm.str("");
        mysql_free_result(result);
        result = 0;

   }  /* |if (is_gwirdsif)|  */

@q ***** (5) @>
@
\LOG
\initials{LDF 2013.02.28.}
Now setting |Dublin_Core_Metadata_Sub_Type::metadata_id = dc_metadata_id|
and |Dublin_Core_Metadata_Sub_Type::id = dc_metadata_sub_id|
in all members of |metadata_sub_map|.
\ENDLOG 

@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

   if (is_gwirdcli)
      sql_strm << "replace ";
   else 
      sql_strm << "insert ";

   sql_strm << "into Dublin_Core_Metadata_Sub (dublin_core_metadata_sub_id, "
            << "dublin_core_metadata_id, dublin_core_element_id, dublin_core_term_id, "
            << "value) values ";

   sql_strm_1 << comma_str_1;

   if (is_gwirdcli)
      sql_strm_1 << "replace ";
   else 
      sql_strm_1 << "insert ";

   sql_strm_1 << "into Dublin_Core_Attributes "
              << "(dublin_core_metadata_id, dublin_core_metadata_sub_id, "
              << "attribute, value) values ";

   attributes_found = false;

   for (multimap<unsigned int, Dublin_Core_Metadata_Sub_Type>::iterator iter
           = metadata_sub_map.begin();
        iter != metadata_sub_map.end();
        ++iter)
    {

           if (replace)
           {
               dc_metadata_sub_id = iter->second.id;
           }

           sql_strm << comma_str
                    << "(" << dc_metadata_sub_id << ", " << dc_metadata_id << ", "
                    << iter->second.element_id << ", " << iter->second.qualifier_id << ", "
                    << "'" << iter->second.value << "')";

           comma_str = ", ";

           comma_str_1 = "";

           for (multimap<string, string>::const_iterator iter_1 
                   = iter->second.attribute_map.begin();
                iter_1 != iter->second.attribute_map.end();
                ++iter_1)
           {

               attributes_found = true;

               sql_strm_1 << comma_str_1
                          << "(" << dc_metadata_id << ", " 
                          << dc_metadata_sub_id << ", "
                          << "'" << iter_1->first << "', "
                          << "'" << iter_1->second << "')";

               comma_str_1 = ", ";

           }  /* inner |for|  */

           if (replace == false)
           {
               iter->second.metadata_id = dc_metadata_id;
               iter->second.id          = dc_metadata_sub_id;
               ++dc_metadata_sub_id;
           }           


    }  /* outer |for|  */

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = submit_mysql_query(sql_strm.str(), result, mysql_ptr, 0, 0, &affected_rows);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl 
            << "`submit_mysql_query' failed, returning " 
            << status << "."
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to insert (or replace) data into `Dublin_Core_Metadata_Sub' table."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
           mysql_free_result(result);
       }

       ret_val = 1;

       goto DELETE_DATABASE_ENTRIES_AND_EXIT;


   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl 
            << "`submit_mysql_query' succeeded."
            << endl
            << "`affected_rows' == " << affected_rows
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   mysql_free_result(result);
   result = 0;

   sql_strm.str("");

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm_1.str() == " << sql_strm_1.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = submit_mysql_query(sql_strm_1.str(), result, mysql_ptr, 0, 0, &affected_rows);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl 
            << "`submit_mysql_query' failed, returning " 
            << status << "."
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to insert (or replace) data into `Dublin_Core_Metadata_Sub' table."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
           mysql_free_result(result);
       }

       ret_val = 1;

       goto DELETE_DATABASE_ENTRIES_AND_EXIT;


   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl 
            << "`submit_mysql_query' succeeded."
            << endl
            << "`affected_rows' == " << affected_rows
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   mysql_free_result(result);
   result = 0;

   sql_strm.str("");
   sql_strm_1.str("");

@q ***** (5) @>
@
\LOG
\initials{LDF 2013.11.25.}
Added this section.
\ENDLOG

@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

   if (is_gwirdsif && irods_object_ref_id > 0UL)
   {
       sql_strm << "update Irods_Objects set dublin_core_metadata_id = " 
                << dc_metadata_id << " where irods_object_id = " << irods_object_ref_id;

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "sql_strm.str() == " << sql_strm.str() << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       status = submit_mysql_query(sql_strm.str(), result, mysql_ptr, 0, 0, &affected_rows);

       if (status != 0)
       {
           lock_cerr_mutex(); 
           cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                << endl 
                << "`submit_mysql_query' failed, returning " 
                << status << "."
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Failed to update `" << database << ".Irods_Objects' table."
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           if (result)
           {
               mysql_free_result(result);
           }

           ret_val = 1;

           goto DELETE_DATABASE_ENTRIES_AND_EXIT;


       }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                << endl 
                << "`submit_mysql_query' succeeded."
                << endl
                << "`affected_rows' == " << affected_rows
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

       mysql_free_result(result);
       result = 0;

       sql_strm.str("");

   }  /* |if (is_gwirdsif && irods_object_ref_id > 0UL)|  */

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

   if (ret_val == 0)
       goto UNLOCK_TABLES_AND_EXIT;

DELETE_DATABASE_ENTRIES_AND_EXIT:

   if (result)
   {
       mysql_free_result(result);
       result = 0;
   }

   sql_strm.str("");

   if (replace == false)
   {
       sql_strm << "delete from Dublin_Core_Metadata where dublin_core_metadata_id >= " 
                << save_dc_metadata_id;
   }
   else
   {
       sql_strm << "delete from Dublin_Core_Metadata where dublin_core_metadata_id = "
                << id;
   }

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = submit_mysql_query(sql_strm.str(), result, mysql_ptr, 0, 0, &affected_rows);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl 
            << "`submit_mysql_query' failed, returning " 
            << status << "."
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to delete data from `Dublin_Core_Metadata' table."
            << endl;
       unlock_cerr_mutex(); 

       ret_val = 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl 
            << "`submit_mysql_query' succeeded."
            << endl
            << "`affected_rows' == " << affected_rows
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   mysql_free_result(result);
   result = 0;

@q ****** (6) @>
@
\LOG
\initials{LDF 2013.12.05.}
Added this section.
\ENDLOG

@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

   if (result)
   {
       mysql_free_result(result);
       result = 0;
   }

   sql_strm.str("");

   if (is_gwirdsif)
   {

        sql_strm << "delete from Irods_Objects_Dublin_Core_Metadata "
                 << "where dublin_core_metadata_id >= " 
                 << save_dc_metadata_id;

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "sql_strm.str() == " << sql_strm.str() << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        status = submit_mysql_query(sql_strm.str(), result, mysql_ptr, 0, 0, &affected_rows);

        if (status != 0)
        {
            lock_cerr_mutex(); 
            cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                 << endl 
                 << "`submit_mysql_query' failed, returning " 
                 << status << "."
                 << endl
                 << mysql_error(mysql_ptr)
                 << endl 
                 << "Failed to delete data from `Irods_Objects_Dublin_Core_Metadata' table."
                 << endl;
            unlock_cerr_mutex(); 

            ret_val = 1;

        }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
                 << endl 
                 << "`submit_mysql_query' succeeded."
                 << endl
                 << "`affected_rows' == " << affected_rows
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

        mysql_free_result(result);
        result = 0;

   }  /* |if (is_gwirdsif)|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

   sql_strm.str("");

   if (replace == false)
      sql_strm << "delete from Dublin_Core_Metadata_Sub where dublin_core_metadata_sub_id >= " 
               << save_dc_metadata_sub_id;

   else
      sql_strm << "delete from Dublin_Core_Metadata_Sub where dublin_core_metadata_id = " 
               << id;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = submit_mysql_query(sql_strm.str(), result, mysql_ptr, 0, 0, &affected_rows);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl 
            << "`submit_mysql_query' failed, returning " 
            << status << "."
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to delete data from `Dublin_Core_Metadata_Sub' table."
            << endl;
       unlock_cerr_mutex(); 

       ret_val = 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl 
            << "`submit_mysql_query' succeeded."
            << endl
            << "`affected_rows' == " << affected_rows
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   mysql_free_result(result);
   result = 0;

   sql_strm.str("");

@q ****** (6) @>

   if (replace == false)
      sql_strm << "delete from Dublin_Core_Attributes where dublin_core_metadata_id >= " 
               << save_dc_metadata_id  << " or dublin_core_metadata_sub_id >= " 
               << save_dc_metadata_sub_id;
   else
      sql_strm << "delete from Dublin_Core_Attributes where dublin_core_metadata_id = " 
               << id;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = submit_mysql_query(sql_strm.str(), result, mysql_ptr, 0, 0, &affected_rows);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl 
            << "`submit_mysql_query' failed, returning " 
            << status << "."
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to delete data from `Dublin_Core_Attributes' table."
            << endl;
       unlock_cerr_mutex(); 

       ret_val = 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl 
            << "`submit_mysql_query' succeeded."
            << endl
            << "`affected_rows' == " << affected_rows
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   mysql_free_result(result);
   result = 0;

   sql_strm.str("");

@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=


UNLOCK_TABLES_AND_EXIT:

   if (result)
   {
      mysql_free_result(result);
      result = 0;
   }

   status = submit_mysql_query("unlock tables", result, mysql_ptr, 0, 0, 0);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl
            << "`submit_mysql_query' failed, returning " << status << "."
            << endl
            << "Failed to unlock database tables."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
          mysql_free_result(result);

       pthread_mutex_unlock(&sql_lock_tables_mutex);

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl
            << "`submit_mysql_query' succeeded, returning 0."
            << endl
            << "Unlocked database tables successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   pthread_mutex_unlock(&sql_lock_tables_mutex);

   mysql_free_result(result);
   result = 0;

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

   if (ret_val != 0)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::write_dc_metadata_to_database':"
            << endl
            << "`ret_val' == " << ret_val << " (!= 0)."
            << endl
            << "Exiting function unsuccessfully with return value " << ret_val << "."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
          mysql_free_result(result);

       return ret_val;
          
   }  /* |if (ret_val != 0)|  */


@q ***** (5) @>
@
\LOG
\initials{LDF 2013.02.28.}
Now setting |*dc_metadata_id_ptr = dc_metadata_id| if |dc_metadata_id_ptr| is non-null.
\ENDLOG 
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>=

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Exiting `Dublin_Core_Metadata_Type::write_dc_metadata_to_database' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition  */

@q *** (3) Set handle ID (|set_handle_id|).  @>
@ Set handle ID (|set_handle_id|).
\initials{LDF 2013.02.28.}

\LOG
\initials{LDF 2013.02.28.}
Added this function.
\ENDLOG

@q **** (4) Declaration @>

@<|Dublin_Core_Metadata_Type| function declarations@>=

int
set_handle_id(MYSQL *mysql_ptr, unsigned long int hhandle_id);

@q **** (4) Definition  @>
@
@<|Dublin_Core_Metadata_Type::set_handle_id| definition@>=

int
Dublin_Core_Metadata_Type::set_handle_id(MYSQL *mysql_ptr, 
                                      unsigned long int hhandle_id)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   int status;

   MYSQL_RES *result = 0;
   unsigned int row_ctr;
   unsigned int field_ctr;

   long affected_rows;

   MYSQL_ROW curr_row;

   stringstream sql_strm;

   int ret_val = 0;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `Dublin_Core_Metadata_Type::set_handle_id'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) Lock `gwirdsif.Dublin_Core_Metadata' database table.  @>

@ Lock \.{gwirdsif.Dublin\_Core\_Metadata} database table.  
\initials{LDF 2013.02.28.}

@<|Dublin_Core_Metadata_Type::set_handle_id| definition@>=

   pthread_mutex_lock(&sql_lock_tables_mutex);

   sql_strm << "lock table gwirdsif.Dublin_Core_Metadata write";

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = submit_mysql_query(sql_strm.str(), result, mysql_ptr);   

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Dublin_Core_Metadata_Type::set_handle_id':"
            << endl
            << "`submit_mysql_query' failed, returning " << status << ":"
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to lock database tables."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        pthread_mutex_unlock(&sql_lock_tables_mutex);

        return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::set_handle_id':  Locked "
            << "database tables successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   sql_strm.str("");
   mysql_free_result(result);
   result = 0;

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::set_handle_id| definition@>=

   handle_id = hhandle_id;

   sql_strm << "update gwirdsif.Dublin_Core_Metadata set handle_id = " << handle_id 
            << " where dublin_core_metadata_id = " << id;
  
#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = submit_mysql_query(sql_strm.str(), result, mysql_ptr, 0, 0, &affected_rows);   

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Dublin_Core_Metadata_Type::set_handle_id':"
            << endl
            << "`submit_mysql_query' failed, returning " << status << ":"
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to update `Dublin_Core_Metadata' table."
            << endl;
        unlock_cerr_mutex(); 

        if (result)
        {
           mysql_free_result(result);
           result = 0;
        }

        ret_val = 1;
 
        goto SET_HANDLE_ID_UNLOCK_TABLES;


   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::set_handle_id':  Updated Dublin_Core_Metadata "
            << "table successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   sql_strm.str("");
   mysql_free_result(result);
   result = 0;

@q ***** (5) Unlock `gwirdsif.Dublin_Core_Metadata' database table.  @>

@ Unlock \.{gwirdsif.Dublin\_Core\_Metadata} database table.  
\initials{LDF 2013.02.28.}

@<|Dublin_Core_Metadata_Type::set_handle_id| definition@>=

SET_HANDLE_ID_UNLOCK_TABLES:

   sql_strm.str("");

   if (result)
   {
      mysql_free_result(result);
      result = 0;
   }

   sql_strm << "unlock tables";

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = submit_mysql_query(sql_strm.str(), result, mysql_ptr);   

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Dublin_Core_Metadata_Type::set_handle_id':"
            << endl
            << "`submit_mysql_query' failed, returning " << status << ":"
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to unlock database tables."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);

        pthread_mutex_unlock(&sql_lock_tables_mutex);

        return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Dublin_Core_Metadata_Type::set_handle_id':  Unlocked "
            << "database tables successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   pthread_mutex_unlock(&sql_lock_tables_mutex);

   sql_strm.str("");
   mysql_free_result(result);
   result = 0;


@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::set_handle_id| definition@>=


@q ***** (5) @>

   if (ret_val != 0)
   {
       lock_cerr_mutex(); 
       cerr << "Exiting `Dublin_Core_Metadata_Type::set_handle_id' unsuccessfully "
            << "with return value " << ret_val << "."
            << endl;
       unlock_cerr_mutex(); 

       return ret_val;

   }  /* |if (ret_val != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Exiting `Dublin_Core_Metadata_Type::set_handle_id' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return ret_val;

}  /* End of |Dublin_Core_Metadata_Type::set_handle_id| definition  */

@q *** (3) @>


@q *** (3) Mark Dublin Core metadata for deletion (|mark_dc_metadata_for_deletion|).  @>
@ Mark Dublin Core metadata for deletion (|mark_dc_metadata_for_deletion|).
\initials{LDF 2013.11.20.}

\LOG
\initials{LDF 2013.11.20.}
Added this function.
\ENDLOG

@q **** (4) Declaration  @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
static
int
mark_dc_metadata_for_deletion(MYSQL *&mysql_ptr,
                              Response_Type &response,
                              deque<Response_Type> &response_deque,
                              string irods_current_dir,
                              int user_id,
                              unsigned int &errors_occurred,
                              unsigned int &warnings_occurred,
                              string thread_str);


@q **** (4) Definition  @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=
int
Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion(MYSQL *&mysql_ptr,
                                                         Response_Type &response,
                                                         deque<Response_Type> &response_deque,
                                                         string irods_current_dir,
                                                         int user_id,
                                                         unsigned int &errors_occurred,
                                                         unsigned int &warnings_occurred,
                                                         string thread_str)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   stringstream temp_strm;

   stringstream sql_strm;

   MYSQL_RES* result = 0;
   MYSQL_ROW curr_row;

   unsigned int row_ctr   = 0;
   unsigned int field_ctr = 0;
   long affected_rows     = 0L;

   int status = 0;

   string filename_str;

   Response_Type new_response;

   new_response.type = Response_Type::COMMAND_ONLY_TYPE;


#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion'."
            << endl;
       response.show("response:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

   if (response.string_vector.size() == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
            << endl
            << "`string_vector' is empty."
            << endl 
            << "No filenames.  Can't mark Dublin Core metadata for deletion."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "DELETE METADATA RESPONSE 1 \"(No filenames)\" "
                 << response.metadata_options << "U \"Failure (no filenames)\"";

       new_response.command = temp_strm.str();
       response_deque.push_back(new_response);
       
       ++errors_occurred; 

       return 1;

   }  /* |if (string_vector.size() == 0)|  */

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

   size_t pos = response.string_vector.front().find("/");

   if (pos == string::npos)
   {
      filename_str  = irods_current_dir;
      filename_str += "/";
   }

   filename_str += response.string_vector.front();
       
   if (response.string_vector.size() > 1) 
      filename_str += " ... (multiple iRODS objects)";   

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

   sql_strm << "select dublin_core_metadata_id, irods_object_path, "
            << "dc_metadata_irods_object_path, marked_for_deletion, "
            << "delete_from_database_timestamp "
            << "from gwirdsif.Dublin_Core_Metadata where "
            << "user_id = " << user_id << " and irods_object_path ";

   string comma_str = "";

   sql_strm << "in (";

   for (vector<string>::iterator iter = response.string_vector.begin();
        iter != response.string_vector.end();
        ++iter)
   {
       
      pos = iter->find("/");

      if (pos == string::npos)
         sql_strm << "'" << irods_current_dir << "/";

      sql_strm << *iter << "'";

      string comma_str = ", ";

   }  /* |for|  */

   sql_strm << ")";

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=
  
#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
            << endl
            << "`sql_strm.str()' == " << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

   status = submit_mysql_query(sql_strm.str(), result, mysql_ptr, &row_ctr, &field_ctr);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
            << endl
            << "`submit_mysql_query' failed, returning "
            << status << "."
            << endl
            << "Failed to retrieve Dublin Core metadata from the "
            << "`gwirdsif.Dublin_Core_Metadata' database table."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "DELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                 << "\"" << filename_str << "\" "
                 << response.metadata_options << "U \"Server-side database error\"";

       new_response.command = temp_strm.str();
       response_deque.push_back(new_response);

       if (result)
          mysql_free_result(result);

       ++errors_occurred; 

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

   else if (row_ctr == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
            << endl
            << "`row_ctr' == 0:"
            << endl
            << "Failed to retrieve Dublin Core metadata from the "
            << "`gwirdsif.Dublin_Core_Metadata' database table."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "DELETE METADATA RESPONSE " << GW_DC_METADATA_NOT_FOUND << " "
                 << "\"" << filename_str << "\" "
                 << response.metadata_options << "U \"Dublin Core metadata not found\"";


       new_response.command = temp_strm.str();
       response_deque.push_back(new_response);

       if (result)
          mysql_free_result(result);

       ++errors_occurred; 

       return 1;

   }  /* |if (status != 0)|  */


@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
            << endl
            << "`submit_mysql_query' succeeded, returning 0."
            << endl
            << "`row_ctr' == " << row_ctr
            << endl 
            << "`field_ctr' == " << field_ctr
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       bitset<sizeof(response.metadata_options)> b(response.metadata_options);

       lock_cerr_mutex(); 
       cerr << thread_str << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
            << endl
            << "`response.metadata_options' == " << b 
            << endl
            << "response.delay_value        == " << response.delay_value
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */    

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

   unsigned long temp_val = 0UL;

   unsigned long dc_metadata_id = 0UL;
   bool marked_for_deletion;
   string filename;
   string timestamp; 

   bool delete_file      = response.metadata_options &  1U;

   bool delete_file_only = response.metadata_options &  2U;

   bool immediate        = response.metadata_options &  4U;

   bool force            = response.metadata_options & 16U;

   bool save_db_entry    = response.metadata_options & 32U;

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
            << endl
            << "`delete_file'      == " << delete_file
            << endl 
            << "`delete_file_only' == " << delete_file_only
            << endl 
            << "`immediate'        == " << immediate
            << endl 
            << "`force'            == " << force
            << endl 
            << "`save_db_entry'    == " << save_db_entry
            << endl; 
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=


   if (delete_file && delete_file_only)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "WARNING!  "
            << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
            << endl
            << "`delete_file' and `delete_file_only' are both `true'."
            << endl
            << "Setting `delete_file' to `false'."
            << endl;
       unlock_cerr_mutex(); 

       delete_file = false;

       ++warnings_occurred; 

   }  /* |if (delete_file && delete_file_only)|  */


   temp_strm.str("");

   sql_strm.str("");  

   sql_strm << "update gwirdsif.Dublin_Core_Metadata set marked_for_deletion = 1, "
            << "last_modified = now(), delete_from_database_timestamp = ";

   if (immediate)
      sql_strm << "timestampadd(second, -31622400, now()) ";

   else if (response.delay_value == 0 || response.delay_value == 1)  
   {
      sql_strm << "now()";
   }
   else
      sql_strm << "timestampadd(second, " << response.delay_value << ", now())";

   if (delete_file_only == true && save_db_entry == true)
      sql_strm << ", delete_file = 6 ";
   else if (delete_file_only == true && save_db_entry == false)
      sql_strm << ", delete_file = 2 ";
   else if (delete_file == true && save_db_entry == true)
      sql_strm << ", delete_file = 5 ";
   else if (delete_file == true && save_db_entry == false)
      sql_strm << ", delete_file = 1 ";
   else 
      sql_strm << ", delete_file = 0 ";

   sql_strm << "where dublin_core_metadata_id in (";

   comma_str = "";

   bool found = false;

   for (int i = 0; i < row_ctr; ++i)
   {
@q ****** (6) @>

        curr_row = mysql_fetch_row(result);

        if (curr_row == 0)
        {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "ERROR!  In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
                << endl 
                << "`mysql_fetch_row' failed, returning 0:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           temp_strm.str("");

           temp_strm << "DELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                     << "\"" << filename_str << "\" "
                     << response.metadata_options << "U \"Server-side database error\"";

           new_response.command = temp_strm.str();
           response_deque.push_back(new_response);

           if (result)
              mysql_free_result(result);

           ++errors_occurred; 

           return 1;

        }  /* |if (curr_row == 0)|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

        temp_val = strtoul(curr_row[0], 0, 10);

        errno = 0;

        if (temp_val == ULONG_MAX)
        {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "ERROR!  In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX':"
                << endl
                << strerror(errno)
                << endl 
                << "Failed to retrieve `dublin_core_metadata_id' field from the "
                << "`gwirdsif.Dublin_Core_Metadata' database table."
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           temp_strm.str("");

           temp_strm << "DELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                     << "\"" << filename_str << "\" "
                     << response.metadata_options << "U \"Server-side database error\"";

           new_response.command = temp_strm.str();
           response_deque.push_back(new_response);

           if (result)
              mysql_free_result(result);

           ++errors_occurred; 

           return 1;

        }  /* |if (temp_val == ULONG_MAX)|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str
                 << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
                 << endl 
                 << "`strtoul' succeeded.  `temp_val' == " << temp_val << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

        dc_metadata_id = temp_val;

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

        if (curr_row[3] == static_cast<char*>(0))
           marked_for_deletion = false;

        else
        {
@q ******* (7) @>

            temp_val = strtoul(curr_row[3], 0, 10);

            errno = 0;

            if (temp_val == ULONG_MAX)
            {
               lock_cerr_mutex(); 
               cerr << thread_str
                    << "ERROR!  In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
                    << endl 
                    << "`strtoul' failed, returning `ULONG_MAX':"
                    << endl
                    << strerror(errno)
                    << endl 
                    << "Failed to retrieve `marked_for_deletion' field from the "
                    << "`gwirdsif.Dublin_Core_Metadata' database table."
                    << endl 
                    << "Exiting function unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               temp_strm.str("");

               temp_strm << "DELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                         << "\"" << filename_str << "\" "
                         << response.metadata_options << "U \"Server-side database error\"";

               new_response.command = temp_strm.str();
               response_deque.push_back(new_response);

               if (result)
                  mysql_free_result(result);

               ++errors_occurred; 

               return 1;

            }  /* |if (temp_val == ULONG_MAX)|  */


@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

            else if (temp_val > 1)
            {
               lock_cerr_mutex(); 
               cerr << thread_str
                    << "ERROR!  In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
                    << endl 
                    << "Invalid value for `marked_for_deletion' field:  " << temp_val << "."
                    << endl
                    << "Exiting function unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               temp_strm.str("");

               temp_strm << "DELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                         << "\"" << filename_str << "\" "
                         << response.metadata_options << "U \"Server-side database error\"";

               new_response.command = temp_strm.str();
               response_deque.push_back(new_response);

               if (result)
                  mysql_free_result(result);

               ++errors_occurred; 

               return 1;

            }  /* |if (temp_val > 1)|  */

@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str
                     << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
                     << endl 
                     << "`strtoul' succeeded.  `temp_val' == " << temp_val << "."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

            marked_for_deletion = static_cast<bool>(temp_val);

        }  /* |else|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

        if (curr_row[1] == static_cast<char*>(0))
        {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "ERROR!  In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
                << endl 
                << "`curr_row[1]' == 0:"
                << endl
                << strerror(errno)
                << endl 
                << "Failed to retrieve `irods_object_path' field from the "
                << "`gwirdsif.Dublin_Core_Metadata' database table."
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           temp_strm.str("");

           temp_strm << "DELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                     << "\"" << filename_str << "\" "
                     << response.metadata_options << "U \"Server-side database error\"";

           new_response.command = temp_strm.str();
           response_deque.push_back(new_response);

           if (result)
              mysql_free_result(result);

           ++errors_occurred; 

           return 1;

        }  /* |if (curr_row[1] == static_cast<char*>(0))|  */

        filename = curr_row[1];

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

        if (curr_row[4] == static_cast<char*>(0))
        {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "ERROR!  In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
                << endl 
                << "`curr_row[4]' == 0:"
                << endl
                << strerror(errno)
                << endl 
                << "Failed to retrieve `delete_from_database_timestamp' field from the "
                << "`gwirdsif.Dublin_Core_Metadata' database table."
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           temp_strm.str("");

           temp_strm << "DELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                     << "\"" << filename_str << "\" "
                     << response.metadata_options << "U \"Server-side database error\"";

           new_response.command = temp_strm.str();
           response_deque.push_back(new_response);

           if (result)
              mysql_free_result(result);

           ++errors_occurred; 

           return 1;

        }  /* |if (curr_row[4] == static_cast<char*>(0))|  */

        timestamp = curr_row[4];

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str
                 << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
                 << endl 
                 << "`dc_metadata_id' == " << dc_metadata_id
                 << endl 
                 << "`marked_for_deletion' == " << marked_for_deletion
                 << endl 
                 << "`filename' == " << filename
                 << endl 
                 << "`timestamp' == " << timestamp
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

        if (marked_for_deletion && force == false)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "WARNING!  "
                 << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
                 << endl
                 << "Dublin core metadata for iRODS object `" << filename << "' "
                 << "already marked for deletion and `force' == `false'."
                 << endl
                 << "Not marking again.  Will send response to client."
                 << endl;
            unlock_cerr_mutex();  

            ++warnings_occurred;

            temp_strm.str("");

            temp_strm << "DELETE METADATA RESPONSE " 
                      << GW_DC_METADATA_ALREADY_MARKED_FOR_DELETION << " "
                      << "\"" << filename  << "\" "
                      << response.metadata_options << "U "
                      << "\"Dublin Core metadata already marked for deletion."
                      << endl 
                      << "`delete_from_database_timestamp' == " << timestamp << endl
                      << "Not marking again.  Use `force' option to force marking.\"";


            new_response.command = temp_strm.str();

            temp_strm.str("");

            response_deque.push_back(new_response);

        }  /* |if (marked_for_deletion && force == false)|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

        else
        {

            found = true;

            sql_strm << comma_str << dc_metadata_id;

            comma_str = ", ";

        }  /* |else|  */

@q ****** (6) @>

   }  /* |for|  */

   sql_strm << ")";

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
            << endl 
            << "`found' == " << found 
            << endl
            << "`sql_strm.str()' == " << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   mysql_free_result(result);
   result = 0;

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

   if (found == false)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "WARNING!  "
            << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
            << endl
            << "`found' == `false':  No Dublin Core metadata found to mark for deletion."
            << endl 
            << "Exiting function unsuccessfully with return value 2."
            << endl;
       unlock_cerr_mutex();  

       temp_strm.str("");

       temp_strm << "DELETE METADATA RESPONSE " 
                 << GW_DC_METADATA_NOT_FOUND << " "
                 << "\"" << filename  << "\" "
                 << response.metadata_options << "U "
                 << "\"No Dublin Core metadata found to mark for deletion.\""
                 << endl;

       new_response.command = temp_strm.str();
       response_deque.push_back(new_response);

       ++warnings_occurred;

       return 2;

   }  /* |if (found == false)|  */

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

   status = submit_mysql_query(sql_strm.str(), result, mysql_ptr, 0, 0, &affected_rows);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
            << endl
            << "`submit_mysql_query' failed, returning "
            << status << "."
            << endl
            << "Failed to update Dublin Core metadata in the "
            << "`gwirdsif.Dublin_Core_Metadata' database table."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "DELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                 << "\"" << filename_str << "\" "
                 << response.metadata_options << "U \"Server-side database error\"";

       new_response.command = temp_strm.str();
       response_deque.push_back(new_response);

       if (result)
          mysql_free_result(result);

       ++errors_occurred; 

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

   else if (affected_rows == 0L)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
            << endl
            << "`affected_rows' == 0:"
            << endl
            << "Failed to update Dublin Core metadata in the "
            << "`gwirdsif.Dublin_Core_Metadata' database table."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "DELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                 << "\"" << filename_str << "\" "
                 << response.metadata_options << "U \"Failed to update Dublin Core metadata.\"";

       new_response.command = temp_strm.str();
       response_deque.push_back(new_response);

       if (result)
          mysql_free_result(result);

       ++errors_occurred; 

       return 1;

   }  /* |if (status != 0)|  */


@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
            << endl
            << "`submit_mysql_query' succeeded, returning 0."
            << endl
            << "`affected_rows' == " << affected_rows
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

   mysql_free_result(result);
   result = 0;

   temp_strm.str("");

   temp_strm << "DELETE METADATA RESPONSE 0 \"" << filename_str << "\" "
             << response.metadata_options << "U \"Success\"";

   new_response.command = temp_strm.str();
   response_deque.push_back(new_response);

@q ***** (5) @>
@
\LOG
\initials{LDF 2013.11.27.}
Added this section.
\ENDLOG

@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=

   if (immediate)  
   {
@q ******* (7) @>

        if (purge_dc_metadata_thread_id == static_cast<pthread_t>(0))
        {
             lock_cerr_mutex(); 
             cerr << thread_str 
                  << "NOTICE!  In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
                  << endl
                  << "`purge_dc_metadata_thread_id' == 0."
                  << endl
                  << "\"Purge Dublin Core metadata\" thread not running.  "
                  << "Not calling `pthread_cond_signal' "
                  << "to wake it up."
                  << endl
                  << "Continuing."
                  << endl;
             unlock_cerr_mutex(); 

        }  /* |if (purge_dc_metadata_thread_id == 0)|  */

@q ******* (7) @>

        else
        {
            pthread_mutex_lock(&purge_dc_metadata_mutex);

            status = pthread_cond_signal(&purge_dc_metadata_cond);

            if (status != 0)
            {
               lock_cerr_mutex(); 
               cerr << thread_str 
                    << "ERROR!  In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
                    << endl
                    << "`pthread_cond_signal' failed, returning " << status << ":"
                    << endl
                    << "Error:  " << strerror(status)
                    << endl
                    << "Exiting function unsuccessfully with return value 1." 
                    << endl;
               unlock_cerr_mutex(); 

               ++errors_occurred; 

               return 1;

            }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str 
                     << "In `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion':"
                     << endl
                     << "`pthread_cond_signal' succeeded, returning 0."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

            pthread_mutex_unlock(&purge_dc_metadata_mutex);

        }  /* |else|  */

@q ******* (7) @>

   } /* |if (immediate)|  */


@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>=



#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Exiting `Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    return 0;

}  /* End of |Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition  */

@q *** (3) Undelete Dublin Core metadata for deletion (|undelete_dc_metadata|).  @>
@ Undelete Dublin Core metadata for deletion (|undelete_dc_metadata|).
\initials{LDF 2013.11.20.}

\LOG
\initials{LDF 2013.11.20.}
Added this function.
\ENDLOG

@q **** (4) Declaration  @>

@<|Dublin_Core_Metadata_Type| function declarations@>=
static
int
undelete_dc_metadata(MYSQL *&mysql_ptr,
                     Response_Type &response,
                     deque<Response_Type> &response_deque,
                     string irods_current_dir,
                     int user_id,
                     unsigned int &errors_occurred,
                     unsigned int &warnings_occurred,
                     string thread_str);

@q **** (4) Definition  @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=
int
Dublin_Core_Metadata_Type::undelete_dc_metadata(MYSQL *&mysql_ptr,
                                                Response_Type &response,
                                                deque<Response_Type> &response_deque,
                                                string irods_current_dir,
                                                int user_id,
                                                unsigned int &errors_occurred,
                                                unsigned int &warnings_occurred,
                                                string thread_str)
{

@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   stringstream temp_strm;
   stringstream sql_strm;

   MYSQL_RES* result = 0;
   MYSQL_ROW curr_row;

   unsigned int row_ctr   = 0;
   unsigned int field_ctr = 0;
   long affected_rows     = 0L;

   int status = 0;

   string filename_str;


   Response_Type new_response;
   new_response.type = Response_Type::COMMAND_ONLY_TYPE;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `Dublin_Core_Metadata_Type::undelete_dc_metadata'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

   if (response.string_vector.size() == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
            << endl
            << "`string_vector' is empty."
            << endl 
            << "No filenames.  Can't unmark Dublin Core metadata for deletion."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "UNDELETE METADATA RESPONSE 1 \"(No filenames)\" "
                 << "\"Failure (no filenames)\"";

       new_response.command = temp_strm.str();
       response_deque.push_back(new_response);

       ++errors_occurred; 

       return 1;

   }  /* |if (string_vector.size() == 0)|  */

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

   size_t pos = response.string_vector.front().find("/");

   if (pos == string::npos)
   {
      filename_str  = irods_current_dir;
      filename_str += "/";
   }

   filename_str += response.string_vector.front();
       
   if (response.string_vector.size() > 1) 
      filename_str += " ... (multiple iRODS objects)";   


@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

   sql_strm << "select dublin_core_metadata_id, marked_for_deletion, irods_object_path "
            << "from gwirdsif.Dublin_Core_Metadata where user_id = " << user_id << " "
            << "and irods_object_path in (";

   string comma_str = "";

   for (vector<string>::iterator iter = response.string_vector.begin();
        iter != response.string_vector.end();
        ++iter)
   {

       sql_strm << comma_str << "'";

       pos = iter->find("/");

       if (pos == string::npos)
           sql_strm << irods_current_dir << "/";

       sql_strm << *iter << "'";

       comma_str = ", ";

   }  /* |for|  */

   sql_strm << ")";

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
            << endl
            << "`sql_strm.str()' == " << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

   status = submit_mysql_query(sql_strm.str(), result, mysql_ptr, &row_ctr, &field_ctr);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
            << endl
            << "`submit_mysql_query' failed, returning "
            << status << "."
            << endl
            << "Failed to retrieve Dublin Core metadata from the "
            << "`gwirdsif.Dublin_Core_Metadata' database table."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "UNDELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                 << "\"" << filename_str << "\" "
                 << "\"Server-side database error\"";

       new_response.command = temp_strm.str();
       response_deque.push_back(new_response);

       if (result)
          mysql_free_result(result);

       ++errors_occurred; 

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

   else if (row_ctr == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
            << endl
            << "`row_ctr' == 0:"
            << endl
            << "Failed to retrieve Dublin Core metadata from the "
            << "`gwirdsif.Dublin_Core_Metadata' database table."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "UNDELETE METADATA RESPONSE " << GW_DC_METADATA_NOT_FOUND << " "
                 << "\"" << filename_str << "\" "
                 << "\"Dublin Core metadata not found\"";


       new_response.command = temp_strm.str();
       response_deque.push_back(new_response);

       if (result)
          mysql_free_result(result);

       ++errors_occurred; 

       return 1;

   }  /* |if (status != 0)|  */


@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
            << endl
            << "`submit_mysql_query' succeeded, returning 0."
            << endl
            << "`row_ctr' == " << row_ctr
            << endl 
            << "`field_ctr' == " << field_ctr
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

   unsigned long int dc_metadata_id = 0UL; 
   bool marked_for_deletion;

   bool found = false;

   sql_strm.str("");

   sql_strm << "update gwirdsif.Dublin_Core_Metadata set marked_for_deletion = 0, "
            << "delete_file = 0, delete_from_database_timestamp = 0, last_modified = now() "
            << "where dublin_core_metadata_id in (";

   unsigned long int temp_val = 0UL;

   comma_str = "";

   for (int i = 0; i < row_ctr; ++i)
   {
@q ****** (6) @>

        curr_row = mysql_fetch_row(result);

        if (curr_row == 0)
        {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "ERROR!  In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
                << endl 
                << "`mysql_fetch_row' failed, returning 0:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           temp_strm.str("");

           temp_strm << "UNDELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                     << "\"" << filename_str << "\" "
                     << "\"Server-side database error\"";

           new_response.command = temp_strm.str();
           response_deque.push_back(new_response);

           if (result)
              mysql_free_result(result);

           ++errors_occurred; 

           return 1;

        }  /* |if (curr_row == 0)|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

        temp_val = strtoul(curr_row[0], 0, 10);

        errno = 0;

        if (temp_val == ULONG_MAX)
        {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "ERROR!  In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX':"
                << endl
                << strerror(errno)
                << endl 
                << "Failed to retrieve `dublin_core_metadata_id' field from the "
                << "`gwirdsif.Dublin_Core_Metadata' database table."
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           temp_strm.str("");

           temp_strm << "UNDELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                     << "\"" << filename_str << "\" "
                     << "\"Server-side database error\"";

           new_response.command = temp_strm.str();
           response_deque.push_back(new_response);

           if (result)
              mysql_free_result(result);

           ++errors_occurred; 

           return 1;

        }  /* |if (temp_val == ULONG_MAX)|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str
                 << "In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
                 << endl 
                 << "`strtoul' succeeded.  `temp_val' == " << temp_val << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

        dc_metadata_id = temp_val;

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

        temp_val = strtoul(curr_row[1], 0, 10);

        errno = 0;

        if (temp_val == ULONG_MAX)
        {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "ERROR!  In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX':"
                << endl
                << strerror(errno)
                << endl 
                << "Failed to retrieve `marked_for_deletion' field from the "
                << "`gwirdsif.Dublin_Core_Metadata' database table."
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           temp_strm.str("");

           temp_strm << "UNDELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                     << "\"" << filename_str << "\" "
                     << "\"Server-side database error\"";

           new_response.command = temp_strm.str();
           response_deque.push_back(new_response);

           if (result)
              mysql_free_result(result);

           ++errors_occurred; 

           return 1;

        }  /* |if (temp_val == ULONG_MAX)|  */


@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

        else if (temp_val > 1)
        {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "ERROR!  In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
                << endl 
                << "Invalid value for `marked_for_deletion' field:  " << temp_val << "."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           temp_strm.str("");

           temp_strm << "UNDELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                     << "\"" << filename_str << "\" "
                     << "\"Server-side database error\"";

           new_response.command = temp_strm.str();
           response_deque.push_back(new_response);

           if (result)
              mysql_free_result(result);

           ++errors_occurred; 

           return 1;

        }  /* |if (temp_val > 1)|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str
                 << "In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
                 << endl 
                 << "`strtoul' succeeded.  `temp_val' == " << temp_val << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

        marked_for_deletion = static_cast<bool>(temp_val);

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
            << endl 
            << "`dc_metadata_id'      == " << dc_metadata_id
            << endl 
            << "`marked_for_deletion' == " << marked_for_deletion
            << endl
            << "`curr_row[2]' == " << curr_row[2]
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

    if (marked_for_deletion == false)
    {
           temp_strm.str("");

           temp_strm << "UNDELETE METADATA RESPONSE " 
                     << GW_DC_METADATA_NOT_MARKED_FOR_DELETION << " "
                     << "\"" << curr_row[2] << "\" "
                     << "\"Dublin Core metadata not marked for deletion." 
                     << endl
                     << "Not unmarking.\"";

           new_response.command = temp_strm.str();
           response_deque.push_back(new_response);

           ++warnings_occurred; 

           temp_strm.str("");

    }
    else
    {
        sql_strm << comma_str << dc_metadata_id;
  
        comma_str = ", ";

        found = true;
    }

@q ****** (6) @>

   }  /* |for|  */

   sql_strm << ")";

   mysql_free_result(result);
   result = 0;

   if (found == false)
   {

        lock_cerr_mutex(); 
        cerr << thread_str
             << "WARNING!  In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
             << endl 
             << "No Dublin Core metadata found to undelete."
             << endl
             << "Will send response to client "
             << "and exit function unsuccessfully with return value 2."
             << endl;
        unlock_cerr_mutex(); 

        temp_strm.str("");

        temp_strm << "UNDELETE METADATA RESPONSE " << GW_DC_METADATA_NOT_FOUND << " "
                  << "\"" << filename_str << "\" "
                  << "\"No Dublin Core metadata found to unmark for deletion.\"";

        new_response.command = temp_strm.str();
        response_deque.push_back(new_response);

        ++warnings_occurred; 

        return 2;

   }  /* |if (found == false)|  */

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
            << endl 
            << "`found' == " << true
            << endl
            << "`sql_strm.str()' == " << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

   status = submit_mysql_query(sql_strm.str(), result, mysql_ptr, 0, 0, &affected_rows);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
            << endl
            << "`submit_mysql_query' failed, returning "
            << status << "."
            << endl
            << "Failed to update Dublin Core metadata in the "
            << "`gwirdsif.Dublin_Core_Metadata' database table."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "UNDELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                 << "\"" << filename_str << "\" "
                 << "\"Server-side database error\"";

       new_response.command = temp_strm.str();
       response_deque.push_back(new_response);

       if (result)
          mysql_free_result(result);

       ++errors_occurred; 

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

   else if (affected_rows == 0L)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
            << endl
            << "`affected_rows' == 0:"
            << endl
            << "Failed to update Dublin Core metadata in the "
            << "`gwirdsif.Dublin_Core_Metadata' database table."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "UNDELETE METADATA RESPONSE " << GW_SERVER_SIDE_DATABASE_ERROR << " "
                 << "\"" << filename_str << "\" "
                 << "\"Failed to update Dublin Core metadata.\"";

       new_response.command = temp_strm.str();
       response_deque.push_back(new_response);

       if (result)
          mysql_free_result(result);

       ++errors_occurred; 

       return 1;

   }  /* |if (status != 0)|  */


@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Dublin_Core_Metadata_Type::undelete_dc_metadata':"
            << endl
            << "`submit_mysql_query' succeeded, returning 0."
            << endl
            << "`affected_rows' == " << affected_rows
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

   mysql_free_result(result);
   result = 0;

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>=

   temp_strm.str("");

   temp_strm << "UNDELETE METADATA RESPONSE 0 \"" << filename_str << "\" "
             << "\"Success\"";

   new_response.command = temp_strm.str();
   response_deque.push_back(new_response);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Exiting `Dublin_Core_Metadata_Type::undelete_dc_metadata' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


    return 0;

}  /* End of |Dublin_Core_Metadata_Type::undelete_dc_metadata| definition  */


@q **** (4) @>

@q *** (3) Get Dublin Core metadata from database (|get_dc_metadata_from_database|).  @>
@ Get Dublin Core metadata from database (|get_dc_metadata_from_database|).  
\initials{LDF 2013.11.22.}

\LOG
\initials{LDF 2013.11.22.}
Added this function.

\initials{LDF 2013.12.09.}
Added argument |Response_Type &response|.  Removed optional argument 
|bool get_sub_dc_metadata = false|.

\initials{LDF 2013.12.16.}
Added optional argument |string database = "gwirdsif"|.
\ENDLOG

@q **** (4) Declaration  @>

@<|Dublin_Core_Metadata_Type| function declarations@>=

static
int
get_dc_metadata_from_database(MYSQL *&mysql_ptr,
                              Response_Type &response,
                              map<unsigned long int, Dublin_Core_Metadata_Type> 
                                 &dc_metadata_map,
                              vector<string> &irods_object_path_vector,
                              vector<unsigned int> &id_vector,
                              bool get_expired,
                              unsigned int limit,
                              string database = "gwirdsif",
                              string thread_str = "");

@q **** (4) Definition  @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

int
Dublin_Core_Metadata_Type::get_dc_metadata_from_database(MYSQL *&mysql_ptr,
                                                         Response_Type &response,
                                                         map<unsigned long int, 
                                                            Dublin_Core_Metadata_Type>
                                                             &dc_metadata_map,
                                                         vector<string> &irods_object_path_vector,
                                                         vector<unsigned int> &id_vector,
                                                         bool get_expired,
                                                         unsigned int limit,
                                                         string database,
                                                         string thread_str)

{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Dublin_Core_Metadata_Type::get_dc_metadata_from_database'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

   Dublin_Core_Metadata_Type curr_dc_metadata;

   int status;

   stringstream temp_strm;

   const int sql_ctr = 3;
   stringstream sql_strm[sql_ctr];

   MYSQL_RES *result[sql_ctr] = {0, 0, 0};

   unsigned int row_ctr;
   unsigned int field_ctr;
   long affected_rows;

   MYSQL_ROW curr_row;

   unsigned long temp_ulong = 0UL;
   int temp_int             = 0;

   bool get_sub_dc_metadata = response.options & 8U;

   unsigned long int temp_val = 0UL;

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

@q ****** (6) @>

   string comma_str = "";
   string and_str   = "";
   string where_str = "where ";

   sql_strm[0] << "select distinct dublin_core_metadata_id, user_id, irods_server_id, "
               << "irods_object_path, dc_metadata_irods_object_path, "
               << "handle_id, created, unix_timestamp(created), "
               << "last_modified, unix_timestamp(last_modified), marked_for_deletion, "
               << "delete_file, delete_from_database_timestamp, "
               << "unix_timestamp(delete_from_database_timestamp), "
               << "irods_object_ref_id, irods_object_self_id "
               << "from gwirdsif.Dublin_Core_Metadata ";

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

   if (id_vector.size() > 0)
   {
      sql_strm[0] << where_str << "dublin_core_metadata_id in (";

      for (vector<unsigned int>::iterator iter = id_vector.begin();
           iter != id_vector.end();
           ++iter)
      { 
          sql_strm[0] << comma_str << *iter;
          comma_str = ", ";
      }

      sql_strm[0] << ") ";

      where_str = "";
      and_str = "and ";
      comma_str = "";

   }  /* |if (id_vector.size() > 0)|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

   if (irods_object_path_vector.size() > 0)
   {
      sql_strm[0] << where_str << and_str << "irods_object_path in (";

      for (vector<string>::iterator iter = irods_object_path_vector.begin();
           iter != irods_object_path_vector.end();
           ++iter)
      { 
          sql_strm[0] << comma_str << "'" << *iter << "'";
          comma_str = ", ";
      }

      sql_strm[0] << ") ";

      where_str = "";
      and_str = "and ";
      comma_str = "";

   }  /* |if (irods_object_path.size() > 0)|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

   if (get_expired == true)
   {
       sql_strm[0] << where_str << and_str << "marked_for_deletion = 1 "
                   << "and delete_from_database_timestamp < "
                   << "timestampadd(second, -" << limit << ", now()) ";

   }

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

   sql_strm[0] << "order by dublin_core_metadata_id";

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=


#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
            << endl
            << "`sql_strm[0].str()' == " << sql_strm[0].str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

        status = submit_mysql_query(sql_strm[0].str(), result[0], mysql_ptr, &row_ctr, &field_ctr);

        if (status != 0)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "ERROR!  "
                 << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                 << endl
                 << "`submit_mysql_query' failed, returning " << status << ":"
                 << endl 
                 << "Error:  " << mysql_error(mysql_ptr)
                 << endl 
                 << "Error number:  " << mysql_errno(mysql_ptr)
                 << endl 
                 << "Failed to select Dublin Core metadata from the "
                 << "`gwirdsif.Dublin_Core_Metadata' database table." 
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
             unlock_cerr_mutex(); 

             if (result[0])
                mysql_free_result(result[0]);

             return 1;

        }  /* |if (status != 0)|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':" 
                 << endl
                 << "`submit_mysql_query' succeeded, returning 0."
                 << endl
                 << "`row_ctr' == " << row_ctr
                 << endl
                 << "`field_ctr' == " << field_ctr
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) |row_ctr == 0|.  No rows found.  @>

@ |row_ctr == 0|.  No rows found.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

        if (row_ctr == 0)
        {
#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str 
                     << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                     << endl
                     << "`row_ctr' == 0.  No rows found."
                     << endl
                     << "Exiting function successfully with return value 2."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

            mysql_free_result(result[0]);

            return 2;
      
        }  /* |if (row_ctr == 0)|  */

@q ***** (5) |row_ctr > 0|.  @>

@ |row_ctr > 0|.  
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

        int curr_field = 0;
 
        for (int i = 0; i < row_ctr; ++i)
        {
@q ****** (6) @>

             curr_field = 0;

             curr_dc_metadata.clear();

             curr_row = mysql_fetch_row(result[0]);

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             if (curr_row == 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`mysql_fetch_row' failed:"
                      << endl
                      << mysql_error(mysql_ptr)
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (curr_row == 0)|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`mysql_fetch_row' succeeded."
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) |dublin_core_metadata_id|.  @>

@ |dublin_core_metadata_id|.  
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

@q ******* (7) @>

             if (curr_row[curr_field] == 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `dublin_core_metadata_id' == 0."
                      << endl
                      << "This isn't permitted."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (curr_row[curr_field] == 0)|  */


@q ******* (7) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `dublin_core_metadata_id' == " 
                      << curr_row[curr_field]
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ******* (7) @>

             errno = 0;
             temp_ulong = strtoul(curr_row[curr_field], 0, 10);

             if (temp_ulong == ULONG_MAX)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' failed, returning `ULONG_MAX':"
                      << endl
                      << strerror(errno)
                      << endl 
                      << "Failed to set `curr_dc_metadata.id'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong == ULONG_MAX)|  */

@q ******* (7) @>

             curr_dc_metadata.id = temp_ulong;

#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' succeeded:"
                      << endl
                      << "`curr_dc_metadata.id' == " << curr_dc_metadata.id
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             ++curr_field;

@q ****** (6) |user_id|.  @>

@ |user_id|.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

@q ******* (7) @>

             if (curr_row[curr_field] == 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `user_id' == 0."
                      << endl
                      << "This isn't permitted."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (curr_row[curr_field] == 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `user_id' == " 
                      << curr_row[curr_field]
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             errno = 0;
             temp_ulong = strtoul(curr_row[curr_field], 0, 10);

             if (temp_ulong == ULONG_MAX)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' failed, returning `ULONG_MAX':"
                      << endl
                      << strerror(errno)
                      << endl 
                      << "Failed to set `curr_dc_metadata.user_id'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong == ULONG_MAX)|  */

@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             else if (temp_ulong > UINT_MAX)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' returned " << temp_ulong << " > "
                      << "(`UINT_MAX' == " << UINT_MAX << ")"
                      << endl
                      << "Value out of range for "
                      << "`Dublin_Core_Metadata_Type::user_id' (`unsigned int')."
                      << endl 
                      << "Failed to set `curr_dc_metadata.user_id'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong > UINT_MAX)|  */

@q ******* (7) @>

             curr_dc_metadata.user_id = static_cast<unsigned int>(temp_ulong); 

#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' succeeded:"
                      << endl
                      << "`curr_dc_metadata.user_id' == " << curr_dc_metadata.user_id
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             ++curr_field;

@q ****** (6) |irods_server_id|.  @>

@ |irods_server_id|.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             if (curr_row[curr_field] == 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `irods_server_id' == 0."
                      << endl
                      << "This isn't permitted."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (curr_row[curr_field] == 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `irods_server_id' == " 
                      << curr_row[curr_field]
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             errno = 0;
             temp_ulong = strtoul(curr_row[curr_field], 0, 10);

             if (temp_ulong == ULONG_MAX)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' failed, returning `ULONG_MAX':"
                      << endl
                      << strerror(errno)
                      << endl 
                      << "Failed to set `curr_dc_metadata.irods_server_id'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong == ULONG_MAX)|  */

@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             else if (temp_ulong > UINT_MAX)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' returned " << temp_ulong << " > "
                      << "(`UINT_MAX' == " << UINT_MAX << ")"
                      << endl
                      << "Value out of range for "
                      << "`Dublin_Core_Metadata_Type::irods_server_id' (`unsigned int')."
                      << endl 
                      << "Failed to set `curr_dc_metadata.irods_server_id'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong > UINT_MAX)|  */

@q ******* (7) @>

             curr_dc_metadata.irods_server_id = static_cast<unsigned int>(temp_ulong); 

#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' succeeded:"
                      << endl
                      << "`curr_dc_metadata.irods_server_id' == " 
                      << curr_dc_metadata.irods_server_id
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             ++curr_field;

@q ****** (6) |irods_object_path|.  @>

@ |irods_object_path|.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=


             if (curr_row[curr_field] == 0)
             {
#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str 
                         << "WARNING!  "
                         << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                         << endl 
                         << "`curr_row[" << curr_field << "]' == `irods_object_path' == 0."
                         << endl
                         << "Can't set `curr_dc_metadata.irods_object_path'."
                         << endl 
                         << "Will try to continue."
                         << endl;
                    unlock_cerr_mutex(); 
                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */

             }  /* |if (curr_row[curr_field] == 0)|  */

             else
             {
                curr_dc_metadata.irods_object_path = curr_row[curr_field];

#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str 
                         << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                         << endl 
                         << "`curr_dc_metadata.irods_object_path' == " 
                         << curr_dc_metadata.irods_object_path
                         << endl;
                    unlock_cerr_mutex(); 
                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */

             }  /* |else|  */

@q ******* (7) @>

             ++curr_field;

@q ****** (6) |dc_metadata_irods_object_path|.  @>

@ |dc_metadata_irods_object_path|.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=


             if (curr_row[curr_field] == 0)
             {
#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str 
                         << "WARNING!  "
                         << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                         << endl 
                         << "`curr_row[" << curr_field << "]' == "
                         << "`dc_metadata_irods_object_path' == 0."
                         << endl
                         << "Can't set `curr_dc_metadata.dc_metadata_irods_object_path'."
                         << endl 
                         << "Will try to continue."
                         << endl;
                    unlock_cerr_mutex(); 
                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */

             }  /* |if (curr_row[curr_field] == 0)|  */

             else
             {
                curr_dc_metadata.dc_metadata_irods_object_path = curr_row[curr_field];

#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str 
                         << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                         << endl 
                         << "`curr_dc_metadata.dc_metadata_irods_object_path' == " 
                         << curr_dc_metadata.dc_metadata_irods_object_path
                         << endl;
                    unlock_cerr_mutex(); 
                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */

             }  /* |else|  */

@q ******* (7) @>

             ++curr_field;

@q ****** (6) |handle_id|.  @>

@ |handle_id|.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             if (curr_row[curr_field] == 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `handle_id' == 0."
                      << endl
                      << "This isn't permitted."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (curr_row[curr_field] == 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `handle_id' == " 
                      << curr_row[curr_field]
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             errno = 0;
             temp_ulong = strtoul(curr_row[curr_field], 0, 10);

             if (temp_ulong == ULONG_MAX)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' failed, returning `ULONG_MAX':"
                      << endl
                      << strerror(errno)
                      << endl 
                      << "Failed to set `curr_dc_metadata.handle_id'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong == ULONG_MAX)|  */

@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             curr_dc_metadata.handle_id = temp_ulong; 

#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' succeeded:"
                      << endl
                      << "`curr_dc_metadata.handle_id' == " 
                      << curr_dc_metadata.handle_id
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             ++curr_field;

@q ****** (6) |created_str|.  @>

@ |created_str|.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             if (curr_row[curr_field] == 0)
             {
#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str 
                         << "WARNING!  "
                         << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                         << endl 
                         << "`curr_row[" << curr_field << "]' == "
                         << "`created_str' == 0."
                         << endl
                         << "Can't set `curr_dc_metadata.created_str'."
                         << endl 
                         << "Will try to continue."
                         << endl;
                    unlock_cerr_mutex(); 
                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */

             }  /* |if (curr_row[curr_field] == 0)|  */

             else
             {
                curr_dc_metadata.created_str = curr_row[curr_field];

#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str 
                         << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                         << endl 
                         << "`curr_dc_metadata.created_str' == " 
                         << curr_dc_metadata.created_str
                         << endl;
                    unlock_cerr_mutex(); 
                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */

             }  /* |else|  */

@q ******* (7) @>

             ++curr_field;

@q ****** (6) |created|.  @>

@ |created|.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             if (curr_row[curr_field] == 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `created' == 0."
                      << endl
                      << "This isn't permitted."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (curr_row[curr_field] == 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `created' == " 
                      << curr_row[curr_field]
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             errno = 0;
             temp_ulong = strtoul(curr_row[curr_field], 0, 10);

             if (temp_ulong == ULONG_MAX)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' failed, returning `ULONG_MAX':"
                      << endl
                      << strerror(errno)
                      << endl 
                      << "Failed to set `curr_dc_metadata.created'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong == ULONG_MAX)|  */

@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             curr_dc_metadata.created = static_cast<time_t>(temp_ulong); 

#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' succeeded:"
                      << endl
                      << "`curr_dc_metadata.created' == " 
                      << curr_dc_metadata.created
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

             ++curr_field;

@q ****** (6) |last_modified_str|.  @>

@ |last_modified_str|.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             if (curr_row[curr_field] == 0)
             {
#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str 
                         << "WARNING!  "
                         << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                         << endl 
                         << "`curr_row[" << curr_field << "]' == "
                         << "`last_modified_str' == 0."
                         << endl
                         << "Can't set `curr_dc_metadata.last_modified_str'."
                         << endl 
                         << "Will try to continue."
                         << endl;
                    unlock_cerr_mutex(); 
                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */

             }  /* |if (curr_row[curr_field] == 0)|  */

             else
             {
                curr_dc_metadata.last_modified_str = curr_row[curr_field];

#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str 
                         << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                         << endl 
                         << "`curr_dc_metadata.last_modified_str' == " 
                         << curr_dc_metadata.last_modified_str
                         << endl;
                    unlock_cerr_mutex(); 
                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */

             }  /* |else|  */

@q ******* (7) @>

             ++curr_field;

@q ****** (6) |last_modified|.  @>

@ |last_modified|.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             if (curr_row[curr_field] == 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `last_modified' == 0."
                      << endl
                      << "This isn't permitted."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (curr_row[curr_field] == 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `last_modified' == " 
                      << curr_row[curr_field]
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             errno = 0;
             temp_ulong = strtoul(curr_row[curr_field], 0, 10);

             if (temp_ulong == ULONG_MAX)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' failed, returning `ULONG_MAX':"
                      << endl
                      << strerror(errno)
                      << endl 
                      << "Failed to set `curr_dc_metadata.last_modified'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong == ULONG_MAX)|  */

@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             curr_dc_metadata.last_modified = static_cast<time_t>(temp_ulong); 

#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' succeeded:"
                      << endl
                      << "`curr_dc_metadata.last_modified' == " 
                      << curr_dc_metadata.last_modified
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

             ++curr_field;

@q ****** (6) |marked_for_deletion|.  @>

@ |marked_for_deletion|.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             if (curr_row[curr_field] == 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `marked_for_deletion' == 0."
                      << endl
                      << "This isn't permitted."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (curr_row[curr_field] == 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `marked_for_deletion' == " 
                      << curr_row[curr_field]
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             errno = 0;
             temp_ulong = strtoul(curr_row[curr_field], 0, 10);

             if (temp_ulong == ULONG_MAX)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' failed, returning `ULONG_MAX':"
                      << endl
                      << strerror(errno)
                      << endl 
                      << "Failed to set `curr_dc_metadata.marked_for_deletion'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong == ULONG_MAX)|  */

@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             else if (temp_ulong > 1)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' returned " << temp_ulong << " > 1"
                      << endl
                      << "Value out of range for "
                      << "`Dublin_Core_Metadata_Type::marked_for_deletion' (`bool')."
                      << endl 
                      << "Failed to set `curr_dc_metadata.marked_for_deletion'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong > 1)|  */

@q ******* (7) @>

             curr_dc_metadata.marked_for_deletion = static_cast<bool>(temp_ulong); 

#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' succeeded:"
                      << endl
                      << "`curr_dc_metadata.marked_for_deletion' == " 
                      << curr_dc_metadata.marked_for_deletion
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             ++curr_field;

@q ****** (6) |delete_file|.  @>

@ |delete_file|.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             if (curr_row[curr_field] == 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `delete_file' == 0."
                      << endl
                      << "This isn't permitted."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (curr_row[curr_field] == 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == `delete_file' == " 
                      << curr_row[curr_field]
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             errno = 0;
             temp_ulong = strtoul(curr_row[curr_field], 0, 10);

             if (temp_ulong == ULONG_MAX)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' failed, returning `ULONG_MAX':"
                      << endl
                      << strerror(errno)
                      << endl 
                      << "Failed to set `curr_dc_metadata.delete_file'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong == ULONG_MAX)|  */

@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             else if (temp_ulong > 64)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' returned " << temp_ulong << " (> 64)"
                      << endl
                      << "Value out of range for "
                      << "`Dublin_Core_Metadata_Type::delete_file' (> 64)."
                      << endl 
                      << "Failed to set `curr_dc_metadata.delete_file'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong > 64)|  */

@q ******* (7) @>

             curr_dc_metadata.delete_file = static_cast<int>(temp_ulong); 

#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' succeeded:"
                      << endl
                      << "`curr_dc_metadata.delete_file' == " 
                      << curr_dc_metadata.delete_file
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>


             ++curr_field;

@q ****** (6) |delete_from_database_timestamp_str|.  @>

@ |delete_from_database_timestamp_str|.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             if (curr_row[curr_field] == 0)
             {
#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str 
                         << "WARNING!  "
                         << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                         << endl 
                         << "`curr_row[" << curr_field << "]' == "
                         << "`delete_from_database_timestamp_str' == 0."
                         << endl
                         << "Can't set `curr_dc_metadata.delete_from_database_timestamp_str'."
                         << endl 
                         << "Will try to continue."
                         << endl;
                    unlock_cerr_mutex(); 
                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */

             }  /* |if (curr_row[curr_field] == 0)|  */

             else
             {
                curr_dc_metadata.delete_from_database_timestamp_str = curr_row[curr_field];

#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str 
                         << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                         << endl 
                         << "`curr_dc_metadata.delete_from_database_timestamp_str' == " 
                         << curr_dc_metadata.delete_from_database_timestamp_str
                         << endl;
                    unlock_cerr_mutex(); 
                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */

             }  /* |else|  */

@q ******* (7) @>

             ++curr_field;

@q ****** (6) |delete_from_database_timestamp|.  @>

@ |delete_from_database_timestamp|.
\initials{LDF 2013.11.22.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             if (curr_row[curr_field] == 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == "
                      << "`delete_from_database_timestamp' == 0."
                      << endl
                      << "This isn't permitted."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (curr_row[curr_field] == 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == "
                      << "`delete_from_database_timestamp' == " 
                      << curr_row[curr_field]
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             errno = 0;
             temp_ulong = strtoul(curr_row[curr_field], 0, 10);

             if (temp_ulong == ULONG_MAX)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' failed, returning `ULONG_MAX':"
                      << endl
                      << strerror(errno)
                      << endl 
                      << "Failed to set `curr_dc_metadata.delete_from_database_timestamp'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong == ULONG_MAX)|  */

@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             curr_dc_metadata.delete_from_database_timestamp = static_cast<time_t>(temp_ulong); 

#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' succeeded:"
                      << endl
                      << "`curr_dc_metadata.delete_from_database_timestamp' == " 
                      << curr_dc_metadata.delete_from_database_timestamp
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

             ++curr_field;

@q ****** (6) |irods_object_ref_id|.  @>

@ |irods_object_ref_id|.
\initials{LDF 2013.11.25.}

\LOG
\initials{LDF 2013.11.25.}
Added this section.
\ENDLOG

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             if (curr_row[curr_field] == 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == "
                      << "`irods_object_ref_id' == 0."
                      << endl
                      << "This isn't permitted."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (curr_row[curr_field] == 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == "
                      << "`irods_object_ref_id' == " 
                      << curr_row[curr_field]
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             errno = 0;
             temp_ulong = strtoul(curr_row[curr_field], 0, 10);

             if (temp_ulong == ULONG_MAX)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' failed, returning `ULONG_MAX':"
                      << endl
                      << strerror(errno)
                      << endl 
                      << "Failed to set `curr_dc_metadata.irods_object_ref_id'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong == ULONG_MAX)|  */

@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             curr_dc_metadata.irods_object_ref_id = temp_ulong; 

#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' succeeded:"
                      << endl
                      << "`curr_dc_metadata.irods_object_ref_id' == " 
                      << curr_dc_metadata.irods_object_ref_id
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

             ++curr_field;

@q ****** (6) |irods_object_self_id|.  @>

@ |irods_object_self_id|.
\initials{LDF 2013.11.25.}

\LOG
\initials{LDF 2013.11.25.}
Added this section.
\ENDLOG

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             if (curr_row[curr_field] == 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == "
                      << "`irods_object_self_id' == 0."
                      << endl
                      << "This isn't permitted."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (curr_row[curr_field] == 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`curr_row[" << curr_field << "]' == "
                      << "`irods_object_self_id' == " 
                      << curr_row[curr_field]
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

             errno = 0;
             temp_ulong = strtoul(curr_row[curr_field], 0, 10);

             if (temp_ulong == ULONG_MAX)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' failed, returning `ULONG_MAX':"
                      << endl
                      << strerror(errno)
                      << endl 
                      << "Failed to set `curr_dc_metadata.irods_object_self_id'."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (temp_ulong == ULONG_MAX)|  */

@q ******* (7) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             curr_dc_metadata.irods_object_self_id = temp_ulong; 

#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`strtoul' succeeded:"
                      << endl
                      << "`curr_dc_metadata.irods_object_self_id' == " 
                      << curr_dc_metadata.irods_object_self_id
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

             ++curr_field;

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

             dc_metadata_map.insert(make_pair(curr_dc_metadata.id, curr_dc_metadata));
             curr_dc_metadata.clear();


@q ****** (6) @>

        }  /* |for|  */
      

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

   sql_strm[0].str("");   
   mysql_free_result(result[0]);
   result[0] = 0;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 

       cerr << thread_str 
            << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
            << endl       
            << "`dc_metadata_map.size()' == " << dc_metadata_map.size()
            << endl;

       if (dc_metadata_map.size() > 0)
          cerr << "`dc_metadata_map':"
               << endl;

       for (map<unsigned long int, Dublin_Core_Metadata_Type>::iterator iter 
               = dc_metadata_map.begin();
            iter != dc_metadata_map.end();
            ++iter)
       {
           iter->second.show();

       }  /* |for|  */

       if (dc_metadata_map.size() > 0)
          cerr << endl;

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) |get_sub_dc_metadata == true|.  @>

@ |get_sub_dc_metadata == true|.
\initials{LDF 2013.11.25.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

   if (get_sub_dc_metadata == true)
   {
@q ****** (6) @>
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str 
                << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                << endl 
                << "`get_sub_dc_metadata' == `true'.  Will retrieve "
                << "database entries from `gwirdsif.Dublin_Core_Metadata_Sub' "
                << "and `gwirdsif.Dublin_Core_Attributes' tables."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

       sql_strm[0] << "select distinct S.dublin_core_metadata_id, S.dublin_core_metadata_sub_id, "
                   << "S.dublin_core_term_id, T.term_name, S.value, "
                   << "E.dublin_core_element_id, E.element_name "
                   << "from Dublin_Core_Metadata_Sub as S, Dublin_Core_Elements as E, "
                   << "Dublin_Core_Terms as T where S.dublin_core_metadata_id in (";

       comma_str = "";
 
       for (map<unsigned long int, Dublin_Core_Metadata_Type>::iterator iter 
               = dc_metadata_map.begin();
            iter != dc_metadata_map.end();
            ++iter)
       {
           sql_strm[0] << comma_str << iter->second.id;

           comma_str = ", ";

       }  /* |for|  */

       sql_strm[0] << ") and S.dublin_core_metadata_sub_id > 0 "
                   << "and S.dublin_core_element_id = E.dublin_core_element_id "
                   << "and S.dublin_core_term_id = T.dublin_core_term_id "
                   << "order by S.dublin_core_metadata_id, S.dublin_core_metadata_sub_id";

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str 
                << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                << endl 
                << "`sql_strm[0].str()' == " << sql_strm[0].str()
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */        

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

        status = submit_mysql_query(sql_strm[0].str(), result[0], mysql_ptr, &row_ctr, &field_ctr);

        if (status != 0)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "ERROR!  "
                 << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                 << endl
                 << "`submit_mysql_query' failed, returning " << status << ":"
                 << endl 
                 << "Error:  " << mysql_error(mysql_ptr)
                 << endl 
                 << "Error number:  " << mysql_errno(mysql_ptr)
                 << endl 
                 << "Failed to select Dublin Core metadata from the "
                 << "`gwirdsif.Dublin_Core_Metadata' database table." 
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
             unlock_cerr_mutex(); 

             if (result[0])
                mysql_free_result(result[0]);

             return 1;

        }  /* |if (status != 0)|  */

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':" 
                 << endl
                 << "`submit_mysql_query' succeeded, returning 0."
                 << endl
                 << "`row_ctr' == " << row_ctr
                 << endl
                 << "`field_ctr' == " << field_ctr
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        if (row_ctr == 0)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "WARNING!  "
                 << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':" 
                 << endl
                 << "`row_ctr' == 0"
                 << endl 
                 << "Failed to retrieve rows from `gwirdsif.Dublin_Core_Metadata_Sub' "
                 << "database table."
                 << endl
                 << "This should never happen.  Will try to continue."
                 << endl
                 << "Skipping to `END_GET_DC_METADATA'."
                 << endl;
            unlock_cerr_mutex(); 

            goto END_GET_DC_METADATA;

        }  /* |if (row_ctr == 0)|  */


@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

        Dublin_Core_Metadata_Sub_Type dcm_sub;

        multimap<unsigned long int, Dublin_Core_Metadata_Sub_Type> dcm_sub_map;

        map<unsigned long int, Dublin_Core_Metadata_Type>::iterator iter;

        int i = 0;

        for (int i = 0; i < row_ctr; ++i)
        {
@q ******* (7) @>

             curr_row = mysql_fetch_row(result[0]);

             if (curr_row == 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  "
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`mysql_fetch_row' failed:"
                      << endl
                      << mysql_error(mysql_ptr)
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (curr_row == 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`mysql_fetch_row' succeeded."
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

             dcm_sub.clear();

             status = dcm_sub.set(mysql_ptr, curr_row, database, thread_str);

             if (status != 0)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "ERROR!  "
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`Dublin_Core_Metadata_Sub_Type::set' failed, returning "
                      << status << "."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 mysql_free_result(result[0]);

                 return 1;

             }  /* |if (status != 0)|  */

@q ******** (8) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`Dublin_Core_Metadata_Sub_Type::set' succeeded, returning 0."
                      << endl;

                 dcm_sub.show("dcm_sub:");

                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */                  

@q ******* (7) @>

             iter = dc_metadata_map.find(dcm_sub.metadata_id);

             if (iter != dc_metadata_map.end() && (dcm_sub.element_id > 0 || dcm_sub.term_id > 0))
             {
                 temp_val = dcm_sub.element_id;

                 if (temp_val == 0)
                     temp_val = dcm_sub.term_id;

                 iter->second.metadata_sub_map.insert(make_pair(temp_val, dcm_sub));
             }
             else
             {
                 lock_cerr_mutex(); 
                 cerr << thread_str 
                      << "WARNING!  "
                      << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                      << endl 
                      << "`Dublin_Core_Metadata_Sub_Type dcm_sub' has `element_id' == 0 "
                      << "and `term_id' == 0:"
                      << endl;

                 dcm_sub.show("dcm_sub:");

                 cerr << "This shouldn't ever happen."
                      << endl
                      << "Not inserting `dcm_sub' into `iter->second.metadata_sub_map."
                      << endl
                      << "Inserting it into (local) `dcm_sub_map' instead."
                      << endl
                      << "Continuing."
                      << endl;
                 unlock_cerr_mutex(); 

                dcm_sub_map.insert(make_pair(dcm_sub.metadata_id, dcm_sub));

             }

@q ******* (7) @>

        }  /* |for|  */

@q ****** (6) @>
@
@:TODO@> !! TODO: Get qualifiers in a separate step.  However, qualifiers are not currently 
being used.  Qualifiers are inserted into the \.{Dublin\_Core\_Qualifiers} table ``by hand''.
I am somewhat confused by the terminology.  I'm going to have to go over the code
for handling Dublin Core metadata.  However, it would only pay to do this if the package
is actually going to be used.
\initials{LDF 2013.12.16.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

@q ****** (6) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 

            cerr << thread_str 
                 << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                 << endl 
                 << "`dc_metadata_map.size() == " << dc_metadata_map.size()
                 << endl;

            if (dc_metadata_map.size() > 0)
               cerr << "`dc_metadata_map':"
                    << endl;
            
            for (map<unsigned long int, Dublin_Core_Metadata_Type>::iterator iter 
                    = dc_metadata_map.begin();
                 iter != dc_metadata_map.end();
                 ++iter)
            {
                iter->second.show();
            }


            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex();
            cerr << thread_str 
                 << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                 << endl  
                 << "`dcm_sub_map.size()' == " << dcm_sub_map.size()
                 << endl;

            if (dcm_sub_map.size() > 0)
               cerr << "`dcm_sub_map':"
                    << endl;
            
            for (map<unsigned long int, Dublin_Core_Metadata_Sub_Type>::iterator iter 
                    = dcm_sub_map.begin();
                 iter != dcm_sub_map.end();
                 ++iter)
            {
                cerr << iter->first << ":" << endl;
                iter->second.show();
            }


            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>

   }  /* |if (get_sub_dc_metadata == true)|  */


@q ***** (5) |get_sub_dc_metadata == false|.  @>

@ |get_sub_dc_metadata == false|.
\initials{LDF 2013.11.25.}

@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

   else /* |get_sub_dc_metadata == false|  */
   {

#if DEBUG_COMPILE
       if (DEBUG)    
       {
           lock_cerr_mutex(); 
           cerr << thread_str 
                << "In `Dublin_Core_Metadata_Type::get_dc_metadata_from_database':"
                << endl 
                << "`get_sub_dc_metadata' == `false'.  Not retrieving "
                << "database entries from `gwirdsif.Dublin_Core_Metadata_Sub' "
                << "and `gwirdsif.Dublin_Core_Attributes' tables."
                << endl;
            unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |else| (|get_sub_dc_metadata == false|)  */

@q ***** (5) @>
@
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>=

END_GET_DC_METADATA:

   for (int i = 0; i < sql_ctr; ++i)
   {
      if (result[i])
         mysql_free_result(result[i]);

      result[i] = 0;
   }

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Exiting `Dublin_Core_Metadata_Type::get_dc_metadata_from_database' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition  */



@q *** (3) Putting `dcmtdttp.web' together.  @>

@ Putting {\tt dcmtdttp\PERIOD web} together.

@q **** (4) This is what's compiled.  @>
@ This is what's compiled.
@c
@<Include files@>@;@/
using namespace std;
using namespace gwrdifpk;
@<Preprocessor macro definitions@>@;@/
@<File-local variables@>@;@/
class Scan_Parse_Parameter_Type;
class Dublin_Core_Metadata_Type;

@<|class Dublin_Core_Metadata_Type| declaration@>@;@/
@<Initialize |static| |Dublin_Core_Metadata_Type| data members@>@;@/
@<|Dublin_Core_Metadata_Type| constructor definition@>@;@/
@<|Dublin_Core_Metadata_Type::set| definition@>@;@/
@<|Dublin_Core_Metadata_Type| destructor definition@>@;@/
@<|Dublin_Core_Metadata_Type::clear| definition@>@;@/
@<|Dublin_Core_Metadata_Type::operator==| definition@>@;@/
@<|Dublin_Core_Metadata_Type::show| definition@>@;@/
@<|Dublin_Core_Metadata_Type::initialize_maps| definition@>@;@/
@<|Dublin_Core_Metadata_Type::output| definition@>@;@/
@<|Dublin_Core_Metadata_Type::parse| definition@>@;@/
@<|Dublin_Core_Metadata_Type::start| definition@>@;@/
@<|Dublin_Core_Metadata_Type::end| definition@>@;@/
@<|Dublin_Core_Metadata_Type::handle_data| definition@>@;@/
@<|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| definition@>@;@/
@<|Dublin_Core_Metadata_Type::set_handle_id| definition@>@;@/
@<|Dublin_Core_Metadata_Type::mark_dc_metadata_for_deletion| definition@>@;@/
@<|Dublin_Core_Metadata_Type::undelete_dc_metadata| definition@>@;@/
@<|Dublin_Core_Metadata_Type::get_dc_metadata_from_database| definition@>@;@/


@q **** (4) This is what's written to the header file `dcmtdttp.h'.  @>

@ This is what's written to the header file \filename{dcmtdttp.h}.
@
@(dcmtdttp.h@>=
#ifndef DCMTDTTP_H
#define DCMTDTTP_H 1
using namespace std;
using namespace gwrdifpk;
class Scan_Parse_Parameter_Type;
class Dublin_Core_Metadata_Type;

@<|class Dublin_Core_Metadata_Type| declaration@>@;@/
#endif 

@q * (1) Emacs-Lisp code for use in indirect buffers  @>

@q (progn (cweb-mode) (outline-minor-mode))                          @>

@q * (1) Local variables for Emacs @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q abbrev-mode:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>
