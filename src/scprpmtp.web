@q scprpmtp.web  @>
@q Created by Laurence D. Finston (LDF) Wed Jun 27 11:35:23 CEST 2012  @>

@q * (1) Copyright and License.@>

@q This file is part of gwrdifpk, a package for long-term archiving.  @>
@q Copyright (C) 2013, 2014 Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen @>

@q gwrdifpk is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q gwrdifpk is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License          @>
@q along with gwrdifpk; if not, write to the Free Software                    @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q gwrdifpk is available for downloading via Git from @>
@q https://github.com/gwdg/gwrdifpk.git    @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gwdg.de@>

@q Laurence D. Finston                                                   @>
@q Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen  @>
@q Am Fassberg 11         					         @>
@q 37077 Goettingen              					 @>
@q Germany                           					 @>                                

@q Laurence.Finston@@gwdg.de (@@ stands for a single "at" sign.)@>

@q ** (2)  scprpmtp.web  @>
@* {\bf Scan\_Parse\_Parameter\_Type}.

@f Scan_Parse_Parameter_Type int

@q ** (2) Include files  @>

@ Include files.

@<Include files@>=

#ifndef _GNU_SOURCE
#define _GNU_SOURCE         
#endif 

#include <stdlib.h>  /* Standard Library for C  */
#include <stdio.h>
#include <sys/mman.h>
#include <errno.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <limits.h>
#include <pwd.h>

#include <string.h>

#include <algorithm> /* Standard Template Library (STL) for C++  */
#include <bitset> 
#include <fstream> 
#include <iomanip>
#include <ios>
#include <iostream>
#include <map>
#include <string>
#include <time.h>
#include <math.h>
#include <sstream>  

#include <vector>
#include <deque>
#include <stack>
#include <set>

#include <pthread.h>  /* POSIX threads  */

#include <gcrypt.h> /* for |gcry_control| */
#include <gnutls/gnutls.h>
#include <gnutls/x509.h>

#include <mysql.h>
#include <errmsg.h>

#include <expat.h>

#if HAVE_CONFIG_H
#include <config.h>
#endif 

#undef NAME_LEN
#undef LOCAL_HOST

#include "rspercds.h++"
#include "glblcnst.h++"
#include "glblvrbl.h++"
#include "excptntp.h++"
#include "utilfncs.h++"
#include "grouptp.h++"
#include "hndlvltp.h++"
#include "irdsavtp.h++"
#include "helper.h++"
#include "tanfncs.h++"
#include "pidfncs.h++"
#include "parser.h++"
#include "scanner.h++"
#include "rspnstp.h++"
#include "irdsobtp.h++"
#include "hndltype.h++"
#include "dcmdsbtp.h++"
#include "dcmtdttp.h++"
#include "x509cert.h++"
#include "dstngnmt.h++"
#include "usrinftp.h++"
#include "pullrqtp.h++"
#include "pullpttp.h++"
#include "pullrstp.h++"

@q ** (2) @>
@
@<External function declarations@>=
int 
yyparse(yyscan_t parameter);

@q ** (2) Scan_Parse_Parameter_Type. @>

@ {\bf Scan\_Parse\_Parameter\_Type}.
\initials{LDF 2012.06.27.}


\LOG
\initials{LDF 2012.07.04.}
Added |friend| declaration for |yyparse|.  Added |bool PARSER_DEBUG|.

\initials{LDF 2012.07.05.}
Added |fstream response_strm|.

\initials{LDF 2012.07.11.}
Added |string Distinguished_Name| and |string username|.
%
Added |int user_id|.  It's initialized to $-1$ in the constructor and set in 
|Scan_Parse_Parameter_Type::get_user|.
%
Added |string irods_password_encrypted|, |string homedir|, |string zone|
and |string default_resource|.
They're set in |Scan_Parse_Parameter_Type::get_user|.

\initials{LDF 2012.07.13.}
Added |int thread_ctr|.  It's set to $-1$ in the constructor.

\initials{LDF 2012.07.27.}
Added the data members |string data_filename| and 
|char data_buffer[BUFFER_SIZE]|.

\initials{LDF 2012.07.30.}
Added the private data member |deque<Response_Type> response_deque|.

\initials{LDF 2012.07.30.}
Removed |fstream response_strm|.

\initials{LDF 2012.09.12.}
Added data member |string irods_password_encrypted_timestamp|.

\initials{LDF 2012.09.20.}
Added data members |gnutls_session_t session| and |bool remote_connection|.

\initials{LDF 2012.09.21.}
Added data member |bool anonymous|.  Added |friend| declarations for 
|listen_local|, |listen_remote_anon| and |listen_remote_X_509|.

\initials{LDF 2012.09.27.}
Added data member |string icommands_flag_str|.

\initials{LDF 2012.09.27.}
Added the private data member |vector<string> filename_vector|.

\initials{LDF 2012.09.28.}
Added the private data members |string pid_str|,
|string pid_suffix| and |string pid_institute_str|.

\initials{LDF 2012.10.08.}
Added the private data members |string pid_prefix_str|,
|unsigned int default_handle_prefix_id| and |string default_handle_prefix|.

\initials{LDF 2012.10.08.}
Added the private data members |unsigned int default_institute_id|
and |string default_institute_name|.

\initials{LDF 2012.10.16.}
Added |Handle_Value_Type handle|.  It's used in |zzparse|.   

\initials{LDF 2012.10.17.}
Changed the names of the |string| variables |homedir|, |zone|, |default_resource|
and |current_dir| to 
|irods_homedir|, |irods_zone|, |irods_default_resource| and |irods_current_dir|, 
respectively.

\initials{LDF 2012.11.22.}
Added |map<unsigned int, Response_Type> response_map|.

\initials{LDF 2012.11.22.}
Added |pthread_mutex_t response_map_mutex|.

\initials{LDF 2013.03.22.}
Added |string irods_auth_filename| and |string irods_env_filename|.

\initials{LDF 2013.04.03.}
Added the private data members |deque<Response_Type> pending_response_deque|,
|bool pending_operations_flag| and 
|deque<Response_Type>::iterator pending_operations_iter|.

\initials{LDF 2013.04.25.}
Removed data member |string icommands_flag_str|.

\initials{LDF 2013.05.10.}
Removed data member |string Distinguished_Name|.

\initials{LDF 2013.05.17.}
Added the data members |User_Info_Type *user_info_ptr|.

\initials{LDF 2013.05.17.}
Added data member |Distinguished_Name_Type distinguished_name|.

\initials{LDF 2013.05.19.}
Added member function |set_user_info|.

\initials{LDF 2013.05.22.}
Added |friend| declarations for |distinguished_name_rule_func| and |get_user_info_func|.

\initials{LDF 2013.05.22.}
Added data members |map<string, int> user_id_map| 
and |map<int, User_Info_Type> user_info_map|.

\initials{LDF 2013.05.24.}
Renamed |deque<Response_Type> pending_response_deque| to |delayed_response_deque|

\initials{LDF 2013.06.16.}
Added |Handle_Value_Triple hvt|.  It's used in |yyparse|.

\initials{LDF 2013.07.11.}
Added |string input_commands|.  It's used by \.{gwirdcli} only and set by the command-line option
\.{--commands}. 

\initials{LDF 2013.08.07.}
Added |friend| declaration for |yylex|.

\initials{LDF 2013.08.09.}
Added |unsigned long delay_value|.  It's used in |yyparse|.

\initials{LDF 2013.09.04.}
Added |friend| declaration for |create_databases|.

\initials{LDF 2013.09.20.}
Added |string public_key_id|.

\initials{LDF 2014.01.10.}
Changed name of |string public_key_id| to |gpg_key_id|.

\initials{LDF 2014.01.10.}
Added the private data member |string temp_gpg_key_id|.

\initials{LDF 2014.01.13.}
Changed the name of |string temp_gpg_key_id| to  |temp_gpg_key_fingerprint|.

\initials{LDF 2014.01.13.}
Added |unsigned int gpg_key_pair_id|.

\initials{LDF 2014.01.31.}
Added |friend| declarations for |pull_response| and |pull_client_func|.
\ENDLOG 

@q *** (3) Declaration  @>
 
@<|class Scan_Parse_Parameter_Type| declaration@>=

class Scan_Parse_Parameter_Type
{
@q **** (4) @>

   friend int create_databases(Scan_Parse_Parameter_Type &param);

   friend int Irods_Object_Type::get_avus_from_irods_system(string command,
                                          string filename, 
                                          Scan_Parse_Parameter_Type &param, int *ctr);

   friend int main(int, char **);

   friend void* listen_local(void *v);
   friend void* listen_remote_anon(void *v);
   friend void* listen_remote_X_509(void *v);

   friend void* pull_response(void* v);

   friend int pull_client_func (Scan_Parse_Parameter_Type &param, string distinguished_name_str);

   friend void* connect_func(void* v);

   friend int yyparse(yyscan_t parameter);
   friend int yylex(YYSTYPE*, yyscan_t);

   friend int client_func(Scan_Parse_Parameter_Type &param);

   friend int parse_post_data(Scan_Parse_Parameter_Type &param);

   friend int exchange_data_with_server (Scan_Parse_Parameter_Type &param);
   friend int exchange_data_with_client(Scan_Parse_Parameter_Type &param);

   friend int client_sending_file_rule_func(Scan_Parse_Parameter_Type *param, 
                                            string filename, 
                                            int reference,
                                            unsigned int options);

   friend int distinguished_name_rule_func(Scan_Parse_Parameter_Type*, const char*);

   friend int get_user_info_func(Scan_Parse_Parameter_Type*, const char*);

   int sock;

   gnutls_session_t session;

   bool remote_connection;
   bool anonymous;

   unsigned int connection_type;

   bool PARSER_DEBUG;

   MYSQL *mysql_ptr;

   Distinguished_Name_Type distinguished_name;

   int user_id;

   string username;

   vector<Group_Type> group_vector;

   unsigned int privileges;  /* On \.{pcfinston.gwdg.de}, this allows the definition of
                                32 privileges.
                                \initials{LDF 2013.05.17.}  */

   string irods_auth_filename; 

   string irods_env_filename;

   string irods_password_encrypted;

   string irods_password_encrypted_timestamp;

   string irods_homedir;

   string irods_current_dir;

   string irods_zone;

   string irods_default_resource;

   int thread_ctr;

   time_t expires;

   string data_filename;
   char data_buffer[BUFFER_SIZE];

   string input_commands;

   deque<Response_Type> response_deque;
 
   deque<Response_Type> delayed_response_deque;

   bool pending_operations_flag;

   deque<Response_Type>::iterator pending_operations_iter;

   map<unsigned int, Response_Type> response_map;
   pthread_mutex_t response_map_mutex;

   bool client_finished;
   bool server_finished; 

   vector<string> filename_vector;

   /* These are set by |Scan_Parse_Parameter_Type::get_user| (server-side only).
      \initials{LDF 2012.10.08.}  */

   unsigned int default_handle_prefix_id;  
   string       default_handle_prefix;

   unsigned int default_institute_id;  
   string       default_institute_name;

   /* These are used in the parser.  \initials{LDF 2012.10.08.}  */

   string pid_str;             
   string pid_prefix_str;
   string pid_suffix_str;
   string pid_institute_str;

   string temp_gpg_key_fingerprint;

   unsigned long delay_value;
  
   Handle_Value_Triple hvt;


   map<string, int> user_id_map;
   map<int, User_Info_Type> user_info_map;


   Handle_Value_Type handle_value;

   User_Info_Type *user_info_ptr;  /* Used in |zzparse|  \initials{LDF 2013.05.17.}  */

@q **** (4) @>

@ |Irods_Object_Type *irods_object| is used in the client-side parser |zzparse|
for collecting data sent by the server.  Currently, these are just the
user-defined metadata (a.k.a.~AVUs) and the filename.  So far, I've just been
using simple filenames, i.e., not the complete path.  The object is created
(with |new|) in the rule ``\<avu list> $\longrightarrow$ \.{Empty}''
and and deleted and set to 0 in the rule
``\<statement> $\longrightarrow$ \.{GET\_ZZ} \.{METADATA\_ZZ} \.{RESPONSE\_ZZ} 
\.{STRING\_ZZ} \.{INTEGER\_ZZ} \.{INTEGER\_ZZ} \<avu list>''.
\par
The objects pointed to by |irods_object| are pushed onto 
|map<Irods_Object_Type> irods_object_vector|, so the latter contains
a collection of |Irods_Object_Type| objects that have been retrieved during
a run of the program.  
\par
@^Handle System@>
@:TODO@> !! TODO:  It would be possible to store them in a database.  In this
case, I should use an expiration time, as the Handle System does for handles.
\par
@:TODO@> !! TODO:  Maybe use a |map| with the PID as the key.
\initials{LDF 2012.10.12.}

@q ***** (5) @>

\LOG
\initials{LDF 2012.11.16.}
Added |vector<string> temp_file_vector|.  It replaces the global variable of 
the same type and name.  The temporary files will be deleted in the destructor
for |Scan_Parse_Parameter_Type|.  This ensures that temporary files that are still
needed in a  running thread won't be deleted.

\initials{LDF 2012.11.19.}
Added |unsigned int errors_occurred| and |unsigned int warnings_occurred|.

\initials{LDF 2013.01.07.}
Working on |Irods_Object_Type|.  Added data members.  Added corresponding 
database table \.{gwirdsif.Irods\_Objects}.  See \filename{irdsobtp.web} and 
\filename{archobjs.sql}.

\initials{LDF 2013.04.25.}
Added |int thread_cancel_state|.  It is initialized to |PTHREAD_CANCEL_ENABLE| in the default 
constructor (as of this date,  the only constructor).

\initials{LDF 2013.04.25.}
Added |vector<string> string_vector|.  It's used in |yyparse|.

\initials{LDF 2013.05.08.}
Added |X509_Cert_Type user_cert| and |X509_Cert_Type ca_cert|.

\initials{LDF 2013.05.27.}

\initials{LDF 2013.05.27.}
Added the |static| maps |server_action_map|, 
|client_action_map|,
|server_action_name_map|
and
|client_action_name_map|.

\initials{LDF 2013.12.06.}
Added |vector<int> int_vector|.  It's used in the server-side parser (|yyparse|).

\initials{LDF 2014.01.13.}
Changed name of |string gpg_key_id| to |gpg_key_fingerprint|.

\initials{LDF 2014.02.14.}
Added |unsigned int notices_occurred|.
\ENDLOG 

@q **** (4) @>

@<|class Scan_Parse_Parameter_Type| declaration@>=

   Irods_Object_Type *irods_object;  

   vector<Irods_Object_Type> irods_object_vector;  

   vector<string> temp_file_vector;

   vector<string> string_vector;
   vector<int>    int_vector;

   unsigned int errors_occurred;
   unsigned int warnings_occurred;
   unsigned int notices_occurred;

   typedef int (Scan_Parse_Parameter_Type::*func_ptr)(Response_Type &);

   static map<unsigned int, func_ptr> server_action_map;
   static map<unsigned int, func_ptr> client_action_map;

   static map<unsigned int, string> server_action_name_map;
   static map<unsigned int, string> client_action_name_map;

   int thread_cancel_state;

   X509_Cert_Type user_cert;     /* Used by server  */

   X509_Cert_Type server_cert;   /* Used by client  */

   X509_Cert_Type ca_cert;       /* Currently not used.  \initials{LDF 2013.05.10.}  */

   X509_Cert_Type *cert_ptr;     /* Used in |zzparse|.  \initials{LDF 2013.05.15.}  */

   unsigned int gpg_key_pair_id;

   string gpg_key_fingerprint;

@q **** (4) @>
@
\LOG
\initials{LDF 2013.05.08.}
Added definition of |get_thread_ctr|.

\initials{LDF 2013.05.10.}
Added the following |static| constants:
|NULL_AUTH_TYPE|, |LOCAL_NULL_AUTH_TYPE|, |X_509_AUTH_TYPE| and |ANON_AUTH_TYPE|.

\initials{LDF 2013.05.16.}
Added the following |static| constants:
|SUPERUSER_PRIVILEGE|, |DELEGATE_PRIVILEGE|, |SHOW_CERTIFICATES_PRIVILEGE|, 
|SHOW_DISTINGUISHED_NAMES_PRIVILEGE| and |SHOW_PRIVILEGES_PRIVILEGE|.

\initials{LDF 2013.05.17.}
Added |static unsigned int SHOW_USER_INFO_PRIVILEGE|.

\initials{LDF 2013.06.05.}
Added |static unsigned int SHOW_GROUPS_PRIVILEGE|.

\initials{LDF 2013.07.04.}
Added |static unsigned int DELETE_HANDLES_PRIVILEGE|.

\initials{LDF 2013.09.12.}
Added the |static unsigned int| constants 
|DELETE_HANDLE_VALUES_PRIVILEGE|,
|DELETE_HS_ADMIN_HANDLE_VALUES_PRIVILEGE|,
|DELETE_LAST_HS_ADMIN_HANDLE_VALUE_PRIVILEGE|
and 
|UNDELETE_HANDLE_VALUES_PRIVILEGE|.
Made the other |static unsigned int| variables for privileges and authorization type 
constants, too.

\initials{LDF 2014.02.03.}
Added the |static unsigned int| constants 
|PULL_REQUEST_SELF_PRIVILEGE|,
|PULL_REQUEST_GROUP_PRIVILEGE| and
|PULL_REQUEST_ALL_PRIVILEGE|.

\initials{LDF 2014.02.18.}
Added the |static const unsigned int| constants 
|ADD_GROUPS_PRIVILEGE|,
|DELETE_GROUPS_PRIVILEGE|, 
|PULL_RESPONSE_SELF_PRIVILEGE|,
|PULL_RESPONSE_GROUP_PRIVILEGE| and
|PULL_RESPONSE_ALL_PRIVILEGE|.
\ENDLOG 

@q ***** (5) @>

@<|class Scan_Parse_Parameter_Type| declaration@>=

   public:

      @<|Scan_Parse_Parameter_Type| function declarations@>@;

      int get_pids(string s, int *ctr = 0) { return get_metadata(s, 1, ctr); }

      int get_thread_ctr(void) { return thread_ctr; }

   static const unsigned int NULL_AUTH_TYPE;
   static const unsigned int LOCAL_NULL_AUTH_TYPE;
   static const unsigned int X_509_AUTH_TYPE;
   static const unsigned int ANON_AUTH_TYPE;

   /* On \.{pcfinston.gwdg.de}, 32 privileges are allowed (|sizeof(unsigned int) * 8|).
      \initials{LDF 2013.05.17.}  */ 

   static const unsigned int SUPERUSER_PRIVILEGE;                   
   static const unsigned int DELEGATE_PRIVILEGE;         
   static const unsigned int ADD_GROUPS_PRIVILEGE;         
   static const unsigned int DELETE_GROUPS_PRIVILEGE;         
   static const unsigned int DELETE_HANDLES_PRIVILEGE;
   static const unsigned int DELETE_HANDLE_VALUES_PRIVILEGE;
   static const unsigned int DELETE_HS_ADMIN_HANDLE_VALUES_PRIVILEGE;
   static const unsigned int DELETE_LAST_HS_ADMIN_HANDLE_VALUE_PRIVILEGE;
   static const unsigned int UNDELETE_HANDLE_VALUES_PRIVILEGE;
   static const unsigned int SHOW_USER_INFO_PRIVILEGE;
   static const unsigned int SHOW_GROUPS_PRIVILEGE;
   static const unsigned int SHOW_CERTIFICATES_PRIVILEGE;
   static const unsigned int SHOW_DISTINGUISHED_NAMES_PRIVILEGE;
   static const unsigned int SHOW_PRIVILEGES_PRIVILEGE;

   static const unsigned int PULL_REQUEST_SELF_PRIVILEGE;
   static const unsigned int PULL_REQUEST_GROUP_PRIVILEGE;
   static const unsigned int PULL_REQUEST_ALL_PRIVILEGE;

   static const unsigned int PULL_RESPONSE_SELF_PRIVILEGE;
   static const unsigned int PULL_RESPONSE_GROUP_PRIVILEGE;
   static const unsigned int PULL_RESPONSE_ALL_PRIVILEGE;

};


@q *** (3) Initialize |Scan_Parse_Parameter_Type| static data members.  @>

@ Initialize |Scan_Parse_Parameter_Type| static data members.
\initials{LDF 2013.05.10.}

\LOG
\initials{LDF 2013.05.10.}
Added this section.
\ENDLOG

@<Initialize |Scan_Parse_Parameter_Type| static data members@>=

   const unsigned int Scan_Parse_Parameter_Type::NULL_AUTH_TYPE       = 0;
   const unsigned int Scan_Parse_Parameter_Type::LOCAL_NULL_AUTH_TYPE = 1;
   const unsigned int Scan_Parse_Parameter_Type::X_509_AUTH_TYPE      = 2;
   const unsigned int Scan_Parse_Parameter_Type::ANON_AUTH_TYPE       = 3;

   /* On \.{pcfinston.gwdg.de}, 32 privileges are allowed (|sizeof(unsigned int) * 8|).
      \initials{LDF 2013.05.17.}  */ 

   const unsigned int Scan_Parse_Parameter_Type::SUPERUSER_PRIVILEGE                         
      = 1U;  /* $2^0$  */

   const unsigned int Scan_Parse_Parameter_Type::DELEGATE_PRIVILEGE                          
      = 2U;  /* $2^1$  */

   const unsigned int Scan_Parse_Parameter_Type::ADD_GROUPS_PRIVILEGE
      = 4U;  /* $2^2$  */

   const unsigned int Scan_Parse_Parameter_Type::DELETE_GROUPS_PRIVILEGE         
      = 8U;  /* $2^3$  */

   const unsigned int Scan_Parse_Parameter_Type::DELETE_HANDLES_PRIVILEGE                    
      = 16U; /* $2^4$  */

   const unsigned int Scan_Parse_Parameter_Type::DELETE_HANDLE_VALUES_PRIVILEGE              
      = 32U;  /* $2^5$  */

   const unsigned int Scan_Parse_Parameter_Type::DELETE_HS_ADMIN_HANDLE_VALUES_PRIVILEGE     
      = 64U;  /* $2^6$  */

   const unsigned int Scan_Parse_Parameter_Type::DELETE_LAST_HS_ADMIN_HANDLE_VALUE_PRIVILEGE 
      = 128U; /* $2^7$  */

   const unsigned int Scan_Parse_Parameter_Type::UNDELETE_HANDLE_VALUES_PRIVILEGE
      = 256U;  /* $2^8$  */

   const unsigned int Scan_Parse_Parameter_Type::SHOW_USER_INFO_PRIVILEGE                    
      = 512U; /* $2^9$  */

   const unsigned int Scan_Parse_Parameter_Type::SHOW_GROUPS_PRIVILEGE                       
      = 1024U; /* $2^{10}$  */

   const unsigned int Scan_Parse_Parameter_Type::SHOW_CERTIFICATES_PRIVILEGE                 
      = 2048U;  /* $2^{11}$  */

   const unsigned int Scan_Parse_Parameter_Type::SHOW_DISTINGUISHED_NAMES_PRIVILEGE          
      = 4096U; /* $2^{12}$  */

   const unsigned int Scan_Parse_Parameter_Type::SHOW_PRIVILEGES_PRIVILEGE                   
      = 8192U;  /* $2^{13}$  */

   const unsigned int Scan_Parse_Parameter_Type::PULL_REQUEST_SELF_PRIVILEGE  
      = 16384U;  /* $2^{14}$  */

   const unsigned int Scan_Parse_Parameter_Type::PULL_REQUEST_GROUP_PRIVILEGE 
      = 32768U;  /* $2^{15}$  */

   const unsigned int Scan_Parse_Parameter_Type::PULL_REQUEST_ALL_PRIVILEGE   
      = 65536U;  /* $2^{16}$  */

   const unsigned int Scan_Parse_Parameter_Type::PULL_RESPONSE_SELF_PRIVILEGE  
      = 131072U;  /* $2^{17}$  */

   const unsigned int Scan_Parse_Parameter_Type::PULL_RESPONSE_GROUP_PRIVILEGE 
      = 262144U;  /* $2^{18}$  */

   const unsigned int Scan_Parse_Parameter_Type::PULL_RESPONSE_ALL_PRIVILEGE   
      = 524288U;  /* $2^{19}$  */

   typedef int (Scan_Parse_Parameter_Type::*func_ptr)(Response_Type &);

   map<unsigned int, func_ptr> Scan_Parse_Parameter_Type::server_action_map;
   map<unsigned int, func_ptr> Scan_Parse_Parameter_Type::client_action_map;

   map<unsigned int, string> Scan_Parse_Parameter_Type::server_action_name_map;
   map<unsigned int, string> Scan_Parse_Parameter_Type::client_action_name_map;

@q *** (3) |Scan_Parse_Parameter_Type| functions.@>
@ {\bf Scanner\_Type} functions.
\initials{LDF 2012.06.27.}

@q **** (4) Default constructor.  @>
@ Default constructor.
\initials{LDF 2012.06.27.}

\LOG
\initials{LDF 2012.06.27.}
Added this function.

\initials{LDF 2012.07.10.}
Added code for instantiating an |IrodsAccess| object.

\initials{LDF 2012.11.19.}
Now initializing |unsigned int errors_occurred| and 
|unsigned int warnings_occurred| to 0.

\initials{LDF 2013.04.25.}
Now initializing |thread_cancel_state| to |PTHREAD_CANCEL_ENABLE|.

\initials{LDF 2013.08.09.}
@:BUG FIX@> BUG FIX:  Added code for calling |mysql_real_connect| and |mysql_select_db|
in loops:  If either call fails, it's repeated up to 5 times.  If the sixth attempt fails,
the function calls |pthread_exit|.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

Scan_Parse_Parameter_Type(void);

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type| constructor definitions@>=

Scan_Parse_Parameter_Type::Scan_Parse_Parameter_Type(void)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG, 0, 0); 

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "Entering `Scan_Parse_Parameter_Type' default constructor."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    int status;

    thread_ctr = 0;
    user_id = -1;

    privileges = gpg_key_pair_id = 0U;

    expires = 0;

    sock = 0;
    PARSER_DEBUG = false;

    client_finished = false;
    server_finished = false; 

    remote_connection = false;
    anonymous         = false;

    connection_type = 0U;

    default_handle_prefix_id = 0;
    default_institute_id     = 0;

    delay_value = 0UL;

    cert_ptr = 0;

    user_info_ptr = 0;

    memset(data_buffer, 0, BUFFER_SIZE);

    irods_object = 0;

    errors_occurred   = warnings_occurred = notices_occurred = 0;

    thread_cancel_state = PTHREAD_CANCEL_ENABLE;

    bool failed = false;

@q ****** (6) @>
@
\LOG
\initials{LDF 2012.07.10.}
Added this section.

\initials{LDF 2012.09.18.}
Now only calling |setup_java_vm| and the MySQL functions if |is_gwirdsif == true|.
Neither the Java VM nor the MySQL database are needed at this time for |gwirdcli|
or |gwrdwbap|.  However, it's not possible to compile the conditionally, because
the same object file is used for all three programs.  I prefer it this way and don't
want to change it.  I don't see any reason to supply a ``client-only'' version of the
package, especially considering that the necessary libraries are easily available.

\initials{LDF 2013.04.26.}
Now connecting to the database if |!is_gwirdsif|, i.e., also if this 
function is called on the client-side.  Now using the \.{gwirdcli} database 
on the client-side.  In this case, |getpwuid_r| is called to retrieve the 
user name, which is used as the database user name, too.
\ENDLOG

@<|Scan_Parse_Parameter_Type| constructor definitions@>=


    mysql_ptr = mysql_init(0);

    if (mysql_ptr)
    {
       if (DEBUG)
       {
          lock_cerr_mutex(); 
          cerr << "In `Scan_Parse_Parameter_Type' constructor:  " 
               << "`mysql_init' succeeded."
               << endl;
          unlock_cerr_mutex();

       }  /* |if (DEBUG)|  */ 

    }  /* |if (mysql_ptr)| */

    else
    {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Scan_Parse_Parameter_Type' constructor:" 
            << endl
            << "`mysql_init' failed.  Exiting thread unsuccessfully with "
            << "return value 0."
            << endl;
       unlock_cerr_mutex();
 
       pthread_exit(0);

    }   

@q ******* (7) Set |mysql_socket_filename|.  @>
@ Set |mysql_socket_filename|.  
\initials{LDF 2012.09.07.}

\LOG
\initials{LDF 2012.09.07.}
Added this section.  It's needed, because the name of the socket file for 
the MySQL server is platform-dependent.
\ENDLOG

@<|Scan_Parse_Parameter_Type| constructor definitions@>=

    string mysql_socket_filename;

    errno = 0;

    status = access("/var/run/mysql/mysql.sock", F_OK);

@q ******** (8) @>

    if (status == -1)
    {  

@q ********* (9) @>

#if DEBUG_COMPILE
         if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "In `Scan_Parse_Parameter_Type' constructor:" 
                  << endl
                  << "MySQL server socket file `/var/run/mysql/mysql.sock' doesn't exist:"
                  << endl 
                  << "`access' error: " << strerror(errno)
                  << endl 
                  << "Trying `/var/run/mysqld/mysqld.sock'."
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>

         errno = 0;

         status = access("/var/run/mysqld/mysqld.sock", F_OK);

         if (status == -1)
         {
              lock_cerr_mutex(); 
              cerr << "ERROR!  In `Scan_Parse_Parameter_Type' constructor:" 
                   << endl
                   << "MySQL server socket file `/var/run/mysqld/mysqld.sock' doesn't exist:"
                   << endl 
                   << "`access' error: " << strerror(errno)
                   << endl
                   << "Tested for `/var/run/mysql/mysql.sock' previously."
                   << endl
                   << "Exiting thread unsuccessfully with "
                   << "return value 0."
                   << endl;
              unlock_cerr_mutex();

              mysql_close(mysql_ptr); 
              mysql_ptr = 0;
 
              pthread_exit(0);

         }  /* |if (status == -1)|  */

@q ********* (9) @>
 
         else
         {
#if DEBUG_COMPILE
              if (DEBUG)
              {
                  lock_cerr_mutex(); 
                  cerr << "In `Scan_Parse_Parameter_Type' constructor:" 
                       << endl
                       << "MySQL server socket file `/var/run/mysqld/mysqld.sock' exists."
                       << endl;
                  unlock_cerr_mutex(); 

              }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

              mysql_socket_filename = "/var/run/mysqld/mysqld.sock";

         }  /* |else|  */

@q ********* (9) @>

     }  /* |if (status == -1)|  */
     
@q ******** (8) @>

     else
     {
#if DEBUG_COMPILE
          if (DEBUG)
          {
              lock_cerr_mutex(); 
              cerr << "In `Scan_Parse_Parameter_Type' constructor:" 
                   << endl
                   << "MySQL server socket file `/var/run/mysql/mysql.sock' exists."
                   << endl;
              unlock_cerr_mutex(); 

          }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

          mysql_socket_filename = "/var/run/mysql/mysql.sock";         

     }  /* |else|  */

@q ******** (8) @>

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type| constructor definitions@>=

     string temp_str;

     stringstream temp_strm;

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type| constructor definitions@>=

     my_bool reconnect    = 1;
     unsigned int timeout = 120;

     mysql_options(mysql_ptr, MYSQL_OPT_RECONNECT, &reconnect); 
     mysql_options(mysql_ptr, MYSQL_OPT_CONNECT_TIMEOUT, &timeout); 

#if 0 
     mysql_options(mysql_ptr, MYSQL_INIT_COMMAND,"set time_zone = '+0:00'");
#endif 

     failed = false;

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type| constructor definitions@>=


     if (is_gwirdsif)
     {
@q ******** (8) @>

          if (mysql_username.empty())
          {
               mysql_username = "root";
          }

          if (mysql_password == 0)
          {
@q ********* (9) @>

#if DEBUG_COMPILE
              if (DEBUG)
              {
                  lock_cerr_mutex(); 
                  cerr << "`mysql_password' == 0."
                       << endl 
                       << "Allocating memory and setting it here."
                       << endl;
                  unlock_cerr_mutex(); 

              }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>

              mysql_password = new char[MYSQL_PASSWORD_LENGTH];
              memset(mysql_password, 0, MYSQL_PASSWORD_LENGTH);
              strcpy(mysql_password, "root");

@q ********* (9) @>

          }  /* |if (mysql_password == 0)|  */

@q ******** (8) @>

#if DEBUG_COMPILE
          else if (DEBUG)
          {
              lock_cerr_mutex(); 
              cerr << "`mysql_password' != 0.  `mysql_password' == " << mysql_password
                   << endl 
                   << "Not allocating memory and setting it here (already set)."
                   << endl;
              unlock_cerr_mutex(); 

          }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ******** (8) @>

     }  /* |if (is_gwirdsif)|  */

@q ******* (7) @>
@
@:KLUDGE@> !! KLUDGE:   @:TODO@> !! TODO:  Do something about this!
I can copy the code for creating the FIFO for GPG passphrases from |main| in 
\filename{gwirdsif.web}.
\initials{LDF 2013.10.02.}

@<|Scan_Parse_Parameter_Type| constructor definitions@>=

     else if (is_gwirdcli)
     {

         mysql_password = new char[MYSQL_PASSWORD_LENGTH];
         memset(mysql_password, 0, MYSQL_PASSWORD_LENGTH);
         strcpy(mysql_password, mysql_username.c_str());

     }  /* |else if (is_gwirdcli)|  */
    

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type| constructor definitions@>=

#if DEBUG_COMPILE
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "In `Scan_Parse_Parameter_Type' default constructor:"
              << endl 
              << "mysql_username == " << mysql_username << endl;

         if (mysql_password != 0)
            cerr << "mysql_password == " << mysql_password << endl;
         else
            cerr << "mysql_password == NULL" << endl;

         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


     for (int i = 0; i < 6; ++i)
     {


          if (!mysql_real_connect(mysql_ptr, 
                                  0, 
                                  mysql_username.c_str(),
                                  mysql_password, 
                                  0,
                                  0, 
                                  mysql_socket_filename.c_str(), 0))
          {
             failed = true;

             lock_cerr_mutex(); 
             cerr << "ERROR!  In `Scan_Parse_Parameter_Type' constructor:" 
                  << endl
                  << "`mysql_real_connect' failed.  "
                  << "Error:  " << mysql_error(mysql_ptr)
                  << endl 
                  << "Error number:  " << mysql_errno(mysql_ptr)
                  << endl;
              unlock_cerr_mutex();

              if (i == 5)
              {
                  lock_cerr_mutex(); 
                  cerr << "Exiting thread unsuccessfully with "
                       << "return value 0."
                       << endl;
                  unlock_cerr_mutex(); 

                  mysql_close(mysql_ptr); 
                  mysql_ptr = 0;

                  pthread_exit(0);

              }  /* |if|  */

              else
              {
                  lock_cerr_mutex(); 
                  cerr << "Trying again, i.e., calling `mysql_real_connect' again."
                       << endl;
                  unlock_cerr_mutex(); 

                  sleep(1);

                  continue;

              }

          }  /* |if|  */

          else
          {
              if (failed || DEBUG)
              {
                 lock_cerr_mutex(); 
                 cerr << "In `Scan_Parse_Parameter_Type' constructor:"
                      << endl
                      << "`mysql_real_connect' succeeded.  Database user name == " 
                      << mysql_username << "."
                      << endl; 
                 unlock_cerr_mutex();
              }   

              failed = false;

              break;

          }  /* |else|  */

     }  /* |for|  */

@q ******* (7) Select database.  @>

@ Select database.  
\initials{LDF 2012.07.10.}

@<|Scan_Parse_Parameter_Type| constructor definitions@>=

     if (is_gwirdsif)
        temp_str = "gwirdsif";
     else 
        temp_str = "gwirdcli";

     failed = false;
 
     for (int i = 0; i < 6; ++i)
     {
@q ******** (8) @>

          status = mysql_select_db(mysql_ptr, temp_str.c_str());

          if (status == 0)
          {  

              if (failed || DEBUG)
              {
                 lock_cerr_mutex(); 
                 cerr << "In `Scan_Parse_Parameter_Type' constructor:  "
                      << "`mysql_select_db succeeded'."
                      << endl
                      << "Connected to `" << temp_str << "' database successfully."
                      << endl;
                 unlock_cerr_mutex();

              }  

              failed = false;

              break;

          }  /* |if (status == 0)| */

          else /* |status != 0| */
          {
@q ********* (9) @>

             failed = true;

             lock_cerr_mutex(); 
             cerr << "In `Scan_Parse_Parameter_Type' constructor:  "  
                  << "`mysql_select_db' failed, returning " << status << "."
                  << endl
                  << "Failed to connect to `" << temp_str << "' database:"
                  << endl
                  << mysql_error(mysql_ptr)
                  << endl;
             unlock_cerr_mutex(); 

             if (i == 5)
             {

                  lock_cerr_mutex(); 
                  cerr << "Exiting thread unsuccessfully with exit status 0."
                       << endl;
                  unlock_cerr_mutex();

                  mysql_close(mysql_ptr); 

                  mysql_ptr = 0;

                  pthread_exit(0);

             }   
             else
             {
                  lock_cerr_mutex(); 
                  cerr << "Trying again, i.e., calling `mysql_select_db' again."
                       << endl;
                  unlock_cerr_mutex();

                  sleep(1);

                  continue;

             }

@q ********* (9) @>

          }   /* |else| (|status != 0|) */

@q ******** (8) @>

     }  /* |for|  */



@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type| constructor definitions@>=



@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type| constructor definitions@>=


   pthread_mutex_init(&response_map_mutex, 0);

   if (DEBUG)
   {
   lock_cerr_mutex(); 
   cerr << "Exiting `Scan_Parse_Parameter_Type' default constructor successfully "
        << "with void return value."
        << endl;
   unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 


   return;

}  /* End of |Scan_Parse_Parameter_Type::Scan_Parse_Parameter_Type(void)| definition.  */

@q **** (4) Destructor.  @>
@ Destructor.
\initials{LDF 2012.06.27.}

\LOG
\initials{LDF 2012.06.27.}
Added this function.

\initials{LDF 2012.09.18.}
Now only calling |mysql_close(mysql_ptr)|, |destroy_java_vm| and |rcDisconnect(conn)|
if |is_gwirdsif == true|.

\initials{LDF 2012.11.16.}
Added code for deleting the temporary files whose names are stored on 
|vector<string> temp_file_vector|.

\initials{LDF 2012.11.27.}
Added code for deleting files named \filename{.irodsEnv} with numerical suffixes
created in \filename{\$HOME/.irods} by the icommand \.{icd}.
\ENDLOG

@q ***** (5) Declaration  @>


@<|Scan_Parse_Parameter_Type| function declarations@>=

~Scan_Parse_Parameter_Type(void);

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type| destructor definition@>=

Scan_Parse_Parameter_Type::~Scan_Parse_Parameter_Type(void)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG, 0, 0);

    int status = 0;

    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "] Entering `Scan_Parse_Parameter_Type' destructor."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 

    response_deque.clear();
    delayed_response_deque.clear();

    group_vector.clear();

    if (remote_connection == true)
    {
        gnutls_bye (session, GNUTLS_SHUT_RDWR);
        tcp_close (sock);
        gnutls_deinit (session);
    }
    else if (sock > 0)
    {
        close(sock);
    }

    if (is_gwirdsif)
    {
        if (mysql_ptr)
           mysql_close(mysql_ptr); 

        mysql_ptr = 0;

    }  /* |if (is_gwirdsif)|  */

    if (irods_object)
    {
        delete irods_object;
        irods_object = 0;
    }
      

    if (cert_ptr)
    {
        delete cert_ptr;
        cert_ptr = 0;
    }
       

    if (user_info_ptr)
    {
        delete user_info_ptr;
        user_info_ptr = 0;
    }

@q ****** (6) @>
@
\LOG
\initials{LDF 2012.11.16.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type| destructor definition@>=

@q ******* (7) @>

#if DEBUG_COMPILE
    if (temp_file_vector.size() == 0 && DEBUG)
    {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type' destructor:"
                 << endl
                 << "`temp_file_vector.size() == 0'.  No temporary files to delete."
                 << endl;
            unlock_cerr_mutex(); 

    }  /* |if (temp_file_vector.size() == 0 && DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

    else if (temp_file_vector.size() > 0 && save_temp_files == false)
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type' destructor:"
                 << endl
                 << "`temp_file_vector.size()' > 0 and `save_temp_files' == `false'."
                 << endl 
                 << "Deleting temporary files."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

        for (vector<string>::const_iterator iter = temp_file_vector.begin();
             iter != temp_file_vector.end();
             ++iter)
        {
@q ********* (9) @>

            errno = 0;
            status = unlink(iter->c_str());

            if (status == -1)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "]  ERROR!  "
                     << "In `Scan_Parse_Parameter_Type' destructor:"
                     << endl
                     << "``unlink' failed, returning -1:"
                     << endl
                     << strerror(errno)
                     << endl
                     << "Failed to delete file `" << *iter << "'."
                     << endl 
                     << "Will try to continue."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (status == -1)|  */

@q ********* (9) @>

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "]  "
                     << "In `Scan_Parse_Parameter_Type' destructor:"
                     << endl
                     << "``unlink' succeeded, returning 0."
                     << endl
                     << "Deleted file `" << *iter << "' successfully."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>

        }  /* |for|  */

@q ******** (8) @>


        temp_file_vector.clear();

    }  /* |else if (temp_file_vector.size() > 0 && save_temp_files == false)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
    else if (save_temp_files == true && DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type' destructor:"
             << endl
             << "`save_temp_files' == `true'.  Not deleting temporary files."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (save_temp_files == true && DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type| destructor definition@>=
   
    filename_vector.clear();

    string_vector.clear();
    int_vector.clear();

    pthread_mutex_destroy(&response_map_mutex);

@q ****** (6) Delete iRODS environment files created by `icd' command.  @>

@ Delete iRODS environment files created by \.{icd} command.  
\initials{LDF 2012.11.27.}

\LOG
\initials{LDF 2012.11.27.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type| destructor definition@>=

   if (is_gwirdsif)
   {
       stringstream temp_strm;

       temp_strm.str("");

       temp_strm << "find $HOME/.irods/ -depth -regex $HOME/.irods/.irodsEnv\\.[0-9]+ -delete";

#if DEBUG_COMPILE 
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       status = system(temp_strm.str().c_str());

       if (status != 0)
       {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "ERROR!  In `Scan_Parse_Parameter_Type' destructor:  "
                 << "`system' failed, returning "
                 << status << ":"
                 << endl;

            if (WIFEXITED(status))
            {
              cerr << "WEXITSTATUS(" << status << ") == " 
                   << WEXITSTATUS(status) << endl;
            }
            else
            {
              cerr << "Process didn't exit." << endl;

            }
            unlock_cerr_mutex();     

       }  /* |if (status != 0)|  */

       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type' destructor:  "
                << "`system' succeeded." << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */ 

    }  /* |if (is_gwirdsif)|  */



@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type| destructor definition@>=


#if DEBUG_COMPILE 
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "] Exiting `Scan_Parse_Parameter_Type' "
             << "destructor successfully "
             << "with void return value."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

    return;

}  /* End of |Scan_Parse_Parameter_Type::~Scan_Parse_Parameter_Type(void)| definition.  */

@q **** (4) Initialize maps.  @>
@ Initialize maps.
\initials{LDF 2013.05.27.}

\LOG
\initials{LDF 2013.05.27.}
Added this function.

\initials{LDF 2013.12.25.}
Added code for |server_action_generate_checksum| and |server_action_verify_checksum|.

\initials{LDF 2014.01.21.}
Added code for |Scan_Parse_Parameter_Type::server_action_store_public_key|.

\initials{LDF 2014.01.31.}
Added code for |Scan_Parse_Parameter_Type::server_action_register_pull|.
\ENDLOG

@q ***** (5) Declaration @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
static
int 
initialize_maps(void);

@q ***** (5) Definition  @>
@
@<Initialize |Scan_Parse_Parameter_Type| maps@>=
int 
Scan_Parse_Parameter_Type::initialize_maps(void)
{
@q ****** (6) @>

    server_action_map[Response_Type::COMMAND_ONLY_TYPE]  
       = &Scan_Parse_Parameter_Type::server_action_command_only;

    server_action_map[Response_Type::SEND_FILE_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_send_file;

    server_action_map[Response_Type::RECEIVE_PUT_FILE_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_receive_put_file;

    server_action_map[Response_Type::RECEIVE_METADATA_FILE_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_receive_metadata_file;

    server_action_map[Response_Type::SEND_HANDLE_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_send_handle;

    server_action_map[Response_Type::LS_TYPE]  
       = &Scan_Parse_Parameter_Type::server_action_ls;

    server_action_map[Response_Type::MV_TYPE]  
       = &Scan_Parse_Parameter_Type::server_action_mv;

    server_action_map[Response_Type::PWD_TYPE]  
       = &Scan_Parse_Parameter_Type::server_action_pwd;

    server_action_map[Response_Type::CD_TYPE]  
       = &Scan_Parse_Parameter_Type::server_action_cd;

    server_action_map[Response_Type::MKDIR_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_mkdir;

    server_action_map[Response_Type::MARK_IRODS_OBJECTS_FOR_DELETION_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion;

    server_action_map[Response_Type::GET_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_get;

    server_action_map[Response_Type::SEND_METADATA_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_send_metadata;

    server_action_map[Response_Type::END_SERVER_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_end_server;

    server_action_map[Response_Type::SLEEP_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_sleep;

    server_action_map[Response_Type::SHOW_CERTIFICATE_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_show_certificate;

    server_action_map[Response_Type::GET_METADATA_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_get_metadata;

    server_action_map[Response_Type::GET_HANDLE_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_get_handle;

    server_action_map[Response_Type::SEND_TAN_LIST_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_send_tan_list;

    server_action_map[Response_Type::PROCESS_PENDING_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_process_pending;

    server_action_map[Response_Type::GET_USER_INFO_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_get_user_info;

    server_action_map[Response_Type::CREATE_HANDLE_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_create_handle;

    server_action_map[Response_Type::ADD_HANDLE_VALUE_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_add_handle_value;

    server_action_map[Response_Type::DELETE_HANDLE_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_delete_handle;

    server_action_map[Response_Type::UNDELETE_HANDLE_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_undelete_handle;

    server_action_map[Response_Type::DELETE_HANDLE_VALUE_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_delete_handle_value;

    server_action_map[Response_Type::UNDELETE_HANDLE_VALUE_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_undelete_handle_value;

    server_action_map[Response_Type::UNDELETE_FILE_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_undelete_file;

    server_action_map[Response_Type::DELETE_METADATA_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_delete_metadata;

    server_action_map[Response_Type::UNDELETE_METADATA_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_undelete_metadata;

    server_action_map[Response_Type::FETCH_DC_METADATA_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_fetch_metadata;

    server_action_map[Response_Type::GENERATE_CHECKSUM_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_generate_checksum;

    server_action_map[Response_Type::VERIFY_CHECKSUM_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_verify_checksum;

    server_action_map[Response_Type::STORE_PUBLIC_KEY_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_store_public_key;

    server_action_map[Response_Type::REGISTER_PULL_TYPE]
       = &Scan_Parse_Parameter_Type::server_action_register_pull;

    server_action_map[Response_Type::MAX_RESPONSE_TYPE + 1] 
       = &Scan_Parse_Parameter_Type::server_action_unknown;

@q ****** (6) @>
@
@<Initialize |Scan_Parse_Parameter_Type| maps@>=

    server_action_name_map[Response_Type::COMMAND_ONLY_TYPE]     
       = "Scan_Parse_Parameter_Type::server_action_command_only";

    server_action_name_map[Response_Type::SEND_FILE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_send_file";

    server_action_name_map[Response_Type::RECEIVE_PUT_FILE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_receive_put_file";

    server_action_name_map[Response_Type::RECEIVE_METADATA_FILE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_receive_metadata_file";

    server_action_name_map[Response_Type::SEND_HANDLE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_send_handle";

    server_action_name_map[Response_Type::LS_TYPE]     
       = "Scan_Parse_Parameter_Type::server_action_ls";

    server_action_name_map[Response_Type::MV_TYPE]     
       = "Scan_Parse_Parameter_Type::server_action_mv";

    server_action_name_map[Response_Type::PWD_TYPE]     
       = "Scan_Parse_Parameter_Type::server_action_pwd";

    server_action_name_map[Response_Type::CD_TYPE]     
       = "Scan_Parse_Parameter_Type::server_action_cd";

    server_action_name_map[Response_Type::MKDIR_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_mkdir";

    server_action_name_map[Response_Type::MARK_IRODS_OBJECTS_FOR_DELETION_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion";

    server_action_name_map[Response_Type::GET_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_get";

    server_action_name_map[Response_Type::SEND_METADATA_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_send_metadata";

    server_action_name_map[Response_Type::END_SERVER_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_end_server";

    server_action_name_map[Response_Type::SLEEP_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_sleep";

    server_action_name_map[Response_Type::SHOW_CERTIFICATE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_show_certificate";

    server_action_name_map[Response_Type::GET_METADATA_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_get_metadata";

    server_action_name_map[Response_Type::GET_HANDLE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_get_handle";

    server_action_name_map[Response_Type::SEND_TAN_LIST_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_send_tan_list";

    server_action_name_map[Response_Type::PROCESS_PENDING_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_process_pending";

    server_action_name_map[Response_Type::GET_USER_INFO_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_get_user_info";

    server_action_name_map[Response_Type::CREATE_HANDLE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_create_handle";

    server_action_name_map[Response_Type::ADD_HANDLE_VALUE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_add_handle_value";

    server_action_name_map[Response_Type::DELETE_HANDLE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_delete_handle";

    server_action_name_map[Response_Type::UNDELETE_HANDLE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_undelete_handle";

    server_action_name_map[Response_Type::UNDELETE_FILE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_undelete_file";

    server_action_name_map[Response_Type::DELETE_HANDLE_VALUE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_delete_handle_value";

    server_action_name_map[Response_Type::UNDELETE_HANDLE_VALUE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_undelete_handle_value";

    server_action_name_map[Response_Type::UNDELETE_FILE_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_undelete_file";

    server_action_name_map[Response_Type::DELETE_METADATA_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_delete_metadata";

    server_action_name_map[Response_Type::UNDELETE_METADATA_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_undelete_metadata";

    server_action_name_map[Response_Type::FETCH_DC_METADATA_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_fetch_metadata";

    server_action_name_map[Response_Type::GENERATE_CHECKSUM_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_generate_checksum";

    server_action_name_map[Response_Type::VERIFY_CHECKSUM_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_verify_checksum";

    server_action_name_map[Response_Type::STORE_PUBLIC_KEY_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_store_public_key";

    server_action_name_map[Response_Type::REGISTER_PULL_TYPE]
       = "Scan_Parse_Parameter_Type::server_action_register_pull";

    server_action_name_map[Response_Type::MAX_RESPONSE_TYPE + 1] 
       = "Scan_Parse_Parameter_Type::server_action_unknown";

@q ****** (6) @>
@
@<Initialize |Scan_Parse_Parameter_Type| maps@>=

    client_action_map[Response_Type::COMMAND_ONLY_TYPE]  
       = &Scan_Parse_Parameter_Type::client_action_command_only;

    client_action_map[Response_Type::SEND_FILE_TYPE]
       = &Scan_Parse_Parameter_Type::client_action_send_file;

    client_action_map[Response_Type::SEND_PUBLIC_KEY_TYPE]
       = &Scan_Parse_Parameter_Type::client_action_send_public_key;

    client_action_map[Response_Type::MAX_RESPONSE_TYPE + 1] 
       = &Scan_Parse_Parameter_Type::client_action_unknown;

@q ****** (6) @>
@
@<Initialize |Scan_Parse_Parameter_Type| maps@>=

    client_action_name_map[Response_Type::COMMAND_ONLY_TYPE]     
       = "Scan_Parse_Parameter_Type::client_action_command_only";

    client_action_name_map[Response_Type::SEND_FILE_TYPE]
       = "Scan_Parse_Parameter_Type::client_action_send_file";

    client_action_name_map[Response_Type::SEND_PUBLIC_KEY_TYPE]
       = "Scan_Parse_Parameter_Type::client_action_send_public_key";

    client_action_name_map[Response_Type::MAX_RESPONSE_TYPE + 1] 
       = "Scan_Parse_Parameter_Type::client_action_unknown";

@q ****** (6) @>

    return 0;


}  /* End of |Scan_Parse_Parameter_Type::initialize_maps| definition  */


@q **** (4) Get Database Username.  @>
@ Get Database Username.
\initials{LDF 2013.05.10.}

\LOG
\initials{LDF 2013.05.10.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
get_database_username(void);

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::get_database_username| definition@>=

int
Scan_Parse_Parameter_Type::get_database_username(void)
{
@q ****** (6) @>
 
   bool DEBUG = false;  /* |true|  */

   set_debug_level(DEBUG);

   int status = 0;

   string thread_ctr_str = "";

   {
       stringstream s;
 
       s << "[Thread " << thread_ctr << "]:  ";

       thread_ctr_str = s.str();
       
   }  

#if DEBUG_COMPILE 
   if (DEBUG)
   {
      lock_cerr_mutex(); 
      cerr << thread_ctr_str << "Entering `Scan_Parse_Parameter_Type::get_database_username'."
           << endl;
      unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_database_username| definition@>=

   Distinguished_Name_Type distinguished_name;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_database_username':"
            << endl 
            << "Calling  Distinguished_Name_Type::operator= " 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


    distinguished_name = user_cert;



#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_database_username':"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    MYSQL_RES* result = 0;
    MYSQL_ROW curr_row;

    unsigned int row_ctr = 0;
    unsigned int field_ctr = 0;

    stringstream query_strm;

    int certificate_id;

    query_strm << "select u.user_id, u.username "
               << "from gwirdsif.Users as u, gwirdsif.Certificates as c "
               << "where u.user_id = c.user_id and u.user_id > 0 "
               << "and ((c.serialNumber is not NULL and c.serialNumber <> 0 and c.serialNumber = " 
               << user_cert.serialNumber << ") or "
               << "(c.commonName = '" << distinguished_name.commonName 
               << "' and c.organization = '" << distinguished_name.organization
               << "' and c.organizationalUnitName = '" << distinguished_name.organizationalUnitName
               << "' and c.countryName = '" << distinguished_name.countryName << "')) "
               << "order by u.user_id";

#if DEBUG_COMPILE 
    if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_database_username':"
             << endl 
             << "`query_strm.str()' == " 
             << endl
             << query_strm.str()
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_database_username| definition@>=


    status = submit_mysql_query(query_strm.str(),
                                result, 
                                &row_ctr, 
                                &field_ctr);

    if (status != 0)
    {
        lock_cerr_mutex();
        cerr << get_datestamp() << thread_ctr_str
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_database_username':"
             << endl 
             << "`submit_mysql_query' failed, returning " << status << ":"
             << endl 
             << "Error:  " << mysql_error(mysql_ptr)
             << endl 
             << "Error number:  " << mysql_errno(mysql_ptr)
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        if (result)
           mysql_free_result(result);        

        username = "";

        ++errors_occurred;

        return 1;             

    }  /* |if (status != 0)|  */

@q ****** (6) @>

#if DEBUG_COMPILE 
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str
             << "In `Scan_Parse_Parameter_Type::get_database_username':"
             << endl 
             << "`myql_query' succeeded, returning 0."
             << endl 
             << "row_ctr == " << row_ctr 
             << endl
             << "field_ctr == " << field_ctr 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) |row_ctr == 0|.  @>

@ |row_ctr == 0|.  
\initials{LDF 2013.05.10.}

@<|Scan_Parse_Parameter_Type::get_database_username| definition@>=

    if (row_ctr ==  0)
    {
@q ******* (7) @>

        lock_cerr_mutex();
        cerr << get_datestamp() << thread_ctr_str
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_database_username':"
             << endl 
             << "No rows returned."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        mysql_free_result(result);        

        username = "";

        ++errors_occurred;

        return 1;             
     
@q ******* (7) @>
   
    } /* |if (row_ctr ==  0)| */


@q ****** (6) |row_ctr > 1|.  @>

@ |row_ctr > 1|.  This shouldn't ever happen.
\initials{LDF 2013.05.10.}

@<|Scan_Parse_Parameter_Type::get_database_username| definition@>=

    else if (row_ctr >  1)
    {
@q ******* (7) @>

        lock_cerr_mutex();
        cerr << get_datestamp() << thread_ctr_str
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_database_username':"
             << endl 
             << row_ctr << " rows returned (> 1).  Only one row should have been returned."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        mysql_free_result(result);        

        ++errors_occurred;

        return 1;             
     
@q ******* (7) @>
   
    } /* |else if (row_ctr ==  0)| */




@q ****** (6) Found entries in database tables.  @>

@ Found entries in database tables.  
\initials{LDF 2013.05.10.}

@<|Scan_Parse_Parameter_Type::get_database_username| definition@>=

    else /* |row_ctr == 1| */
    {
@q ******* (7) @>

        curr_row = mysql_fetch_row(result);

        if (curr_row == 0)
        {
           lock_cerr_mutex(); 
           cerr << get_datestamp() << thread_ctr_str
                << "ERROR!  In `Scan_Parse_Parameter_Type::get_database_username':"
                << endl 
                << "`mysql_fetch_row' failed:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           if (result)
              mysql_free_result(result);

           ++errors_occurred;

           return 1;

        }  /* |if (curr_row == 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE 
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_ctr_str
                 << "In `Scan_Parse_Parameter_Type::get_database_username':"
                 << endl;
            if (curr_row[0])
               cerr << "`curr_row[0]' == " << curr_row[0]
                    << endl;
            else
               cerr << "`curr_row[0]' is NULL." << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

        if (curr_row[0])
        {
           sscanf(curr_row[0], "%d", &user_id);
           distinguished_name.user_id = user_cert.user_id = user_id;
           
        }
        else 
           distinguished_name.user_id = user_cert.user_id = user_id = 0;

        if (curr_row[1])
        {
           distinguished_name.user_name = username = user_cert.user_name = curr_row[1];
        }
        else
        {
            distinguished_name.user_name = username = user_cert.user_name = "";

            lock_cerr_mutex(); 
            cerr << get_datestamp() << thread_ctr_str
                 << "WARNING!  In `Scan_Parse_Parameter_Type::get_database_username':"
                 << endl 
                 << "Failed to find username."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            mysql_free_result(result);

            ++errors_occurred;

            return 1;

        }  /* |else| (|!curr_row[1]|)  */


@q ******* (7) @>
 
    }  /* |else| (|row_ctr == 1|) */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_database_username| definition@>=

#if DEBUG_COMPILE 
   if (DEBUG)
   {
      lock_cerr_mutex(); 
      cerr << thread_ctr_str 
           << "Exiting `Scan_Parse_Parameter_Type::get_database_username' successfully "
           << "with return value 0."
           << endl;
      unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 


   return 0;

}  /* End of |Scan_Parse_Parameter_Type::get_database_username| definition  */

@q **** (4) Get user.  (|get_user|).  @>
@ Get user.  (|get_user|).
\initials{LDF 2012.07.11.}

\LOG
\initials{LDF 2012.07.11.}
Added this function.

\initials{LDF 2012.09.18.}
Added code for exiting unsuccessfully with return value 1 if |is_gwirdsif == false|.

\initials{LDF 2012.10.08.}
Added code for setting the data members |default_prefix_id|, |default_prefix|,
|default_institute_id| and |default_institute_name|.

\initials{LDF 2013.05.10.}
Added optional argument |int user_id = 0|.  Made |const char *dn| argument optional
with default 0.

\initials{LDF 2013.05.14.}
Added optional arguments |User_Info_Type *user_info = 0| and |bool set_user = false|.
@:NOTE@> !! PLEASE NOTE:  The default of |set_user| is ``really'' |true|, unless 
|user_info| is non-null.  That is, this if |user_info == 0|, |set_user| is 
reset to |true|.  The combination of |user_info == 0| and |set_user == false| 
doesn't make any sense, because the function would then have no effect.  Normally,
it should either set the user, in which case |user_info| might as well be NULL, or 
it should store user info in a |User_Info_Type| object, in which case the current 
user should already have been set.  However, one can do both by using |user_info != NULL| 
and |set_user == true|.
\ENDLOG

@q ***** (5) @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
get_user(int curr_user_id = 0, 
         const char *dn = 0, 
         string curr_username = "",
         User_Info_Type *user_info = 0, 
         bool set_user = false);

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=
int
Scan_Parse_Parameter_Type::get_user(int curr_user_id, 
                                    const char *dn, 
                                    string curr_username,
                                    User_Info_Type *user_info,
                                    bool set_user)
{
@q ****** (6) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   int status;

   stringstream temp_strm;

   temp_strm << "[Thread " << thread_ctr << "] ";

   string thread_ctr_str = temp_strm.str(); 

   temp_strm.str("");

#if DEBUG_COMPILE  
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "Entering `Scan_Parse_Parameter_Type::get_user'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   if (!(is_gwirdsif || is_gwirdpcl))
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "WARNING!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl
            << "`is_gwirdsif' == `false'.  This function is only meant to be used by the server "
            << "program `gwirdsif' or the pull client program `gwirdpcl'."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (!(is_gwirdsif || is_gwirdpcl)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (user_info == 0)  /* See explanation above.  \initials{LDF 2013.05.14.}  */
      set_user = true;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':"
            << endl;

       if (user_info)
            cerr << "`user_info' is non-NULL." << endl;
       else
            cerr << "`user_info' is NULL." << endl;

       cerr << "`set_user' == " << set_user << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (curr_user_id == 0 && dn == 0 && curr_username.empty())
   {
       /* First, try setting |curr_user_id| to |user_id|.
          \initials{LDF 2013.05.19.}  */

       curr_user_id = user_id;
   }
   
   if (curr_user_id <= 0 && dn == 0 && curr_username.empty())
   {

       /* Now, if |curr_user_id| is still $<= 0$, we can't query the database.
          \initials{LDF 2013.05.19.}  
       */

       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl
            << "Invalid arguments:  `curr_user_id' == " << curr_user_id << " "
            << "(<= 0) and `dn' == 0 and `curr_username' is empty."
            << endl
            << "Can't query database."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (curr_user_id == 0 && dn == 0 && curr_username.empty())|  */


@q ****** (6) @>

@ @:NOTE@> !! PLEASE NOTE: |curr_user_id| has priority over |dn| and |dn| has
priority over |curr_username|.  Only one of the three items is used in the query!
\initials{LDF 2013.05.19.}

@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   stringstream sql_strm;

   sql_strm << "select distinct u.user_id, u.username, u.Distinguished_Name, "
            << "u.irods_password_encrypted, "
            << "u.irods_password_encrypted_timestamp, u.irods_homedir, "
            << "u.irods_zone, u.irods_default_resource, u.default_prefix_id, p.prefix, "
            << "u.default_institute_id, i.name "
            << "from Users as u, "
            << "Prefixes as p, Users_Prefixes as up, Institutes as i ";

  /* 
     Removed |& user_info == 0| from the following conditional.  I don't think it's needed.  
     \initials{LDF 2013.07.17.}
  */

   if (curr_user_id > 0)
         sql_strm << "where u.user_id = " << curr_user_id << " ";
   else if (dn != 0)
         sql_strm << "where u.Distinguished_Name = '" << dn << "' ";
   else if (!curr_username.empty())
         sql_strm << "where u.username = '" << curr_username << "' ";

   sql_strm << "and u.default_prefix_id = p.prefix_id and up.user_id = u.user_id "
            << "and up.prefix_id = p.prefix_id "
            << "and u.default_institute_id = i.institute_id ";

   sql_strm << "order by u.user_id";

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   MYSQL_RES *result = 0;
   unsigned int row_ctr;
   unsigned int field_ctr;
   MYSQL_ROW curr_row;

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);                  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
            << status << "."
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Can't set user info."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
           mysql_free_result(result);
       }

       ++errors_occurred;   

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
            << endl
            << "`row_ctr' == " << row_ctr
            << endl
            << "`field_ctr' == " << field_ctr
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (row_ctr == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "WARNING!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned 0 rows."
            << endl
            << "Can't set user info."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       ++errors_occurred;

       return 1;

   }  /* |if (row_ctr == 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   else if (row_ctr > 1)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "WARNING!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned " 
            << row_ctr << " rows (> 1)."
            << endl
            << "Will use the data from the first row.  Continuing."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (row_ctr > 1)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if ((curr_row = mysql_fetch_row(result)) == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`mysql_fetch_row' failed:"
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       ++errors_occurred;

       return 1;

   }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`mysql_fetch_row' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
\LOG
\initials{LDF 2013.05.10.}
Now only setting |user_id| if it hasn't already been set, e.g., by 
|Scan_Parse_Parameter_Type::get_database_username|.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (user_id <= 0)
   {

       if (curr_row[0] == 0 || strlen(curr_row[0]) == 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_user':"
                << endl 
                << "`curr_row[0]' is NULL or empty.  Can't set `user_id'."
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (curr_row[0] == 0 || strlen(curr_row[0]) == 0)|  */

       if (set_user)
          user_id = atoi(curr_row[0]);

   }  /* |if (user_id <= 0)|  */

   if (user_info)
   {
      curr_user_id = user_info->user_id = atoi(curr_row[0]);

   }

#if DEBUG_COMPILE 
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  ";

           if (set_user)
               cerr << "`user_id' == " << user_id << endl;
           else if (user_info)
               cerr << "`user_info->user_id' == " << user_info->user_id << endl;

           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 
   
@q ****** (6) @>
@
\LOG
\initials{LDF 2013.05.10.}
Now only setting |username| if it hasn't already been set, e.g., by 
|Scan_Parse_Parameter_Type::get_database_username|.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (username.empty())
   {
       if (curr_row[1] == 0 || strlen(curr_row[1]) == 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_user':"
                << endl 
                << "`curr_row[1]' is NULL or empty.  Can't set `username'."
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (curr_row[1] == 0 || strlen(curr_row[1]) == 0)|  */

       if (set_user)
          username = curr_row[1];

   }  /* |if (username.empty())|  */

   if (user_info)
       user_info->username = curr_row[1];

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  ";

       if (set_user)
          cerr << "`username' == " << username << endl;
       else if (user_info)
          cerr << "`user_info->username' == " << user_info->username << endl; 

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>
@
\LOG
\initials{LDF 2013.05.17.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (curr_row[2] == 0 || strlen(curr_row[2]) == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  "
            << "In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`curr_row[2]' is NULL or empty.  Can't set `distinguished_name'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       ++errors_occurred;

       return 1;

   }  /* |if (curr_row[2] == 0 || strlen(curr_row[2]) == 0)|  */
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str 
            << "In `Scan_Parse_Parameter_Type::get_user':"
            << endl
            << "`curr_row[2]' == \"Distinguished Name\" == " << curr_row[2]
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


   string temp_username = curr_row[1];

   if (set_user)
   {
       distinguished_name.set(curr_row[2], user_id, &temp_username);

   }

   if (user_info)
   {
       user_info->distinguished_name.set(curr_row[2], user_info->user_id, &temp_username);

   }

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  "
            << "set_user == " << set_user 
            << endl;

       if (set_user)
       {
          distinguished_name.show("distinguished_name:");
       }
       else if (user_info)
       {
           user_info->distinguished_name.show("user_info->distinguished_name:");
           
           distinguished_name.show("distinguished_name:");

       }

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (curr_row[3] == 0 || strlen(curr_row[3]) == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`curr_row[3]' is NULL or empty.  Can't set `irods_password_encrypted'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       ++errors_occurred;   

       return 1;

   }  /* |if (curr_row[3] == 0 || strlen(curr_row[3]) == 0)|  */

   if (set_user)
      irods_password_encrypted = curr_row[3];
   if (user_info)
      user_info->irods_password_encrypted = curr_row[3];


#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  ";
 
       if (set_user)
          cerr << "`irods_password_encrypted' ==" 
               << endl 
               << irods_password_encrypted << endl;

       if (user_info)
          cerr << "`user_info->irods_password_encrypted' =="
               << endl 
               << user_info->irods_password_encrypted << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (curr_row[4] == 0 || strlen(curr_row[4]) == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`curr_row[4]' is NULL or empty.  Can't set `irods_password_encrypted_timestamp'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       ++errors_occurred;

       return 1;

   }  /* |if (curr_row[4] == 0 || strlen(curr_row[4]) == 0)|  */

   if (set_user)
      irods_password_encrypted_timestamp = curr_row[4];
   if (user_info)
      user_info->irods_password_encrypted_timestamp = curr_row[4];

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  ";

       if (set_user)
          cerr << "`irods_password_encrypted_timestamp' ==" << endl 
               << irods_password_encrypted_timestamp << endl;
       if (user_info)
          cerr << "`user_info->irods_password_encrypted_timestamp' ==" << endl 
               << user_info->irods_password_encrypted_timestamp << endl;

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
\LOG
\initials{LDF 2012.10.17.}
Now setting |irods_current_dir| to |curr_row[5]| as well as |irods_homedir|.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (curr_row[5] == 0 || strlen(curr_row[5]) == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`curr_row[5]' is NULL or empty.  Can't set `irods_homedir'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       ++errors_occurred;

       return 1;

   }  /* |if (curr_row[5] == 0 || strlen(curr_row[5]) == 0)|  */

   if (set_user)
      irods_current_dir = irods_homedir = curr_row[5];
   if (user_info)
      user_info->irods_current_dir = user_info->irods_homedir = curr_row[5];

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  ";

       if (set_user)
          cerr << "`irods_homedir' == `irods_current_dir' == " << endl 
               << irods_homedir << endl;
       if (user_info)
          cerr << "`user_info->irods_homedir' == `user_info->irods_current_dir' == " << endl 
               << user_info->irods_homedir << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (curr_row[6] == 0 || strlen(curr_row[6]) == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`curr_row[6]' is NULL or empty.  Can't set `irods_zone'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       ++errors_occurred; 

       return 1;

   }  /* |if (curr_row[6] == 0 || strlen(curr_row[6]) == 0)|  */

   if (set_user)
      irods_zone = curr_row[6];
   if (user_info)
      user_info->irods_zone = curr_row[6];

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  ";

       if (set_user)
           cerr << "`irods_zone' == " << endl 
                << irods_zone << endl;
       if (user_info)
           cerr << "`user_info->irods_zone' == " << endl 
                << user_info->irods_zone << endl;

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (curr_row[7] == 0 || strlen(curr_row[7]) == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`curr_row[7]' is NULL or empty.  Can't set `irods_default_resource'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       ++errors_occurred;

       return 1;

   }  /* |if (curr_row[7] == 0 || strlen(curr_row[7]) == 0)|  */

   
   if (set_user)
      irods_default_resource = curr_row[7];
   if (user_info)
      user_info->irods_default_resource = curr_row[7];

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  "
            << "`irods_default_resource' == " << endl 
            << irods_default_resource << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>
@
\LOG
\initials{LDF 2012.10.08.}
Added this section.
\ENDLOG
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (curr_row[8] == 0 || strlen(curr_row[8]) == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`curr_row[8]' is NULL or empty.  Can't set `default_prefix_id'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       ++errors_occurred;

       return 1;

   }  /* |if (curr_row[8] == 0 || strlen(curr_row[8]) == 0)|  */

   if (set_user)
      default_handle_prefix_id = atoi(curr_row[8]);
   if (user_info)
      user_info->default_handle_prefix_id = atoi(curr_row[8]);

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  ";

       if (set_user)
          cerr << "`default_handle_prefix_id' == " << default_handle_prefix_id 
               << endl;
       if (user_info)
          cerr << "`user_info->default_handle_prefix_id' == " 
               << user_info->default_handle_prefix_id 
               << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>
@
\LOG
\initials{LDF 2012.10.08.}
Added this section.
\ENDLOG
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (curr_row[9] == 0 || strlen(curr_row[9]) == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`curr_row[9]' is NULL or empty.  Can't set `default_handle_prefix'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);
       
       ++errors_occurred;

       return 1;

   }  /* |if (curr_row[9] == 0 || strlen(curr_row[9]) == 0)|  */

   if (set_user)
      default_handle_prefix = curr_row[9];
   if (user_info)
      user_info->default_handle_prefix = curr_row[9];

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  ";

       if (set_user)
          cerr << "`default_handle_prefix' == " << default_handle_prefix 
               << endl;
       if (user_info)
          cerr << "`user_info->default_handle_prefix' == " << user_info->default_handle_prefix 
               << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
\LOG
\initials{LDF 2012.10.08.}
Added this section.
\ENDLOG
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (curr_row[10] == 0 || strlen(curr_row[10]) == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`curr_row[10]' is NULL or empty.  Can't set `default_institute_id'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       ++errors_occurred;

       return 1;

   }  /* |if (curr_row[10] == 0 || strlen(curr_row[10]) == 0)|  */

   if (set_user)
      default_institute_id = atoi(curr_row[10]);
   if (user_info)
      user_info->default_institute_id = atoi(curr_row[10]);

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  ";

       if (set_user)
          cerr << "`default_institute_id' == " << default_institute_id 
               << endl;
       if (user_info)
          cerr << "`user_info->default_institute_id' == " << user_info->default_institute_id
               << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>
@
\LOG
\initials{LDF 2012.10.08.}
Added this section.
\ENDLOG
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (curr_row[11] == 0 || strlen(curr_row[11]) == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`curr_row[11]' is NULL or empty.  Can't set `default_institute_name'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       ++errors_occurred;

       return 1;

   }  /* |if (curr_row[11] == 0 || strlen(curr_row[11]) == 0)|  */

   if (set_user)
      default_institute_name = curr_row[11];
   if (user_info)
      user_info->default_institute_name = curr_row[11];

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  ";

       if (set_user)
          cerr << "`default_institute_name' == " << default_institute_name << endl;

       if (user_info)
          cerr << "`user_info->default_institute_name' == " << user_info->default_institute_name 
               << endl;

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   mysql_free_result(result);

   result = 0;

@q ****** (6) Get privileges.  @>

@ Get privileges.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   unsigned int temp_privileges = 0U;

   status = get_privileges_gwirdsif(curr_user_id, &temp_privileges);

   bitset<sizeof(unsigned int) * 8> temp_bitset(temp_privileges);

   if (status == 2)
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
            lock_cerr_mutex(); 
            cerr << thread_ctr_str
                 << "In `Scan_Parse_Parameter_Type::get_user':  "
                 << "`Scan_Parse_Parameter_Type::get_privileges_gwirdsif' succeeded, "
                 << "returning 2." 
                 << endl 
                 << "No entry in database table `gwirdsif.Privileges' for "
                 << "user " << ((curr_user_id > 0) ? curr_user_id : user_id)
                 << endl
                 << "`temp_privileges' == " << temp_bitset  /* Should be 0.  
                                                               \initials{LDF 2013.05.16.}  */
                 << endl; 
            unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
 
   }  /* |if (status == 2)|  */

   else if (status != 0)
   {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':  "
             << "`Scan_Parse_Parameter_Type::get_privileges_gwirdsif' failed, "
             << "returning " << status << "."
             << endl 
             << "Failed to retrieve privileges for user " << curr_user_id << "."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        ++errors_occurred;

        return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  "
             << "`Scan_Parse_Parameter_Type::get_privileges_gwirdsif' succeeded, "
             << "returning 0." 
             << endl 
             << "`temp_privileges' == " << temp_bitset
             << endl;
        unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   if (set_user)
      privileges = temp_privileges;

   if (user_info)
   {
      user_info->privileges = temp_privileges;

#if DEBUG_COMPILE
      if (DEBUG)
      {
           bitset<sizeof(unsigned int) * 8> ui_priv(user_info->privileges);

           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':"
                << endl 
                << "`user_info->privileges' == " << ui_priv
                << endl;
           unlock_cerr_mutex(); 

      }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
   }

@q ****** (6) Retrieve X.509 certificate data.  @>

@ Retrieve X.509 certificate data.
\initials{LDF 2013.05.17.}

\LOG
\initials{LDF 2013.05.17.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   X509_Cert_Type temp_cert;

   int temp_user_id = (set_user) ? user_id : user_info->user_id;

   status = temp_cert.get_from_database(mysql_ptr, temp_user_id, thread_ctr_str); 

   if (status != 0)
   {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':  "
             << "`x509_Cert_Type::get_from_database' failed, "
             << "returning " << status << "."
             << endl 
             << "Failed to retrieve X.509 certificate data for user " 
             << temp_user_id << "."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        ++errors_occurred;

        return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str
             << "In `Scan_Parse_Parameter_Type::get_user':  "
             << "`x509_Cert_Type::get_from_database' succeeded, "
             << "returning 0."
             << endl 
             << "Retrieved X.509 certificate data for user " 
             << temp_user_id << " successfully."
             << endl;

        temp_cert.show("temp_cert:");

        unlock_cerr_mutex(); 
 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   if (set_user)
   {
       if (user_cert.serialNumber == 0)  
       {

           /* This will be the case if |user_cert| has been set by 
              |verify_certificate| and not read from the database.  
              |certificate_id| is internal to \.{gwrdifpk} and not 
              part of the actual X.509 certificate.
              \initials{LDF 2013.05.22.}  
           */

           user_cert = temp_cert;
       }
       else
          user_cert.certificate_id 
             = temp_cert.certificate_id;

   }
 
   if (user_info)
      user_info->certificate = temp_cert;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (set_user)
   {

       Response_Type response;
       response.type = Response_Type::COMMAND_ONLY_TYPE;

       temp_strm.str("");
     
       temp_strm << "GET_USER RESPONSE 0 USER_ID " << user_id << " "
                 << "USER_NAME \"" << username << "\" PRIVILEGES " 
                 << temp_privileges << "U";


       response.command = temp_strm.str();

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "response.command == " << response.command << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


       response_deque.push_front(response);

       temp_strm.str("");

   }  /* |if (set_user)|  */



@q ****** (6) If |set_user == false|, return successfully.  @>

@ If |set_user == false|, return successfully.  
In this case, we don't retrieve the iRODS password from the database, decrypt it, 
and write it to a file.  Instead, we just return successfully with return value 0.
\initials{LDF 2013.05.17.}

@<|Scan_Parse_Parameter_Type::get_user| definition@>=

   if (set_user == false)
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':"
                << endl 
                << "`set_user' == `false'.  Not decrypting iRODS password and writing it to file."
                << endl
                << "Exiting function successfully with return value 0."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       return 0;

   }  /* |if (set_user == false)|  */

@q ****** (6) Lock |buffer| into RAM.  @>

@ Lock |buffer| into into RAM.  
\initials{LDF 2012.07.12.}

\LOG
\initials{LDF 2012.07.12.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_user| definition@>=

    char buffer[256];
    memset(buffer, 0, 256);

    errno = 0;
    status = mlock(buffer, 256);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':  `mlock' failed, "
             << "returning " << status << "."
             << endl 
             << strerror(errno)
             << endl 
             << "Can't lock memory for decrypted iRODS password for user `" 
             << username << "'."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        ++errors_occurred;

        return 1;

    }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':  "
             << "`mlock' succeeded."
             << endl;
        unlock_cerr_mutex(); 
  
    }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@

\LOG
\initials{LDF 2012.11.16.}
Now pushing |temp_filename| onto |vector<string> temp_file_vector|, so it will be deleted 
at the end of the run (thread).
\ENDLOG 

@<|Scan_Parse_Parameter_Type::get_user| definition@>=

    char temp_filename[] = "/tmp/gwirdsif.XXXXXX";

    int fd = mkstemp(temp_filename);
   
    if (fd == -1)
    {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str 
            << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':  "
            << "`mkstemp' failed, returning -1."
            << endl
            << "mkstemp error:  " << strerror(errno)
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;
       
       return 1;

    }  /* |if (fd == -1)|  */

#if DEBUG_COMPILE
    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str 
             << "In `Scan_Parse_Parameter_Type::get_user':  `mkstemp' succeeded.  "
             << "`temp_filename' == "
             << "`" << temp_filename << "'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */

    if (user_info == 0)
       temp_file_vector.push_back(temp_filename);  /* |irods_auth_filename|  */


    close(fd);
    fd = 0;

@q ****** (6) Decrypt iRODS password.  @>
@ Decrypt iRODS password.
\initials{LDF 2012.07.11.}

\LOG
\initials{LDF 2012.07.11.}
Added this section.

\initials{LDF 2012.09.12.}
Now storing timestamp for the ``scrambled'' iRODS password in the database
and retrieving it for the call to \.{touch} below.

\initials{LDF 2013.04.17.}
Now calling \.{touch} with the \.{-m} option for changing only the time of 
last modification.  The time of last access is not changed.  The modification time
must be that of the original file created by \.{iinit}, otherwise the iRODS server 
considers the ``scrambled'' password to be invalid.  The last access time is used in
|purge_server_logs| to determine whether the temporary file can be deleted.

\initials{LDF 2013.09.27.}
Added code for passing a passphrase to \.{gpg}.  This will work even if the 
secret key used for decryption doesn't have a passphrase.  In this case,
\.{gpg} will succeeded, even though a passphrase is supplied.  It doesn't matter 
what it is.  However, I have now switched over to using iRODS passwords that have
been encrypted with a keypair where the secret key does have a passphrase.
\ENDLOG

@q ****** (6) @>

@<|Scan_Parse_Parameter_Type::get_user| definition@>=


#if 1 /* 0 */
bool save_DEBUG = DEBUG;
DEBUG = false; /* |true|  */
#endif 

    temp_strm.str("");

    if (gpg_passphrase != 0 && strlen(gpg_passphrase) > 0)
    {
@q ******* (7) @>

        pthread_mutex_lock(&gpg_passphrase_fifo_mutex);

        status = write_to_fifo(gpg_passphrase, 
                               gpg_passphrase_length,
                               gpg_passphrase_fifo_fd);

        if (status != 0)
        {
            lock_cerr_mutex(); 
            cerr << thread_ctr_str 
                 << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':  "
                 << "`write_to_fifo' failed, returning " << status << "."
                 << endl
                 << "Failed to write `gpg_passphrase' to FIFO " 
                 << "`" << gpg_passphrase_fifo_name << "'."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            pthread_mutex_unlock(&gpg_passphrase_fifo_mutex);

            ++errors_occurred;
       
            return 1;
           

        }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_ctr_str 
                 << "In `Scan_Parse_Parameter_Type::get_user':  "
                 << "`write_to_fifo' succeeded, returning 0."
                 << endl
                 << "Wrote `gpg_passphrase' to FIFO " 
                 << "`" << gpg_passphrase_fifo_name << "' successfully."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

    }  /* |if (gpg_passphrase != 0 && strlen(gpg_passphrase) > 0)|  */

@q ****** (6) @>
@
\LOG
\initials{LDF 2014.01.07.}
Now using |gpg_homedir| in GPG command.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::get_user| definition@>=

    temp_strm << "env LANG=en_US.UTF-8 echo -e \"" << irods_password_encrypted 
              << "\\n\" | gpg --homedir " << gpg_homedir << " --batch --decrypt ";

    if (gpg_passphrase != 0 && strlen(gpg_passphrase) > 0)
       temp_strm << "--passphrase-file '" << gpg_passphrase_fifo_name << "' ";

    temp_strm << "2>/dev/null > " << temp_filename << " "
              << "&& touch -m " << temp_filename 
              << " --date=\"" << irods_password_encrypted_timestamp << "\";"
              << "echo $?";

#if DEBUG_COMPILE 
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "temp_strm.str() == " << temp_strm.str() << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

    FILE *fp = popen(temp_strm.str().c_str(), "r");

    if (fp == 0)
    {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`popen' failed, returning NULL.  Failed to decrypt iRODS password for "
            << "user `" << username << "' or write it to `" << temp_filename << "' or to set its "
            << "timestamp."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (gpg_passphrase != 0 && strlen(gpg_passphrase) > 0)
          pthread_mutex_unlock(&gpg_passphrase_fifo_mutex);

       return 1;

    }  /* |if (fp == 0)|  */

#if DEBUG_COMPILE 
    else if (DEBUG)
    {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`popen' succeeded."
            << endl;
       unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

#if 1 /* 0 */
DEBUG = save_DEBUG; 
#endif 



@q ****** (6) Read exit status GPG command from |fp|.  @>

@ Read exit status GPG command from |fp|.
This will be non-zero if signature verification failed.
\initials{LDF 2012.07.12.}

@<|Scan_Parse_Parameter_Type::get_user| definition@>=

    char *temp_str = fgets(buffer, 16, fp);  /* Testing LDF 2012.09.10.  */

    pclose(fp);
    fp = 0;

    int temp_ret_val = atoi(buffer);  
             
#if DEBUG_COMPILE                          
    if (DEBUG)
    {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`fgets' succeeded, reading " << strlen(buffer) << " characters."
            << endl 
            << "`temp_ret_val' == \"" 
            << temp_ret_val << "\""
            << endl;
       unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

    if (temp_ret_val != 0)
    {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':"
            << endl 
            << "`temp_ret_val' == " << temp_ret_val << " (!= 0)."
            << endl
            << "`gpg --decrypt' or `touch' failed.  Possibly the signature was invalid."
            << endl 
            << "Authentication/authorization failed for user `" << username << "'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (gpg_passphrase != 0 && strlen(gpg_passphrase) > 0)
          pthread_mutex_unlock(&gpg_passphrase_fifo_mutex);

       ++errors_occurred;
       return 1;

    }  /* |if (temp_ret_val != 0)|  */

#if DEBUG_COMPILE 
    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::get_user':"
             << endl 
             << "`temp_ret_val' == 0."
             << endl
             << "`gpg --decrypt' and `touch' succeeded.  Signature is valid."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

    if (gpg_passphrase != 0 && strlen(gpg_passphrase) > 0)
       pthread_mutex_unlock(&gpg_passphrase_fifo_mutex);

    errno = 0;

    memset(buffer, 0, 256);
    status = munlock(buffer, 256);

    if (status == -1)
    {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str 
            << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':  "
            << "`munlock' failed, returning -1."
            << endl
            << "munlock error:  " << strerror(errno)
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

    }  /* |if (status == -1)|  */

#if DEBUG_COMPILE 
    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "Unlocked memory successfully." << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */   
#endif  /* |DEBUG_COMPILE|  */ 

    irods_auth_filename = temp_filename;

     if (user_info)
        user_info->irods_auth_filename = irods_auth_filename;

@q ****** (6) Create iRODS environment file  @>
@ Create iRODS environment file.
\initials{LDF 2013.03.22.}

\LOG
\initials{LDF 2013.03.22.}
Added this section.
\ENDLOG  
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

     strcpy(temp_filename, "/tmp/gwirdsif.XXXXXX");

     fd = mkstemp(temp_filename);
   
     if (fd == -1)
     {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str 
             << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':  "
             << "`mkstemp' failed, returning -1."
             << endl
             << "mkstemp error:  " << strerror(errno)
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        ++errors_occurred;
        return 1;

     }  /* |if (fd == -1)|  */

#if DEBUG_COMPILE
     else if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << thread_ctr_str
              << "In `Scan_Parse_Parameter_Type::get_user':  `mkstemp' succeeded.  "
              << "`temp_filename' == "
              << "`" << temp_filename << "'."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */

     if (user_info == 0)
        temp_file_vector.push_back(temp_filename);  /* |irods_env_filename|  */

     close(fd);
     fd = 0;

     irods_env_filename = temp_filename;

     if (user_info)
        user_info->irods_env_filename = irods_env_filename;

@q ****** (6) Write environment variables for iRODS to |env_strm|, i.e., |irods_env_filename|.  @>

@ Write environment variables for iRODS to |env_strm|, i.e., |irods_env_filename|.

@:IRODS BUGS@>
@:NOTE@> !! PLEASE NOTE:  The file \filename{.irods/.irodsEnv} must exist below the 
home directory of the user under whose account the server program `gwirdsif' is running, 
even though a different environment file is used!  This would appear to be a bug in iRODS.
\initials{LDF 2013.03.22.}

\LOG
\initials{LDF 2013.03.22.}
Added this section.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::get_user| definition@>=

     ofstream env_strm;

     env_strm.open(irods_env_filename.c_str());

     if (!env_strm.is_open())
     {
         lock_cerr_mutex(); 
         cerr << "ERROR!  In `Scan_Parse_Parameter_Type::get_user':" 
              << endl
              << "`ofstream::open' failed, returning `false':"
              << endl 
              << "Failed to open `" << irods_env_filename << "'."
              << endl
              << "Exiting function unsuccessfully with return value 1."
              << endl;
         unlock_cerr_mutex();
 
         ++errors_occurred;
         return 1;

     }  /* |if (!env_strm.is_open())|  */

#if DEBUG_COMPILE
     else if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "In `Scan_Parse_Parameter_Type::get_user':" 
              << endl
              << "`ofstream::open' succeeded, returning `true':"
              << endl 
              << "Opened `irods_env_filename' == `" << irods_env_filename << "' successfully."
              << endl;
         unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

     env_strm << "irodsHost '" << gwirdsif_hostname.c_str() << "'" << endl 
              << "irodsPort 1247" << endl 
              << "irodsDefResource '" << irods_default_resource.c_str() << "'" << endl 
              << "irodsHome '" << irods_homedir.c_str() << "'" << endl 
              << "irodsCwd '" << irods_homedir.c_str() << "'" << endl 
              << "irodsUserName '" << username.c_str() << "'" << endl 
              << "irodsZone '" << irods_zone.c_str() << "'" << endl 
              << "irodsAuthFileName '" << irods_auth_filename << "'" << endl;


     env_strm.close();

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_user| definition@>=

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str
            << "Exiting `Scan_Parse_Parameter_Type::get_user' successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   if (result)
      mysql_free_result(result);
  
   return 0;
  
}  /* |Scan_Parse_Parameter_Type::get_user|  */


@q **** (4) Set user info.  (|set_user_info|).  @>
@ Set user info.  (|set_user_info|).
\initials{LDF 2013.05.19.}

\LOG
\initials{LDF 2013.05.19.}
Added this function declaration.  The definition is in \filename{spptfnc1.web}.
\ENDLOG

@q ***** (5) @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
set_user_info(User_Info_Type &user_info) const;


@q **** (4) get privileges gwirdsif.  (|get_privileges_gwirdsif|).  @>
@ get privileges gwirdsif.  (|get_privileges_gwirdsif|).
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this function declaration.  The definition is in \filename{spptfnc1.web}.

\initials{LDF 2014.02.18.}
Renamed this function.  Old name:  |get_privileges|.  
New name:  |get_privileges_gwirdsif|.  About to add 
|Scan_Parse_Parameter_Type::get_privileges_gwirdcli|.
\ENDLOG

@q ***** (5) @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
get_privileges_gwirdsif(int curr_user_id = 0, unsigned int *privs = 0);

@q **** (4) get privileges gwirdcli.  (|get_privileges_gwirdcli|).  @>
@ get privileges gwirdcli.  (|get_privileges_gwirdcli|).
\initials{LDF 2014.02.18.}

\LOG
\initials{LDF 2014.02.18.}
Added this function declaration.  The definition is in \filename{spptfnc1.web}.
\ENDLOG

@q ***** (5) @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
get_privileges_gwirdcli(int curr_user_id = 0, unsigned int *privs = 0);

@q **** (4) Show.  @>
@ Show.  
\initials{LDF 2012.06.27.}

\LOG
\initials{LDF 2012.06.27.}
Added this function.

\initials{LDF 2012.07.27.}
Added optional argument |stringstream *strm| with default 0.

\initials{LDF 2012.11.16.}
Added code for outputting the filenames on |temp_file_vector|, if present.

\initials{LDF 2013.04.25.}
Added code for outputting the value of |int thread_cancel_state|.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

void
show(string s = "Scan_Parse_Parameter_Type:", stringstream *strm = 0);

@q ***** (5) Definition @>
@
@<|Scan_Parse_Parameter_Type::show| definition@>=

void
Scan_Parse_Parameter_Type::show(string s, stringstream *strm)
{
@q ****** (6) @>

   stringstream temp_strm;

   temp_strm << s << endl
             << "user_id ==                " << user_id
             << endl 
             << "username ==               " << username
             << endl;

   distinguished_name.show("distinguished_name:", &temp_strm);

   temp_strm << "privileges:"
             << endl
             << "   superuser:                          " 
             << (((privileges & SUPERUSER_PRIVILEGE) > 0U) ? 1 : 0)
             << endl 
             << "   delegate:                           " 
             << (((privileges & DELEGATE_PRIVILEGE) > 0U) ? 1 : 0)
             << endl 
             << "   add_groups:                         " 
             << (((privileges & ADD_GROUPS_PRIVILEGE) > 0U) ? 1 : 0)
             << endl 
             << "   delete_groups:                      " 
             << (((privileges & DELETE_GROUPS_PRIVILEGE) > 0U) ? 1 : 0)
             << endl 
             << "   delete_handles:                     " 
             << (((privileges & DELETE_HANDLES_PRIVILEGE) > 0U) ? 1 : 0)
             << endl 
             << "   delete_handle_values:               " 
             << (((privileges & DELETE_HANDLE_VALUES_PRIVILEGE) > 0U) ? 1 : 0)
             << endl 
             << "   delete_hs_admin_handle_values:      " 
             << (((privileges & DELETE_HS_ADMIN_HANDLE_VALUES_PRIVILEGE) > 0U) ? 1 : 0)
             << endl 
             << "   delete_last_hs_admin_handle_value:  " 
             << (((privileges & DELETE_LAST_HS_ADMIN_HANDLE_VALUE_PRIVILEGE) > 0U) ? 1 : 0)
             << endl 
             << "   undelete_handle_values:             " 
             << (((privileges & UNDELETE_HANDLE_VALUES_PRIVILEGE) > 0U) ? 1 : 0)
             << endl 
             << "   show_user_info:                     "   
             << (((privileges & SHOW_USER_INFO_PRIVILEGE) > 0U) ? 1 : 0)
             << endl 
             << "   show_groups:                        " 
             << (((privileges & SHOW_GROUPS_PRIVILEGE) > 0U) ? 1 : 0)
             << endl 
             << "   show_certificates:                  " 
             << (((privileges & SHOW_CERTIFICATES_PRIVILEGE) > 0U) ? 1 : 0)
             << endl          
             << "   show_distinguished_names:           " 
             << (((privileges & SHOW_DISTINGUISHED_NAMES_PRIVILEGE) > 0U) ? 1 : 0)
             << endl          
             << "   show_privileges:                    " 
             << (((privileges & SHOW_PRIVILEGES_PRIVILEGE) > 0U) ? 1 : 0)
             << endl          
             << "   pull_request_self:                  " 
             << (((privileges & PULL_REQUEST_SELF_PRIVILEGE) > 0U) ? 1 : 0)
             << endl          
             << "   pull_request_group:                 " 
             << (((privileges & PULL_REQUEST_GROUP_PRIVILEGE) > 0U) ? 1 : 0)
             << endl          
             << "   pull_request_all:                   " 
             << (((privileges & PULL_REQUEST_ALL_PRIVILEGE) > 0U) ? 1 : 0)
             << endl          
             << "   pull_response_self:                 " 
             << (((privileges & PULL_RESPONSE_SELF_PRIVILEGE) > 0U) ? 1 : 0)
             << endl          
             << "   pull_response_group:                " 
             << (((privileges & PULL_RESPONSE_GROUP_PRIVILEGE) > 0U) ? 1 : 0)
             << endl          
             << "   pull_response_all:                  " 
             << (((privileges & PULL_RESPONSE_ALL_PRIVILEGE) > 0U) ? 1 : 0)
             << endl          
             << "sock                     == " << sock
             << endl 
             << "irods_auth_filename      == " << irods_auth_filename
             << endl 
             << "irods_env_filename       == " << irods_env_filename
             << endl 
             << "irods_zone               == " << irods_zone
             << endl 
             << "irods_default_resource   == " << irods_default_resource
             << endl 
             << "irods_homedir            == " << irods_homedir
             << endl 
             << "irods_current_dir        == " << irods_current_dir
             << endl
             << "data_filename            == " << data_filename
             << endl
             << "input_commands           == " << input_commands
             << endl
             << "gpg_key_pair_id          == " << gpg_key_pair_id
             << endl 
             << "gpg_key_fingerprint      == " << gpg_key_fingerprint
             << endl
             << "temp_gpg_key_fingerprint ==  " << temp_gpg_key_fingerprint
             << endl;

   if (group_vector.size() > 0)
   {

      temp_strm << "group_vector:" << endl;

      for (vector<Group_Type>::const_iterator iter = group_vector.begin();
           iter != group_vector.end();
           ++iter)
           iter->show("", &temp_strm);

   }
   else
      temp_strm << "group_vector is empty"
                << endl;

   if (strlen(data_buffer) == 0)
       temp_strm << "strlen(data_buffer) == 0" << endl;
   else
   {
       temp_strm << "strlen(data_buffer) == " << strlen(data_buffer) 
                 << endl
                 << "data_buffer == " 
                 << endl
                 << data_buffer << endl; 
   }

   temp_strm << "server_finished == " << server_finished
             << endl 
             << "client_finished == " << client_finished
             << endl;

   temp_strm << "default_handle_prefix_id == " << default_handle_prefix_id
             << endl
             << "default_handle_prefix    == " << default_handle_prefix
             << endl
             << "default_institute_id == " << default_institute_id
             << endl
             << "default_institute_name    == " << default_institute_name
             << endl
             << "delay_value == " << delay_value
             << endl;

   if (irods_object)
      temp_strm << "`irods_object' is non-null." << endl;
   else
      temp_strm << "`irods_object' is NULL." << endl;


   temp_strm << "`temp_file_vector.size()' == " << temp_file_vector.size() << endl;

   if (temp_file_vector.size() > 0)
      temp_strm << "Filenames:" << endl;

   for (vector<string>::const_iterator iter = temp_file_vector.begin();
        iter != temp_file_vector.end();
        ++iter)
      temp_strm << "   " << *iter << endl;

   temp_strm << "`string_vector.size()' == " << string_vector.size() << endl;

   if (string_vector.size() > 0)
      temp_strm << "Strings:" << endl;

   for (vector<string>::const_iterator iter = string_vector.begin();
        iter != string_vector.end();
        ++iter)
      temp_strm << "   " << *iter << endl;

   temp_strm << "`int_vector.size()' == " << int_vector.size() << endl;

   if (int_vector.size() > 0)
      temp_strm << "Integers:" << endl;

   for (vector<int>::const_iterator iter = int_vector.begin();
        iter != int_vector.end();
        ++iter)
      temp_strm << "   " << *iter << endl;

   temp_strm << "`errors_occurred' == " << errors_occurred
             << endl 
             << "`warnings_occurred' == " << warnings_occurred
             << endl
             << "`notices_occurred' == " << notices_occurred
             << endl
             << "response_deque.size() == " << response_deque.size()
             << endl

             << "delayed_response_deque.size() == " << delayed_response_deque.size()
             << endl
             
             << "pending_operations_flag == " << pending_operations_flag
             << endl

             << "thread_cancel_state == ";

   if (thread_cancel_state == PTHREAD_CANCEL_ENABLE)
       temp_strm << "PTHREAD_CANCEL_ENABLE" << endl;
   else if (thread_cancel_state == PTHREAD_CANCEL_DISABLE)
       temp_strm << "PTHREAD_CANCEL_DISABLE" << endl;

   else
       temp_strm << thread_cancel_state << endl;  /* This should never occur.
                                                     \initials{LDF 2013.04.25.}  */



   temp_strm << "user_id_map.size() == " << user_id_map.size()
             << endl;

   if (user_id_map.size() > 0)
   {
       temp_strm << "user_id_map:"
                 << endl;

       for (map<string, int>::const_iterator iter = user_id_map.begin();
            iter != user_id_map.end();
            ++iter)
       {
           temp_strm << iter->first << ", " << iter->second << endl;
       }


           temp_strm << endl;
   }


   temp_strm << "user_info_map.size() == " << user_info_map.size()
             << endl;

   if (user_info_map.size() > 0)
   {
       temp_strm << "user_info_map:"
                 << endl;

       for (map<int, User_Info_Type>::const_iterator iter = user_info_map.begin();
            iter != user_info_map.end();
            ++iter)
       {
           temp_strm << iter->first << ":" << endl;
           iter->second.show("User_Info_Type:", &temp_strm); 
       }

           temp_strm << endl;
   }

   if (is_gwirdsif)
   {
       user_cert.show("user_cert:", &temp_strm, false);

   }  /* |if (is_gwirdsif)|  */

   if (cert_ptr)
   {
      temp_strm << "`cert_ptr' is non-NULL." << endl;
      cert_ptr->show("*cert_ptr:", &temp_strm, false);
   }

   else
      temp_strm << "`cert_ptr' is NULL." << endl;

   if (user_info_ptr)
   {
        temp_strm << "`user_info_ptr' is non-NULL." << endl;
        user_info_ptr->show("*user_info_ptr:", &temp_strm);
   }
   else
      temp_strm << "`user_info_ptr' is NULL." << endl;

   if (strm)
      *strm << temp_strm.str();
   else
      cerr << temp_strm.str();

@q ****** (6) @>

   return;

} /* End of |Scan_Parse_Parameter_Type::show| definition   */

@q **** (4) Submit SQL query. @>

@ Submit SQL query.
\initials{LDF 2012.07.11.}

\LOG
\initials{LDF 2012.07.11.}
Added this function.  I've copied it from the version I wrote for the OptiNum-Grid project and
modified it slightly.

\initials{LDF 2012.07.16.}
Moved the original version of this function from this file
(\filename{scprpmtp.web}) to \filename{utilfncs.web}.  Changed it, so that it is
no longer a member function of |Scan_Parse_Parameter_Type|.  Added the required argument
|MYSQL *mysql_ptr| and the optional argument |string thread_ctr_str| with default |""|. 
\par
The new version of this function below calls the non-class member version in 
\filename{utilfncs.web}, passing |this| and a string for the ``thread counter'' as arguments.

\initials{LDF 2012.09.18.}
Added code for exiting unsuccessfully with return value 1 if |is_gwirdsif == false|.

\initials{LDF 2013.09.03.}
Removed code that tests the value of |is_gwirdsif| and exits if it's |false|.  Previously, 
this function was only meant to be used by \.{gwirdsif}, but that's not the case anymore.

\initials{LDF 2014.01.22.}
Made |unsigned int *row_ctr| and |unsigned int *field_ctr| required arguments.  
This function didn't work properly when called with a value for |row_ctr| 
but not for |field_ctr|.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
int
submit_mysql_query(string query,
                   MYSQL_RES*& result,
                   unsigned int *row_ctr,
                   unsigned int *field_ctr,
                   long *affected_rows = 0);

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::submit_mysql_query| definition@>=

int
Scan_Parse_Parameter_Type::submit_mysql_query(string query,
                                              MYSQL_RES*& result, 
                                              unsigned int *row_ctr, 
                                              unsigned int *field_ctr,
                                              long *affected_rows)       
{
   stringstream temp_strm;

   temp_strm << "[Thread " << thread_ctr << "] ";

   /* |::| causes the global (i.e., non-class) version of |submit_mysql_query|
      to be called.
      initials{LDF 2012.07.16.}  */

   return ::submit_mysql_query(query, result, mysql_ptr, 
                               row_ctr, field_ctr, affected_rows, 
                               temp_strm.str());
}

@q **** (4) Submit multiple SQL queries (|Scan_Parse_Parameter_Type::submit_mysql_queries|).  @>

@ Submit multiple SQL queries (|Scan_Parse_Parameter_Type::submit_mysql_queries|).
\initials{LDF 2013.09.03.}

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
submit_mysql_queries(vector<string> &query_vector,
                     MYSQL_RES **result_array,
                     vector<unsigned int *> &row_ctr_vector,
                     vector<unsigned int *> &field_ctr_vector,
                     vector<long int *> &affected_rows_vector,
                     bool continue_on_error = false);


@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::submit_mysql_query| definition@>=
int
Scan_Parse_Parameter_Type::submit_mysql_queries(vector<string> &query_vector,
                                                MYSQL_RES **result_array,  
                                                vector<unsigned int *> &row_ctr_vector,
                                                vector<unsigned int *> &field_ctr_vector,
                                                vector<long int *> &affected_rows_vector,
                                                bool continue_on_error)         
{
@q ****** (6) @>

     bool DEBUG = false;  /* |true|  */
     set_debug_level(DEBUG, 0, 0); 

     int status;

     string thread_str;

     stringstream temp_strm;

     temp_strm << "[Thread " << thread_ctr << "] ";

     thread_str = temp_strm.str();

     temp_strm.str("");

     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::submit_mysql_queries'."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::submit_mysql_query| definition@>=

     status = ::submit_mysql_queries(query_vector,
                                     result_array,
                                     mysql_ptr,
                                     row_ctr_vector,
                                     field_ctr_vector,
                                     affected_rows_vector,
                                     continue_on_error,
                                     thread_str);

     if (status != 0)
     {
         lock_cerr_mutex(); 
         cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::submit_mysql_queries':"
              << endl
              << "Non-class function `submit_mysql_queries' failed, returning " << status << ":"
              << endl
              << mysql_error(mysql_ptr)
              << endl
              << "Exiting function unsuccessfully with return value " << status << "."
              << endl;
         unlock_cerr_mutex();

         return 1;
      
     }  /* |if (status != 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::submit_mysql_query| definition@>=

#if DEBUG_COMPILE
     else if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << thread_str << "In `Scan_Parse_Parameter_Type::submit_mysql_queries':"
              << endl
              << "Non-class function `submit_mysql_queries' succeeded, returning 0."
              << endl;
         unlock_cerr_mutex();

     }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::submit_mysql_query| definition@>=

     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << thread_str << "Exiting `Scan_Parse_Parameter_Type::submit_mysql_queries' "
              << "successfully with return value 0."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */

     return 0;

}  /* End of |Scan_Parse_Parameter_Type::submit_mysql_queries| definition  */

@q **** (4) Send TAN list.  @>
@ Send TAN list.
\initials{LDF 2012.07.19.}

\LOG
\initials{LDF 2012.07.19.}
Added this function.

\initials{LDF 2012.09.18.}
Added code for exiting unsuccessfully with return value 1 if |is_gwirdsif == false|.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
int
send_tan_list(void);

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=
int
Scan_Parse_Parameter_Type::send_tan_list(void)

{
@q ****** (6) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   if (!is_gwirdsif)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] WARNING!  "
            << "In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`is_gwirdsif' == `false'.  This function is only meant to be used by the server "
            << "program `gwirdsif'."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;
       return 1;

   }  /* |if (!is_gwirdsif)|  */

   stringstream temp_strm;

   temp_strm << "[Thread " << thread_ctr << "] ";

   string thread_ctr_str = temp_strm.str();

   temp_strm.str("");

   int status;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "Entering `Scan_Parse_Parameter_Type::send_tan_list'." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

   MYSQL_RES *result = 0;
   MYSQL_ROW curr_row;
   unsigned int row_ctr;
   unsigned int field_ctr;
   long int affected_rows;

   stringstream sql_strm;

   int TAN_ctr = 0;

@q ****** (6) Lock TANs table.  @>

@ Lock \.{TANs} table.  
\initials{LDF 2012.07.19.}

@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

   pthread_mutex_lock(&sql_lock_tables_mutex);

   status = submit_mysql_query("lock tables TANs write", result, 0, 0, 0);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`submit_mysql_query' failed, returning " << status << "."
            << endl
            << "Failed to lock `TANs' table."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
          mysql_free_result(result);

       pthread_mutex_unlock(&sql_lock_tables_mutex);

       ++errors_occurred;
       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`submit_mysql_query' succeeded, returning 0."
            << endl
            << "Locked `TANs' table successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   mysql_free_result(result);
   result = 0;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

   sql_strm << "select count(TAN) from TANs where user_id = 0";

   #if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr, 0);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`submit_mysql_query' failed, returning " << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
          mysql_free_result(result);
          result = 0;
       }

       submit_mysql_query("unlock tables", result, 0, 0, 0);

       if (result)
          mysql_free_result(result);

       pthread_mutex_unlock(&sql_lock_tables_mutex);

       ++errors_occurred;
       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`submit_mysql_query' succeeded, returning 0."
            << endl
            << "`row_ctr' == " << row_ctr
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

   if ((curr_row = mysql_fetch_row(result)) == 0)
   {
       lock_cerr_mutex();
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`mysql_fetch_row' failed:"
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Exiting `Scan_Parse_Parameter_Type::send_tan_list' unsuccessfully "
            << "with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       submit_mysql_query("unlock tables", result, 0, 0, 0);  

       mysql_free_result(result);
                                  
       pthread_mutex_unlock(&sql_lock_tables_mutex);
                         
       ++errors_occurred;

       return 1;

   }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl 
            << "`mysql_fetch_row' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

   if (curr_row[0] == 0 || strlen(curr_row[0]) == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl 
            << "`curr_row[0]' is NULL or empty.  Can't set `TAN_ctr'."
            << endl 
            << "Exiting `Scan_Parse_Parameter_Type::send_tan_list' unsuccessfully "
            << "with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       submit_mysql_query("unlock tables", result, 
                          0, 0, 0);

       if (result)
           mysql_free_result(result);


       pthread_mutex_unlock(&sql_lock_tables_mutex);

       ++errors_occurred;
       return 1;

   }  /* |if (curr_row[0] == 0 || strlen(curr_row[0]) == 0)|  */

   TAN_ctr = atoi(curr_row[0]);
   
#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':  "
            << "`curr_row[0]' == " << curr_row[0] << endl
            << "`TAN_ctr' == " << TAN_ctr
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   mysql_free_result(result);
   result = 0;   

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

   if (TAN_ctr < 100)
   {
@q ******* (7) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':"
                << endl
                << "(`TAN_ctr' == " << TAN_ctr << ") < 100"
                << endl
                << "Calling `generate_tans'."
                << endl;

           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

       status = generate_tans(mysql_ptr, 200, 100, thread_ctr_str);

       if (status != 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
                << endl 
                << "`generate_tans' failed, returning " << status << "."
                << endl 
                << "Exiting `Scan_Parse_Parameter_Type::send_tan_list' unsuccessfully "
                << "with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           submit_mysql_query("unlock tables", result, 
                              0, 0, 0);

           if (result)
               mysql_free_result(result);

           pthread_mutex_unlock(&sql_lock_tables_mutex);


           ++errors_occurred;
           return 1;

       }  /* |if (status != 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':"
                << endl 
                << "`generate_tans' succeeded, returning 0."
                << endl;

           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

@q ******* (7) @>

   }  /* |if (TAN_ctr < 100)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

   sql_strm.str("");

   sql_strm << "update TANs set user_id = -1 where user_id = 0 limit 50";

   #if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   status = submit_mysql_query(sql_strm.str(), result, 0, 0, &affected_rows);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`submit_mysql_query' failed, returning " << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
          mysql_free_result(result);
          result = 0;
       }

       submit_mysql_query("unlock tables", result, 0, 0, 0);

       if (result)
          mysql_free_result(result);

       pthread_mutex_unlock(&sql_lock_tables_mutex);

       ++errors_occurred;
       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`submit_mysql_query' succeeded, returning 0."
            << endl
            << "`affected_rows' == " << affected_rows
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   if (affected_rows == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`affected_rows' == 0."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
          mysql_free_result(result);
          result = 0;
       }

       submit_mysql_query("unlock tables", result, 0, 0, 0);

       if (result)
          mysql_free_result(result);

       pthread_mutex_unlock(&sql_lock_tables_mutex);

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */

   else if (affected_rows != 50)
   {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "WARNING!  In `Scan_Parse_Parameter_Type::send_tan_list':"
             << endl
             << "(`' == " << affected_rows << ") != 50"
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

   }  /* |else if (affected_rows != 50)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`affected_rows' == 50. (This is how it should be.)"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   mysql_free_result(result);
   result = 0;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

   stringstream tan_strm;

   tan_strm << "echo -e \"TAN List for " << username << "\\n\\n";

   /* !! TODO:   LDF 2012.07.19.  Add more information, datestamp, etc.  */

   sql_strm.str("");

   sql_strm << "select TAN from TANs where user_id = -1";

   #if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr, 0);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`submit_mysql_query' failed, returning " << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
          mysql_free_result(result);
          result = 0;
       }

       submit_mysql_query("unlock tables", result, 0, 0, 0);

       if (result)
          mysql_free_result(result);

       pthread_mutex_unlock(&sql_lock_tables_mutex);

       ++errors_occurred;
       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`submit_mysql_query' succeeded, returning 0."
            << endl
            << "`row_ctr' == " << row_ctr
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

   for (int i = 0; i < row_ctr; ++i) 
   {
@q ******* (7) @>

       if ((curr_row = mysql_fetch_row(result)) == 0)
       {
           lock_cerr_mutex();
           cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
                << endl
                << "`mysql_fetch_row' failed:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting `Scan_Parse_Parameter_Type::send_tan_list' unsuccessfully "
                << "with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           submit_mysql_query("unlock tables", result, 0, 0, 0);  
                                                                  
           if (result)
              mysql_free_result(result);

           pthread_mutex_unlock(&sql_lock_tables_mutex);

           ++errors_occurred;
           return 1;

       }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':"
                << endl 
                << "`mysql_fetch_row' succeeded."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

       if (curr_row[0] == 0 || strlen(curr_row[0]) == 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
                << endl 
                << "`curr_row[0]' is NULL or empty."
                << endl 
                << "Exiting `Scan_Parse_Parameter_Type::send_tan_list' unsuccessfully "
                << "with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           submit_mysql_query("unlock tables", result, 
                              0, 0, 0);

           if (result)
               mysql_free_result(result);


           pthread_mutex_unlock(&sql_lock_tables_mutex);

           ++errors_occurred;
           return 1;

       }  /* |if (curr_row[0] == 0 || strlen(curr_row[0]) == 0)|  */

@q ******* (7) @>

       tan_strm << curr_row[0] << "\\n";

@q ******* (7) @>

   }  /* |for|  */

@q ****** (6) @>
@
\LOG
\initials{LDF 2013.09.20.}
Replaced ``hard-wired'' GPG key IDs with |gpg_key_id| for the signing key
and |Scan_Parse_Parameter_Type::public_key_id| for the key used for encryption.

\initials{LDF 2014.01.10.}
Changed name of |string Scan_Parse_Parameter_Type::public_key_id| to |gpg_key_id|.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

   mysql_free_result(result);
   result = 0;

   tan_strm << "\" | gpg --encrypt --armor --homedir " << gpg_homedir 
            << " -r " << gpg_key_fingerprint << " --sign -u " << gpg_key_fingerprint;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "tan_strm.str() == " << tan_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   FILE *fp = popen(tan_strm.str().c_str(), "r");

   if (fp == 0)
   {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
             << endl 
             << "`popen' failed, returning 0."
             << endl 
             << "Failed to encrypt TAN list."
             << endl 
             << "Exiting `Scan_Parse_Parameter_Type::send_tan_list' unsuccessfully "
             << "with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        submit_mysql_query("unlock tables", result, 
                           0, 0, 0);

        if (result)
            mysql_free_result(result);

        pthread_mutex_unlock(&sql_lock_tables_mutex);
 
        ++errors_occurred;
        return 1;

   }  /* |if (fp == 0)|  */
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl 
            << "`popen' succeeded.  Encrypted TAN list successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   ofstream out_strm;

/* !! TODO:  LDF 2012.07.19.  Create temporary file, perhaps. Add code
   for sending using mailx or sendmail.  */

   unlink("/tmp/abc");
   out_strm.open("/tmp/abc");

   char buffer[2048];

   status = 0;

   do
   {
        memset(buffer, 0, 2048);
        status = fread(buffer, 1, 2047, fp);

        if (status > 0)
          out_strm << buffer;

   } while (status == 2047);

   out_strm.close();

   pclose(fp);
   fp = 0;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

   sql_strm.str("");

   sql_strm << "update TANs set user_id = " << user_id << " where user_id = -1";

   #if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   status = submit_mysql_query(sql_strm.str(), result, 0, 0, &affected_rows);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`submit_mysql_query' failed, returning " << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
          mysql_free_result(result);
          result = 0;
       }

       submit_mysql_query("unlock tables", result, 0, 0, 0);

       if (result)
          mysql_free_result(result);

       pthread_mutex_unlock(&sql_lock_tables_mutex);

       ++errors_occurred;
       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`submit_mysql_query' succeeded, returning 0."
            << endl
            << "`affected_rows' == " << affected_rows
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   if (affected_rows == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`affected_rows' == 0."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
          mysql_free_result(result);
          result = 0;
       }

       submit_mysql_query("unlock tables", result, 0, 0, 0);

       if (result)
          mysql_free_result(result);

       ++errors_occurred;

       pthread_mutex_unlock(&sql_lock_tables_mutex);

       return 1;

   }  /* |if (status != 0)|  */

   else if (affected_rows != 50)
   {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "WARNING!  In `Scan_Parse_Parameter_Type::send_tan_list':"
             << endl
             << "(`' == " << affected_rows << ") != 50"
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

   }  /* |else if (affected_rows != 50)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`affected_rows' == 50. (This is how it should be.)"
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   mysql_free_result(result);
   result = 0;

@q ****** (6) Unlock TANs table.  @>

@ Unlock \.{TANs} table.  
\initials{LDF 2012.07.19.}

@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

   status = submit_mysql_query("unlock tables", result, 0, 0, 0);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`submit_mysql_query' failed, returning " << status << "."
            << endl
            << "Failed to unlock `TANs' table."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
          mysql_free_result(result);

       ++errors_occurred;

       pthread_mutex_unlock(&sql_lock_tables_mutex);

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::send_tan_list':"
            << endl
            << "`submit_mysql_query' succeeded, returning 0."
            << endl
            << "Unlocked `TANs' table successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

   pthread_mutex_unlock(&sql_lock_tables_mutex);
   mysql_free_result(result);
   result = 0;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>=

#if DEBUG_COMPILE

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str 
            << "Exiting `Scan_Parse_Parameter_Type::send_tan_list' successfully "
            << "with return value 0." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

#endif  /* |DEBUG_COMPILE|  */

   return 0;

@q ****** (6) @>

}  /* End of |send_tan_list| definition  */

@q **** (4) Set |expires|.  @>
@ Set |expires|.
\initials{LDF 2012.07.23.}

\LOG
\initials{LDF 2012.07.23.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
set_expires(time_t seconds, stringstream *out_strm = 0);

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::set_expires| definition@>=

int
Scan_Parse_Parameter_Type::set_expires(time_t seconds, stringstream *out_strm)
{
@q ***** (5) @>
  
   expires = time(0) + seconds;

   return 0;

} /* End of |Scan_Parse_Parameter_Type::set_expires| definition   */

@q **** (4) Get |expires|.  @>
@ Get |expires|.
\initials{LDF 2012.07.23.}

\LOG
\initials{LDF 2012.07.23.}
Added this function.
\ENDLOG

@q *** (3) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

time_t
get_expires(char *str = 0, size_t str_size = 0, stringstream *out_strm = 0);

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_expires| definition@>=

time_t
Scan_Parse_Parameter_Type::get_expires(char *str, size_t str_size, stringstream *out_strm)
{
@q ***** (5) @>

   /* !! TODO:  LDF 2012.07.23.  Add error handling, perhaps more options.   */

   if (str != 0)
   {
       struct tm tmp;
       struct tm* tmp_ptr = &tmp;

       localtime_r(&expires, tmp_ptr);

       strftime(str, str_size, "%Y-%m-%d %H:%M:%S %Z", tmp_ptr);
    }

    if (out_strm != 0)
    {
       *out_strm << expires;
    }

    return expires;

} /* End of |Scan_Parse_Parameter_Type::get_expires| definition   */

@q **** (4) ls.  @>
@ ls.  
\initials{LDF 2012.07.13.}

\LOG
\initials{LDF 2012.07.13.}
Added this function.

\initials{LDF 2012.07.20.}
Moved the definition of this function from this file (\filename{scprpmtp.web}) to 
\filename{spptjnif.web}.

\initials{LDF 2012.09.18.}
Restored this function declaration.  Apparently, I had removed it at some time in the past.

\initials{LDF 2013.01.10.}
Added optional arguments |string args = ""| and |bool do_response = true|.

\initials{LDF 2013.04.25.}
Replaced optional argument |string args| with optional argument |Response_Type *response = 0|.
Added optional argument |string filename_1 = ""|.
\ENDLOG

@q ***** (5) Declaration @>
@
@<|Scan_Parse_Parameter_Type| function declarations@>=
int
ls(char *buffer_ptr, 
   unsigned int buff_size, 
   string *filename, 
   Response_Type *response,
   string filename_1 = "",
   bool do_response = true);

@q ***** (5) Definition @>
@
@<|Scan_Parse_Parameter_Type::ls| definition@>=
int
Scan_Parse_Parameter_Type::ls(char *buffer_ptr, 
                              unsigned int buff_size, 
                              string *filename, 
                              Response_Type *response,
                              string filename_1,
                              bool do_response)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

    int status = 0;

    stringstream temp_strm;

    temp_strm << "[Thread " << thread_ctr << "] ";

    string thread_ctr_str = temp_strm.str();

    temp_strm.str("");

    *filename = "";  /* Will be set if this function creates a temporary file.
                        It should already be empty when passed to this function, 
                        but setting it to empty string here just to be sure.  
                        \initials{LDF 2012.11.28.}  */


#if DEBUG_COMPILE
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "Entering `Scan_Parse_Parameter_Type::ls'."
             << endl;

        if (response != 0)
        {
            cerr << "response->string_vector.size() == " 
                 << response->string_vector.size() << endl;

            if (response->string_vector.size() > 0)
               for (vector<string>::iterator iter = response->string_vector.begin();
                    iter != response->string_vector.end();
                    ++iter)
                  cerr << "*iter == " << *iter << endl;
            unlock_cerr_mutex(); 

        }  /* |if (response != 0)|  */


    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@ |char buffer[]| is used for the output of the \.{ils} command, i.e., either the icommand
\.{ils} or the function |lsUtil|, depending on what interface to the iRODS server is used.
The size, i.e., 1048576 is equal to $2^{20} = 1\rm{MB}$, so it should be large enough.
\par
If more bytes are returned than the |buff_size| argument (which should normally be the
global constant |BUFFER_SIZE|; $= 2048$ as of this date), the output will be dumped to
a temporary file and the filename will be stored in |*filename|.
\initials{LDF 2012.11.28.}

@<|Scan_Parse_Parameter_Type::ls| definition@>=

    char buffer[1048576];  

    memset(buffer, 0, 1048576);

@q ****** (6) @>
@
\LOG
\initials{LDF 2013.01.11.}
Removed code for decrypting the scrambled iRODS password.  It's not needed, and it shouldn't
work anyway, because in this case, \.{ils} would require the unscrambled password.  

\initials{LDF 2013.05.23.}
Removed ``\.{echo \$?}'' command from the end of the string passed to |popen|.
I wasn't testing the exit status of the shell command, anyway, and the trailing 0 
was sent to the client and displayed, which was confusing.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::ls| definition@>=


    errno = 0;
    temp_strm.str("");

    temp_strm << "env irodsEnvFile=" << irods_env_filename << " "
              << "ils";

    if (response != 0)
    {
        if (!response->flags.empty())
           temp_strm << " " << response->flags;

        for (vector<string>::iterator iter = response->string_vector.begin();
             iter != response->string_vector.end();
             ++iter)
            temp_strm << " " << *iter;

    } /* |if (response != 0)|  */

    if (!filename_1.empty())
       temp_strm << " " << filename_1;

    temp_strm << " 2>&1";


#if DEBUG_COMPILE 
    if (DEBUG)
    {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::ls':"
            << endl
            << "temp_strm.str() == " 
            << temp_strm.str() << endl;
       unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   FILE *fp = popen(temp_strm.str().c_str(), "r");

   if (fp == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::ls':"
            << endl
            << "`popen' failed, returning NULL.  Can't list directory contents."
            << endl;
          
       if (errno != 0)
           cerr << strerror(errno);
        
       cerr << "Exiting function unsuccessfully with return value 1." 
            << endl;
       unlock_cerr_mutex(); 

       if (do_response)
          strcpy(buffer_ptr, "LS RESPONSE 1 \"Server-side error:  `popen' failed\"");

       ++errors_occurred;

       return 1;

   }  /* |if (fp == 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::ls':"
            << endl
            << "`popen' succeeded.  `fp' is non-null. " << endl;  
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::ls| definition@>=

   memset(buffer, 0, 1048576);

   status = fread(buffer, 1, 1048576, fp);

   if (status == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::ls':"
            << endl
            << "`fread' failed, returning 0.  Can't list directory contents."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (do_response)
          strcpy(buffer_ptr, "LS RESPONSE 2 \"Server-side error:  `fread' failed\"");

       pclose(fp);

       ++errors_occurred;

       return 1;

   }  /* |if (status == 0)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::ls| definition@>=

   else if (status == 1048576)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::ls':"
            << endl
            << "`fread' returned " << status << " == 1048576."
            << endl 
            << "Output from pipe exceeds maximum length (i.e., 1048576 - 1 == 1048575)."
            << endl 
            << "Can't list files."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;

       unlock_cerr_mutex(); 

       if (do_response)
          strcpy(buffer_ptr, 
             "LS RESPONSE 3 \"Server-side error:  `ils' output too long (1048576 bytes)\"");


       pclose(fp);

       ++errors_occurred;

       return 1;

   }  /* |if (status == 1048576)|  */


@q ****** (6) Success.  @>

@ Success.  
\initials{LDF 2012.11.28.}

@<|Scan_Parse_Parameter_Type::ls| definition@>=

   else 
   {
@q ******* (7) @>
        
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::ls':"
                << endl
                << "`buffer' == " 
                << endl 
                << buffer << endl
                << "`strlen(buffer)' == " << strlen(buffer)
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 


@q ******* (7) @>

       if (do_response)
          strcpy(buffer_ptr, "LS RESPONSE 0 ");

       int temp_ctr = strlen(buffer) + strlen(buffer_ptr) + 2; 

       if (temp_ctr < buff_size - 1)
       {
#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex();
               cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::ls':"
                    << endl
                    << "`buffer' short enough.  Not dumping to file."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           strcat(buffer_ptr, "\"");
           strcat(buffer_ptr, buffer);
           strcat(buffer_ptr, "\"");
 
#if DEBUG_COMPILE
           if (DEBUG)   
           {
               lock_cerr_mutex(); 
               cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::ls':"
                    << endl
                    << "buffer_ptr == " << buffer_ptr << endl
                    << "Exiting function successfully with return value 0."
                    << endl;

               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           pclose(fp);

           return 0;

       }  /* |if| */

@q ******* (7) @>

@ @:TODO@> !! TODO:  In this case, |buffer| should be dumped to a file, which should
be sent to the client, which must call |Scan_Parse_Parameter_Type::receive_file|
to receive it.  However, it is very unlikely that the \.{ils} command 
(or its equivalent) will produce that many bytes.  Currently, |buff_size| should normally
be |BUFFER_SIZE|, which is 2048 as of this date, but I may increase it.
\initials{LDF 2012.11.28.}

@<|Scan_Parse_Parameter_Type::ls| definition@>=

       else   
       {       
           lock_cerr_mutex();
           cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::ls':"
                << endl
                << "`buffer' too long.  Not yet dumping to a file.  "
                << "This may be implemented in the future."
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           temp_strm.str("");
 
           if (do_response)
              temp_strm << "LS RESPONSE 4 ";

           temp_strm << "\"Response length exceeds maximum length:"
                     << endl 
                     << "Response length == " << temp_ctr << " bytes"
                     << endl  
                     << "Maximum length == " << buff_size - 1 << " bytes\"";

           strcpy(buffer_ptr, temp_strm.str().c_str());

           pclose(fp);

           ++errors_occurred;

           return 1;

       }  /* |else|  */

@q ******* (7) @>

   }  /* |else|  */        

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::ls| definition  */

@q **** (4) mv.  @>
@ mv.
\initials{LDF 2013.12.19.}

\LOG
\initials{LDF 2013.12.19.}
Added this function.
\ENDLOG

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
mv(Response_Type &response, string thread_str = "");

@q ***** (5) Definition @>
@
@<|Scan_Parse_Parameter_Type::mv| definition@>=

int
Scan_Parse_Parameter_Type::mv(Response_Type &response,
                              string thread_str)
{
@q ****** (6) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   char buffer[BUFFER_SIZE];
   memset(buffer, 0, BUFFER_SIZE);
  
   stringstream temp_strm;

   Response_Type new_response;
   new_response.type = Response_Type::COMMAND_ONLY_TYPE;

   string old_filename;
   string new_filename;

   int status = 0;

   size_t pos = 0;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::mv'."
            << endl;

       response.show("response:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mv| definition@>=

   if (response.string_vector.size() < 2)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR! In `Scan_Parse_Parameter_Type::mv':"
            << endl
            << "`response.string_vector.size()' == " << response.string_vector.size() << " "
            << "(< 2)"
            << endl
            << "This function requires two filenames (or paths)."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "MV RESPONSE " << GW_ERROR << " " << response.options << "U "
                 << "\"" << old_filename << "\" \"" << new_filename << "\" "
                 << "\"" << response.flags << "\" "
                 << "\"Old filename and/or new filename not specified\"";

       new_response.command = temp_strm.str();
   
       response_deque.push_back(new_response);

       return 1;

   }  /* |if|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mv| definition@>=

   else
   {
       old_filename = response.string_vector[0];
       new_filename = response.string_vector[1];

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str << "In `Scan_Parse_Parameter_Type::mv':"
                << endl
                << "`old_filename' == " << old_filename
                << endl 
                << "`new_filename' == " << new_filename
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }
        
@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mv| definition@>=

   pos = old_filename.find("/");

   if (pos == string::npos)
   {
      old_filename.insert(0, "/");
      old_filename.insert(0, irods_current_dir);
   }

   pos = new_filename.find("/");

   if (pos == string::npos)
   {
      new_filename.insert(0, "/");
      new_filename.insert(0, irods_current_dir);
   }

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Scan_Parse_Parameter_Type::mv':"
            << endl
            << "`old_filename' == " << old_filename
            << endl 
            << "`new_filename' == " << new_filename
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mv| definition@>=

   Irods_Object_Type irods_object_old(user_id, old_filename);

@q ****** (6) @>

@ Query the \.{gwirdsif.Irods\_Objects} database table for an iRODS object whose
path $=$ |old_filename|.  There should be one.
\initials{LDF 2014.01.03.}

@<|Scan_Parse_Parameter_Type::mv| definition@>=

@q ******* (7) @>

   status = irods_object_old.get_from_database(mysql_ptr);

@q ******* (7) @>

   if (status < 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::mv':"
            << endl
            << "`Irods_Object_Type::get_from_database' failed, returning " << status << "."
            << endl 
            << "Querying `gwirdsif' database for `old_filename' == `" << old_filename << "' "
            << "failed."
            << endl
            << "Will send error message to client and exit function unsuccessfully "
            << "with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "MV RESPONSE " << GW_ERROR << " " << response.options << "U "
                 << "\"" << old_filename << "\" \"" << new_filename << "\" "
                 << "\"" << response.flags << "\" "
                 << "\"Failed to query `gwirdsif' database for old filename.\"";

       new_response.command = temp_strm.str();
   
       response_deque.push_back(new_response);

       return 1;

   }  /* |if (status < 0)|  */
   
@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::mv| definition@>=

   else if (status == 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "WARNING!  In `Scan_Parse_Parameter_Type::mv':"
            << endl
            << "`Irods_Object_Type::get_from_database' returned 0:"
            << endl 
            << "No entry for `old_filename' == `" << old_filename << "' "
            << "in the `gwirdsif.Irods_Objects' database table."
            << endl
            << "This shouldn't be possible.  However, an iRODS object may still exist "
            << "in the iRODS archive."
            << endl 
            << "Continuing."
            << endl;
       unlock_cerr_mutex(); 

       ++warnings_occurred; 

       temp_strm.str("");

       temp_strm << "MV RESPONSE " << GW_WARNING << " " << response.options << "U "
                 << "\"" << old_filename << "\" \"" << new_filename << "\" "
                 << "\"" << response.flags << "\" "
                 << "\"No entry in the `gwirdsif.Irods_Objects' database table "
                 << "for old filename.\"";

       new_response.command = temp_strm.str();
   
       response_deque.push_back(new_response);

   }  /* |else if (status == 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::mv| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Scan_Parse_Parameter_Type::mv':"
            << endl
            << "`Irods_Object_Type::get_from_database' succeeded, returning " 
            << status << "."
            << endl 
            << "Entry found for `old_filename' == `" << old_filename << "' "
            << "in the `gwirdsif.Irods_Objects' database table:"
            << endl;

       irods_object_old.show("irods_object_old:");

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

@ Query the \.{gwirdsif.Irods\_Objects} database table for an iRODS object whose
path $=$ |new_filename|.  There shouldn't be one.
\initials{LDF 2014.01.03.}

@<|Scan_Parse_Parameter_Type::mv| definition@>=

   Irods_Object_Type irods_object_new(user_id, new_filename);

@q ******* (7) @>

   status = irods_object_new.get_from_database(mysql_ptr);

@q ******* (7) @>

   if (status < 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::mv':"
            << endl
            << "`Irods_Object_Type::get_from_database' failed, returning " << status << "."
            << endl 
            << "Querying `gwirdsif' database for `new_filename' == `" << new_filename << "' "
            << "failed."
            << endl
            << "Will send error message to client and exit function unsuccessfully "
            << "with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "MV RESPONSE " << GW_ERROR << " " << response.options << "U "
                 << "\"" << old_filename << "\" \"" << new_filename << "\" "
                 << "\"" << response.flags << "\" "
                 << "\"Failed to query `gwirdsif' database for new filename.\"";

       new_response.command = temp_strm.str();
   
       response_deque.push_back(new_response);

       return 1;

   }  /* |if (status < 0)|  */
   
@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::mv| definition@>=

   else if (status > 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::mv':"
            << endl
            << "`Irods_Object_Type::get_from_database' returned " << status << "."
            << endl 
            << "An entry for `new_filename' == `" << new_filename << "' "
            << "already exists in the `gwirdsif.Irods_Objects' database table."
            << endl
            << "Moving is not permitted."
            << endl
            << "Will send error message to client and exit function unsuccessfully "
            << "with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred; 

       temp_strm.str("");

       temp_strm << "MV RESPONSE " << GW_ERROR << " " << response.options << "U "
                 << "\"" << old_filename << "\" \"" << new_filename << "\" "
                 << "\"" << response.flags << "\" "
                 << "\"Entry for new filename already exists in the `gwirdsif.Irods_Objects' "
                 << "database table."
                 << endl 
                 << "This is not permitted.\"";

       new_response.command = temp_strm.str();
   
       response_deque.push_back(new_response);

       return 1;

   }  /* |else if (status > 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::mv| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Scan_Parse_Parameter_Type::mv':"
            << endl
            << "`Irods_Object_Type::get_from_database' succeeded, returning " 
            << status << "."
            << endl 
            << "No existing entry for `new_filename' == `" << new_filename << "' "
            << "in the `gwirdsif.Irods_Objects' database table."
            << endl
            << "This is as it should be."
            << endl;

       irods_object_new.show("irods_object_new:");

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mv| definition@>=

   vector<Response_Type> new_response_vector;

   status = irods_object_old.rename_irods_object(mysql_ptr,
                                                 irods_env_filename,
                                                 response,
                                                 new_response_vector,
                                                 new_filename,
                                                 thread_str);

   if (status == 2)
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str << "In `Scan_Parse_Parameter_Type::mv':"
                << endl
                << "`Irods_Object_Type::rename_irods_object' succeeded, returning 2." 
                << endl
                << "There is no entry in the `gwirdsif.Irods_Objects' database table "
                << "for iRODS object with path == `" << old_filename << "'."
                << endl
                << "This case was caught above.  It shouldn't happen, but it is possible."
                << endl
                << "Continuing."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |if (status == 2)|  */

@q ****** (6) @>

   else if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::mv':"
            << endl
            << "`Irods_Object_Type::rename_irods_object' failed, returning " 
            << status << "."
            << endl 
            << "Failed to rename iRODS object."
            << endl
            << "Will send error message to client and exit function unsuccessfully "
            << "with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred; 

       if (new_response_vector.size() == 0)
       {
          temp_strm << "MV RESPONSE " << GW_ERROR << " " << response.options << "U "
                    << "\"" << old_filename << "\" \"" << new_filename << "\" "
                    << "\"" << response.flags << "\" "
                    << "\"Failed to rename iRODs object.\"";

          new_response.command = temp_strm.str();

          response_deque.push_back(new_response);
   
       }
       else
       {
           for (vector<Response_Type>::iterator iter = new_response_vector.begin();
                iter != new_response_vector.end();
                ++iter)
              response_deque.push_back(*iter);
           
       }

       return 1;

   }  /* |else if (status != 0)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mv| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Scan_Parse_Parameter_Type::mv':"
            << endl
            << "`Irods_Object_Type::rename_irods_object' succeeded, returning 0." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mv| definition@>=

   if (new_response_vector.size() == 0)
   {
       temp_strm.str("");

       temp_strm << "MV RESPONSE " << GW_SUCCESS << " " << response.options << "U "
                 << "\"" << old_filename << "\" \"" << new_filename << "\" "
                 << "\"" << response.flags << "\" \"Success\"";

       new_response.command = temp_strm.str();
    
       response_deque.push_back(new_response);
   }
   else
   {
       for (vector<Response_Type>::iterator iter = new_response_vector.begin();
            iter != new_response_vector.end();
            ++iter)
          response_deque.push_back(*iter);
       
   }


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mv| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Exiting `Scan_Parse_Parameter_Type::mv' successfully "
            << "with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::mv| definition  */


@q ***** (5) Declaration @>
@
@<|Scan_Parse_Parameter_Type| function declarations@>=

@q **** (4) pwd.  @>
@ pwd.  
\initials{LDF 2013.04.03.}

\LOG
\initials{LDF 2013.04.03.}
Added this function.
\ENDLOG

@q ***** (5) Declaration @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
pwd(char *buffer_ptr, 
    unsigned int buff_size, 
    string args = "");


@q ***** (5) Definition @>
@
@<|Scan_Parse_Parameter_Type::pwd| definition@>=
int
Scan_Parse_Parameter_Type::pwd(char *buffer_ptr, 
                               unsigned int buff_size, 
                               string args)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

    int status = 0;

    stringstream temp_strm;

    temp_strm << "[Thread " << thread_ctr << "] ";

    string thread_ctr_str = temp_strm.str();

    temp_strm.str("");

#if DEBUG_COMPILE
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "Entering `Scan_Parse_Parameter_Type::pwd'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    memset(buffer_ptr, 0, buff_size);

    char buffer[2048];  /* Should be more than large enough for the name of the 
                           working directory.
                           \initials{LDF 2012.09.19.}  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::pwd| definition@>=

    temp_strm << "env irodsEnvFile=" << irods_env_filename << " ipwd";

#if DEBUG_COMPILE 
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::pwd':"
             << endl
             << "'temp_strm.str() == " << temp_strm.str() 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    errno = 0;

    FILE *fp = popen(temp_strm.str().c_str(), "r");
    memset(buffer, 0, 2048);

    if (fp == 0)
    {
         lock_cerr_mutex(); 
         cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::pwd':"
              << endl
              << "`popen' failed, returning NULL.  Can't show working directory."
              << endl;
         
         if (errno != 0)
             perror("popen error");
    
         cerr << "Exiting function unsuccessfully with return value 1."
              << endl;

         unlock_cerr_mutex(); 

         strcpy(buffer_ptr, "PWD FAILED 1"); 

         ++errors_occurred;

         return 1;

    }  /* |if (fp == 0)|  */

#if DEBUG_COMPILE 
    else if (DEBUG)
    {
         lock_cerr_mutex(); 
         cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::pwd':"
              << endl 
              << "`popen' succeeded.  `fp' is non-null. " 
              << endl;  
         unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

    status = fread(buffer, 1, 2048, fp);

@q ***** (5) @>

    if (status == 0)
    {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::pwd':"
             << endl 
             << "`fread' failed, returning 0.  Can't show working directory."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        strcpy(buffer_ptr, "PWD FAILED 1"); 

        ++errors_occurred;

        return 1;

    }  /* |if (status == 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::pwd| definition@>=

    else if (status == 2048)
    {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::pwd':"
             << endl
             << "`fread' returned " << status << " == 2048."
             << endl 
             << "Output from pipe exceeds maximum length."
             << endl 
             << "Can't show working directory."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        pclose(fp);
        fp = 0;

        strcpy(buffer_ptr, "PWD FAILED 1"); 

        ++errors_occurred;

        return 1;


    }  /* |if (status == 2048)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::pwd| definition@>=

    if (buffer[status - 1]  == '\n')  
    {
     
       buffer[status - 1] = '\0';  /* Remove trailing newline, if present.  
                                      \initials{LDF 2013.04.03.}  */
    }

    temp_strm.str("");

    temp_strm << "PWD RESPONSE \"" << buffer << "\"";

    if (temp_strm.str().size() >= buff_size)
    {
        lock_cerr_mutex(); 
        cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::pwd':"
             << endl
             << "Response string length == `temp_strm.str().size()' == "
             << temp_strm.str().size() 
             << endl 
             << ">= `buff_size' == " << buff_size << "."
             << endl 
             << "Can't show working directory."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        strcpy(buffer_ptr, "PWD FAILED 1"); 

        pclose(fp);
        fp = 0;

        ++errors_occurred;

        return 1;

    }  /* |if (temp_strm.str().size() >= buff_size)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::pwd| definition@>=

    else 
    {
#if DEBUG_COMPILE 
         if (DEBUG)
         {
            lock_cerr_mutex(); 
            cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::pwd':"
                 << endl 
                 << "`buffer' == " << buffer 
                 << endl;
            unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 
    
         strcpy(buffer_ptr, temp_strm.str().c_str());

#if DEBUG_COMPILE 
         if (DEBUG)
         {
            lock_cerr_mutex(); 
            cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::pwd':"
                 << endl 
                 << "`buffer_ptr' == " << buffer_ptr
                 << endl;
            unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


    }  /* |else|  */  

    pclose(fp);
    fp = 0;
 
    return 0;


}  /* End of |Scan_Parse_Parameter_Type::pwd| definition  */



@q **** (4) put.  @>
@ put.
\initials{LDF 2012.09.27.}

\LOG
\initials{LDF 2012.09.27.}
Added this function.

\initials{LDF 2013.01.09.}
Added code for creating or updating rows in the \.{Irods\_Objects} database table
and creating rows in the \.{Irods\_Objects\_Handles} table, if a PID is generated.

\initials{LDF 2013.04.04.}
Changed the way |response.local_filename| is handled.  This is the path of 
the iRODS object to be ``put''.  Now, if it's not an absolute path, |irods_current_dir| 
is inserted at the front.  |response.local_filename| can contain directories, e.g., 
a path like \filename{subdir\_1/subdir\_2/abc.txt} can also be specified.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
int
put(Response_Type &response);

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

int
Scan_Parse_Parameter_Type::put(Response_Type &response)
{
@q ****** (6) @>


     /* !! START HERE:  LDF 2014.02.11.  

        When overwriting, check whether there's a checksum in the handle (if any) 
        and update it.
        Maybe add options to \.{put}.

     */

     bool DEBUG = false;  /* |true|  */
     set_debug_level(DEBUG, 0, 0); 

     stringstream temp_strm;
     string temp_str;

     string thread_str;

     int status = 0;

     Response_Type new_response;
     new_response.type = Response_Type::COMMAND_ONLY_TYPE;

     Irods_Object_Type curr_irods_object;
     Irods_AVU_Type    curr_avu;

     unsigned long int curr_metadata_handle_id;
     vector<unsigned long int> metadata_handle_id_vector;

     vector<Handle_Type> handle_vector;

     vector<Handle_Type> metadata_handle_vector;

     MYSQL_RES *result = 0;
     MYSQL_ROW curr_row;
     unsigned int row_ctr;
     unsigned int field_ctr;
     long int affected_rows;

     stringstream sql_strm;

 
     temp_strm << "[Thread " << thread_ctr << "] ";
     thread_str = temp_strm.str();

     temp_strm.str("");

     bool signature_file = false;
     string base_filename;

     FILE *fp = 0;

     char buffer[2048];
     memset(buffer, 0, 2048);

     bool encrypt          = (response.options & 32U)    ? true : false;
     bool sign             = (response.options & 64U)    ? true : false;
     bool clearsign        = (response.options & 128U)   ? true : false;
     bool detached         = (response.options & 256U)   ? true : false;
     bool signature        = (response.options & 512U)   ? true : false;
     bool verify           = (response.options & 2048U)  ? true : false;
     bool compressed_gzip  = (response.options & 4096U)  ? true : false;
     bool compressed_bzip2 = (response.options & 8192U)  ? true : false;
     bool is_tar_file      = (response.options & 16384U) ? true : false;

     unsigned long int temp_val = 0UL;

     size_t pos = 0;

     Irods_Object_Type base_irods_object;

     vector<Handle_Value_Triple> hvt_vector;

     vector<Irods_AVU_Type>::iterator avu_iter;
     string base_irods_object_pid;

     bool overwrite = false;

     int irods_object_ctr = 0;
  
@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE 
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::put'."
              << endl;

         cerr << "`irods_current_dir'            == " << irods_current_dir 
              << endl
              << "`response.remote_filename'     == " << response.remote_filename
              << endl 
              << "`response.local_filename'      == " << response.local_filename
              << endl
              << "`response.options'             == " << response.options << " == " 
              << oct << response.options << " (octal)" << dec
              << endl
              << "`encrypt'                      == " << encrypt
              << endl 
              << "`sign'                         == " << sign
              << endl 
              << "`clearsign'                    == " << clearsign
              << endl 
              << "`detached'                     == " << detached
              << endl
              << "`signature'                    == " << signature
              << endl
              << "`verify'                       == " << verify
              << endl 
              << "compressed_gzip                == " << compressed_gzip 
              << endl 
              << "compressed_bzip2               == " << compressed_bzip2 
              << endl 
              << "`is_tar_file'                  == " << is_tar_file
              << endl 
              << "`response.string_val'          == " << response.string_val
              << endl
              << "`response.gpg_key_fingerprint' == " << response.gpg_key_fingerprint
              << endl;

         response.show("response:");

         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */

@q ****** (6) Test |response.flags| for \.{-f} (force) option.  @>

@ Test |response.flags| for \.{-f} (force) option.  If present, set |bool overwrite| to |true|.
@:NOTE@> !! PLEASE NOTE:  This only works if \.{-f} is used separately from other options,
or if it is the first option in a list preceded by a single hyphen.

\LOG
\initials{LDF 2014.02.13.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

    pos = response.flags.find("-f");

    if (pos != string::npos)
    {
#if DEBUG_COMPILE 
          if (DEBUG)
          {
              lock_cerr_mutex(); 
              cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                   << endl
                   << "`response.flags' contains `-f' (force) option.  "
                   << "Setting `bool overwrite' to `true'."
                   << endl;
              unlock_cerr_mutex(); 

          }  /* |if (DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */

          overwrite = true;


    }  /* |if (pos != string::npos)|  */

    else  
    {

#if DEBUG_COMPILE
          if (DEBUG)
          {
             lock_cerr_mutex(); 
             cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                  << endl
                  << "`response.flags' does not contain `-f' (force) option.  `bool overwrite' "
                  << "remains set to `false'."
                  << endl;
             unlock_cerr_mutex(); 
          }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    }  /* |else|  */

@q ****** (6) Check |response.remote_filename| to see if it contains a filename.  @>

@ Check |response.remote_filename| to see if it contains a filename.
If it doesn't, exit unsuccessfully.
\initials{LDF 2012.11.23.}

\LOG
\initials{LDF 2012.11.23.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

@q ******* (7) @>

    string remote_plain_filename = response.remote_filename;

    pos = remote_plain_filename.find_last_of("/");

    if (pos == string::npos)  
    {   
@q ******** (8) @>

        /* |response.remote_filename| doesn't contain any directories  */

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                 << endl
                 << "`response.remote_filename' == " << response.remote_filename 
                 << " doesn't contain any directories."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */         

@q ******** (8) @>

    }  /* |if (pos == string::npos)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

    else
    {
         remote_plain_filename.erase(0, pos + 1);

#if DEBUG_COMPILE
         if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                  << endl
                  << "`remote_plain_filename' == " << remote_plain_filename
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    }  /* |else|  */

@q ******* (7) @>

@q ****** (6) @>
@
\LOG
\initials{LDF 2014.01.24.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

    if (response.local_filename.empty())
    {
        response.local_filename = response.remote_filename;

        if (response.local_filename[response.local_filename.length() - 1] == '/')
           response.local_filename.erase(response.local_filename.length() - 1);

        if (is_tar_file)
            response.local_filename += ".tar";

        if (compressed_gzip)
            response.local_filename += ".gz";

        else if (compressed_bzip2)
            response.local_filename += ".bz2";

        if (encrypt)
            response.local_filename += ".gpg";

        if (detached)
            response.local_filename += ".sig";

        if (clearsign)
            response.local_filename += ".asc";

    }  /* |if (response.local_filename.empty())|  */


@q ****** (6) Check |response.local_filename| to see if it's a directory.  @>

@ Check |response.local_filename| to see if it's a directory.  
If it is, append the filename portion of |response.remote_filename| to it.
\initials{LDF 2012.11.23.}

\LOG
\initials{LDF 2012.11.23.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

    else if (response.local_filename[response.local_filename.size() - 1] == '/')
    {
@q ******* (7) @>

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                 << endl
                 << "`response.local_filename' is a directory:  " << response.local_filename
                 << endl
                 << "Will append filename part of `response.remote_filename' to it."
                 << endl 
                 << "`response.remote_filename' == " << response.remote_filename
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

         response.local_filename += remote_plain_filename;


#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                 << endl
                 << "After appending `remote_plain_filename', "
                 << "`response.local_filename' == " << response.local_filename
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

    }  /* |if (response.local_filename[response.local_filename.size() - 1] == '/')|  */

@q ****** (6) @>
@
\LOG
\initials{LDF 2013.04.04.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

   if (response.local_filename[0] != '/')
   {
       response.local_filename.insert(0, "/");
       response.local_filename.insert(0, irods_current_dir);
 
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                << endl 
                << "After inserting `irods_current_dir':  "
                << "response.local_filename == " << response.local_filename 
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |if (response.local_filename[0] != '/')|  */

@q ****** (6) @>
@
\LOG
\initials{LDF 2014.02.13.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "response.local_filename == " << response.local_filename << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */    


@q ****** (6) @>
@ 
\LOG
\initials{LDF 2013.01.03.}
Now using |access| instead of |fopen| to test for existence of file.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::put| definition@>=

    errno = 0;
    status = access(response.temporary_filename.c_str(), F_OK);

    if (status == -1)
    {
         lock_cerr_mutex(); 
         cerr << thread_str << "ERROR!  In "
              << "`Scan_Parse_Parameter_Type::put':"
              << endl 
              << "`access' returned -1:"
              << endl 
              << strerror(errno)
              << endl
              << "Can't \"put\" file."
              << endl 
              << "Will send failure notice to client "
              << "and exit function unsuccessfully with return value 1."
              << endl; 
         unlock_cerr_mutex(); 

         temp_strm.str("");
         temp_strm <<  "PUT RESPONSE \"" << response.local_filename 
                   << "\" " << GW_ERROR << "\"Server-side error:  "
                   << "File `" << response.temporary_filename << "' "
                   << "doesn't exist\"";

         new_response.command = temp_strm.str();

         response_deque.push_back(new_response);

         ++errors_occurred;

         return 1;


    }  /* |if (status == -1)|  */

#if DEBUG_COMPILE
    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_str << "In "
             << "`Scan_Parse_Parameter_Type::put':"
             << endl 
             << "`access' succeeded, returning 0.  File "
             << "`" << response.temporary_filename << "' exists."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
\LOG
\initials{LDF 2014.01.09.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=
 
    if (signature == true)
    {
@q ******* (7) @>

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                 << endl 
                 << "`signature' == `true':"
                 << endl
                 << "File `response.local_filename' == " << response.local_filename << " "
                 << "is a signature file."
                 << endl
                 << "`response.string_val' == base filename == " << response.string_val
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

@q ******* (7) @>

    }  /* |if (signature == true)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
             << endl 
             << "`signature' == `false':" 
             << endl
             << "File `response.local_filename' == " << response.local_filename << " "
             << "is not a signature file."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) |verify && clearsign|:  Verify signature.  @>

@ |verify && clearsign|:  Verify signature.  
\initials{LDF 2014.01.13.}

\LOG
\initials{LDF 2014.01.13.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

   if (verify && clearsign)
   {
@q ******* (7) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                << endl 
                << "`verify == `true' and `clearsign' == `true':"
                << endl 
                << "`verify'    == " << verify
                << endl 
                << "`sign'      == " << sign
                << endl 
                << "`clearsign' == " << clearsign
                << endl 
                << "`detached'  == " << detached
                << endl
                << "Will verify signature."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

       if (response.gpg_key_fingerprint.empty())
       {
           lock_cerr_mutex(); 
           cerr << thread_str << "ERROR!  In "
                << "`Scan_Parse_Parameter_Type::put':"
                << endl 
                << "`verify' == `true', but `response.gpg_key_fingerprint' is empty."
                << endl 
                << "Can't verify signature."
                << endl
                << "Will send failure notice to client and exit function unsuccessfully "
                << "with return value 1."
                << endl; 
           unlock_cerr_mutex(); 

           temp_strm.str("");
           temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" " 
                     << GW_ERROR << "\"Signature verificaton requested, "
                     << "but GPG key fingerprint not supplied.\"";

           new_response.command = temp_strm.str();

           response_deque.push_back(new_response);

           ++errors_occurred;

           return 1;

       }  /* |if (response.gpg_key_fingerprint.empty())|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                << endl 
                << "`verify' == `true' and `response.gpg_key_fingerprint' is non-empty:"
                << endl 
                << "`response.gpg_key_fingerprint' == " << response.gpg_key_fingerprint
                << endl 
                << "Will verify signature."
                << endl; 
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

       temp_strm.str("");

       temp_strm << "a=`env LANG=en_US.UTF-8 gpg --verify -vv " 
                 << response.temporary_filename 
                 << " 2>&1`; echo $?; echo $a;";

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str << "In "
                << "`Scan_Parse_Parameter_Type::put':"
                << endl 
                << "`temp_strm.str()' =="
                << endl
                << temp_strm.str()
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

      memset(buffer, 0, 2048);
      errno = 0;
      fp = popen(temp_strm.str().c_str(), "r");

      if (fp == 0)
      {
          lock_cerr_mutex(); 
          cerr << thread_str << "ERROR!  In "
               << "`Scan_Parse_Parameter_Type::put':"
               << endl 
               << "`popen' failed, returning NULL:"
               << endl;
 
          if (errno != 0)
              cerr << strerror(errno) << endl;

          cerr << "Failed to execute `gpg --verify' command in shell."
               << endl
               << "Will send failure notice to client and exit function unsuccessfully "
               << "with return value 1."
               << endl; 
          unlock_cerr_mutex(); 

          temp_strm.str("");
          temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" " 
                    << GW_ERROR << "\"Failed to verify GPG signature.\"";

          new_response.command = temp_strm.str();

          response_deque.push_back(new_response);

          ++errors_occurred;

          return 1;

      }  /* |if (fp == 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
      else if (DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
               << endl 
               << "`popen' succeeded."
               << endl;
          unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

      status = fread(buffer, 1, 2047, fp);

      if (status == 0)
      {
          lock_cerr_mutex(); 
          cerr << thread_str << "ERROR!  In "
               << "`Scan_Parse_Parameter_Type::put':"
               << endl 
               << "`fread' failed, returning 0:"
               << endl
               << "`gpg --verify' command in shell failed, or this function failed to ."
               << "read its output."
               << endl 
               << "Will send failure notice to client and exit function unsuccessfully "
               << "with return value 1."
               << endl; 
          unlock_cerr_mutex(); 

          temp_strm.str("");
          temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" " 
                    << GW_ERROR << "\"Failed to verify GPG signature.\"";

          new_response.command = temp_strm.str();

          response_deque.push_back(new_response);

          ++errors_occurred;

          pclose(fp);

          return 1;

      }  /* |if (status == 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

      else if (status == 2047)
      {
          lock_cerr_mutex(); 
          cerr << thread_str << "ERROR!  In "
               << "`Scan_Parse_Parameter_Type::put':"
               << endl 
               << "`fread' returned 2047:"
               << endl
               << "Output of `gpg --verify' command, executed in shell, "
               << "exceeds maximum amount (2046 characters)."
               << endl 
               << "This is not permitted."
               << endl
               << "`buffer' =="
               << buffer
               << endl 
               << "Will send failure notice to client and exit function unsuccessfully "
               << "with return value 1."
               << endl; 
          unlock_cerr_mutex(); 

          temp_strm.str("");
          temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" " 
                    << GW_ERROR << "\"Failed to verify GPG signature.\"";

          new_response.command = temp_strm.str();

          response_deque.push_back(new_response);

          ++errors_occurred;

          pclose(fp);

          return 1;

      }  /* |if (status == 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
      else if (DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
               << endl 
               << "`fread' succeeded, returning " << status
               << endl
               << "`buffer' ==" 
               << endl 
               << buffer
               << endl; 
          unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      
    
@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

      pclose(fp);
      fp = 0;

      temp_strm.str("");

      temp_strm << buffer;   

      memset(buffer, 0, 2048);      
      temp_strm.clear();

#if DEBUG_COMPILE
      if (DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
               << endl 
               << "`temp_strm.str()' =="
               << endl
               << temp_strm.str()
               << endl; 
          unlock_cerr_mutex(); 

      }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      
   
      status = -101;

      temp_strm >> status;
      
      temp_str = temp_strm.str();

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

      if (status != 0)
      {
          lock_cerr_mutex(); 
          cerr << thread_str << "ERROR!  In "
               << "`Scan_Parse_Parameter_Type::put':"
               << endl 
               << "`gpg --verify' command, executed in shell, failed, returning " << status << "."
               << endl 
               << "Will send failure notice to client and exit function unsuccessfully "
               << "with return value 1."
               << endl; 
          unlock_cerr_mutex(); 

          temp_strm.str("");
          temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" " 
                    << GW_ERROR << "\"Failed to verify GPG signature.\"";

          new_response.command = temp_strm.str();

          response_deque.push_back(new_response);

          ++errors_occurred;

          return 1;

      }  /* |if (status != 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
      else if (DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
               << endl 
               << "`gpg --verify' command, executed in shell, succeeded, returning 0."
               << endl
               << "`temp_str' =="
               << endl
               << temp_str
               << endl; 
          unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */      

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

      pos = temp_str.find("keyid");

      if (pos == string::npos)
      {
          lock_cerr_mutex(); 
          cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
               << endl 
               << "`gpg --verify' succeeded, but failed to read key ID from its output:"
               << endl 
               << "`temp_str' == " << temp_str
               << endl 
               << "Will send failure notice to client and exit function unsuccessfully "
               << "with return value 1."
               << endl; 
          unlock_cerr_mutex(); 

          temp_strm.str("");
          temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" " 
                    << GW_ERROR << "\"Verified signature but failed to read key ID "
                    << "from `gpg --verify' output."
                    << endl 
                    << "Can't confirm that file was signed by the specified key.\"";

          new_response.command = temp_strm.str();

          response_deque.push_back(new_response);

          ++errors_occurred;

          return 1;
 
      }  /* |if (pos == string::npos)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

      temp_str.erase(0, pos + 6);

      pos = temp_str.find(" ");

      if (pos == string::npos)
      {
          lock_cerr_mutex(); 
          cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
               << endl 
               << "`gpg --verify' succeeded, but failed to read key ID from its output:"
               << endl 
               << "`temp_str' == " << temp_str
               << endl 
               << "Will send failure notice to client and exit function unsuccessfully "
               << "with return value 1."
               << endl; 
          unlock_cerr_mutex(); 

          temp_strm.str("");
          temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" " 
                    << GW_ERROR << "\"Verified signature but failed to read key ID "
                    << "from `gpg --verify' output."
                    << endl 
                    << "Can't confirm that file was signed by the specified key.\"";

          new_response.command = temp_strm.str();

          response_deque.push_back(new_response);

          ++errors_occurred;

          return 1;
 
      }  /* |if (pos == string::npos)|  */

      temp_str.erase(pos);

      temp_val = response.gpg_key_fingerprint.length() - temp_str.length();

#if DEBUG_COMPILE
      if (DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
               << endl 
               << "Read key ID successfully:"
               << endl
               << "`temp_str'                                    == " << temp_str
               << endl
               << "response.gpg_key_fingerprint.substr(temp_val) == " 
               << response.gpg_key_fingerprint.substr(temp_val)
               << endl;
          unlock_cerr_mutex(); 

      }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

      status = temp_str.compare(response.gpg_key_fingerprint.substr(temp_val));

      if (status != 0)
      {
          lock_cerr_mutex(); 
          cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
               << endl 
               << "Key ID mismatch:"
               << endl 
               << "`temp_str'                                      == " << temp_str
               << endl 
               << "`response.gpg_key_fingerprint.substr(temp_val)' == "
               << response.gpg_key_fingerprint.substr(temp_val)
               << endl 
               << "`response.gpg_key_fingerprint' == "
               << response.gpg_key_fingerprint
               << endl 
               << "Will send failure notice to client and exit function unsuccessfully "
               << "with return value 1."
               << endl; 
          unlock_cerr_mutex(); 

          temp_strm.str("");
          temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" " 
                    << GW_ERROR << "\"Verified signature but key ID doesn't match "
                    << "the one specified.\"";

          new_response.command = temp_strm.str();

          response_deque.push_back(new_response);

          ++errors_occurred;

          return 1;

      }  /* |if (status != 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
      if (DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
               << endl 
               << "Key IDs match.  Verification successful."
               << endl;
          unlock_cerr_mutex(); 

      }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

       temp_strm.str("");
       temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" " 
                 << GW_SUCCESS << "\"Verified signature successfully.\"";

       new_response.command = temp_strm.str();

       response_deque.push_back(new_response);

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

   }  /* |if (verify && clearsign)|  */

@q ****** (6) @>

@ |irods_object_filename| is the filename that should be stored in the 
\.{Irods\_Objects} table.  If |response.local_filename| contains at least
one directory, |irods_object_filename| is set to |response.local_filename|.
Otherwise, i.e., if |response.local_filename| is a plain filename with 
no directories, |irods_object_filename| is set to |irods_homedir| 
followed by a slash, followed by |response.local_filename|.
\initials{LDF 2013.01.07.}
\initials{LDF 2013.01.09.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "irods_homedir == " << irods_homedir << endl
              << "response.local_filename == " << response.local_filename << endl;
         response.show("response:");
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

     status = curr_irods_object.set(user_id, response.local_filename);

     if (status != 0)
     {

        lock_cerr_mutex(); 
        cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
             << endl
             << "`Irods_Object_Type::set' failed, returning " << status << "."
             << endl 
             << "Failed to set `Irods_Object_Type' object for iRODS object "
             << "`" << response.local_filename << "'."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        temp_strm.str("");

        temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                  << "1 \"Server error:  "
                  << "C++ error:  `Irods_Object_Type' constructor failed";

        new_response.command = temp_strm.str();

        response_deque.push_back(new_response);

        ++errors_occurred;

        return 1;

     }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
              << endl
              << "`Irods_Object_Type::set' succeeded, returning 0."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
\LOG
\initials{LDF 2014.01.09.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

     if (encrypt)
     {
         curr_irods_object.encrypted  = true;
         curr_irods_object.gpg_key_fingerprint_encrypt = response.gpg_key_fingerprint;
     }
     if (sign || clearsign)
     {
         curr_irods_object.signed_gpg = true;
         curr_irods_object.gpg_key_fingerprint_sign = response.gpg_key_fingerprint;
     }
     if (detached)
     {
         /* The reference to the iRODS object containing the signature
            must be added later, when the latter is written to the 
            database.  \initials{LDF 2014.01.10.}  */

         curr_irods_object.gpg_key_fingerprint_sign = response.gpg_key_fingerprint;
     }
     if (signature)
     {
         curr_irods_object.gpg_key_fingerprint_sign = response.gpg_key_fingerprint;
     }

     if (is_tar_file)
        curr_irods_object.compressed_tar_file = true;

     if (compressed_gzip)
        curr_irods_object.compressed_gzip = true;

     else if (compressed_bzip2)
        curr_irods_object.compressed_bzip2 = true;
    
#if DEBUG_COMPILE
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
              << endl;

         curr_irods_object.show("curr_irods_object:");

         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
\LOG
\initials{LDF 2014.02.13.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

     status = curr_irods_object.get_from_database(mysql_ptr, true);
 
     irods_object_ctr = status;  /* This value is needed below.  
                                    \initials{LDF 2014.02.13.}  */

     if (irods_object_ctr > 0 && overwrite == false) 
     {


             lock_cerr_mutex(); 
             cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                  << endl 
                  << "iRODS object `" << response.local_filename << "' already exists,"
                  << endl 
                  << "but `overwrite' == `false'."
                  << endl
                  << "Not overwriting iRODS object."
                  << endl
                  << "Exiting `Scan_Parse_Parameter_Type::put' "
                  << "unsuccessfully with return value 1."
                  << endl;
             unlock_cerr_mutex(); 

             temp_strm.str("");

             temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                       << GW_ERROR << " \"iRODS object already exists, but "
                       << "`-f' (force) option not specified.\"";

             new_response.command = temp_strm.str();

             response_deque.push_back(new_response);

             ++errors_occurred;

             return 1;

     }  /* |if (irods_object_ctr > 0 && overwrite == false) |  */

@q ****** (6) @>
@
\LOG
\initials{LDF 2014.02.13.}
Moved this section.  Now, |curr_irods_object.get_from_database| is called first.
If the iRODS object already exists and |overwrite == false|, this code isn't reached.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::put| definition@>=

    temp_val = 0UL;
    temp_strm.clear();
    temp_strm.str("");

/* !! TODO:  |response.flags| may have leading or trailing spaces.
   This bothers me a little, but I'm not sure whether it's worth doing anything
   about it.  Check how it's set and where it's used.
*/

    temp_strm << "env irodsEnvFile=" << irods_env_filename << " "
              << " iput " << response.flags << " " << response.temporary_filename << " " 
              << response.local_filename << " 2>&1; echo $?";

#if DEBUG_COMPILE
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "temp_strm.str() == " << temp_strm.str() << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

    errno = 0;
   
    fp = popen(temp_strm.str().c_str(), "r");

    if (fp == 0)
    {
        lock_cerr_mutex(); 
        cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
             << "`popen' failed, returning NULL:  " << strerror(errno)
             << endl
             << "Can't \"put\" file.  Will send failure notice to client."
             << endl
             << "Exiting function unsuccessfully with return value 1."
              << endl;
        unlock_cerr_mutex(); 

        temp_strm.str("");
        temp_strm <<  "PUT RESPONSE \"" << response.local_filename 
                  << "\" 1 \"Server error:  "
                  << "Failed to execute `iput' command";

        new_response.command = temp_strm.str();

        response_deque.push_back(new_response);

        ++errors_occurred;

        return 1;


    }  /* |if (fp == 0)|  */

@q ****** (6) @>

    else /* |fp != 0|  */
    {
@q ******* (7) @>

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                 << "`popen' succeeded."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

        memset(buffer, 0, 2048);

        status = fread(buffer, 1, 2048, fp);

@q ******* (7) @>

        if (status == 0)
        {
                lock_cerr_mutex(); 
                cerr << thread_str << "ERROR!  "
                     << "In `Scan_Parse_Parameter_Type::put':"
                     << "`fread' failed, returning 0.  Failed to read from pipe."
                     << endl
                     << "Failed to \"put\" file.  Will send failure notice "
                     << "to client."
                     << endl 
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;
                unlock_cerr_mutex(); 

                temp_strm.str("");
                temp_strm <<  "PUT RESPONSE \"" << response.local_filename
                          << "\" 1 \"Server error:  "
                          << "Failed to read output and/or exit status from "
                          << "`iput' command.\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

                pclose(fp);

                ++errors_occurred;

                return 1;



        }  /* |if (status == 0)|  */

@q ******* (7) @>

        else if (status == 2048)
        {
                lock_cerr_mutex(); 
                cerr << thread_str << "ERROR!  "
                     << "In `Scan_Parse_Parameter_Type::put':"
                     << "`fread' returned 2048:  Pipe output exceeds maximum length."
                     << endl
                     << "Failed to \"put\" file.  "
                     << "Will send failure notice to client."
                     << endl 
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;
                unlock_cerr_mutex(); 

                temp_strm.str("");
                temp_strm <<  "PUT RESPONSE \"" << response.local_filename 
                          << "\" 1 \"Server error:  "
                          << "Output from `iput' command exceeds maximum length "
                          << "(2047 characters).\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

                pclose(fp);
                 
                ++errors_occurred;

                return 1;


        }  /* |else if (status == 2048)|  */

@q ******* (7) @>

        else  /* |fread| succeeded and read valid number of characters  */
        {
@q ******** (8) @>

#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << "`popen' succeeded."
                     << endl
                     << "`buffer' == " << buffer
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            /* Get the return value of \.{iput} command.  */

            char *ret_val_ptr = buffer + strlen(buffer) - 1;
#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "ret_val_ptr == " << ret_val_ptr << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


            --ret_val_ptr;

            while (isdigit(ret_val_ptr[0]))
               --ret_val_ptr;

            if (!(ret_val_ptr[0] == '-' || ret_val_ptr[0] == '+'))
               ++ret_val_ptr;

            int ret_val;

            sscanf(ret_val_ptr, "%d", &ret_val);

            ret_val_ptr[0] = '\0';  /* Remove exit status from end of |buffer|  */



#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << endl 
                     << "ret_val_ptr == " << ret_val_ptr 
                     << endl
                     << "ret_val == " << ret_val 
                     << endl
                     << "`buffer' == " << buffer
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=
           
            if (ret_val == 0)
            {
#if DEBUG_COMPILE
                if (DEBUG)             
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                         << "`iput' succeeded."
                         << endl;
                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */                           

                temp_strm.str("");
                temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" 0 \"" 
                          << "`iput' command succeeded, returning " << ret_val;


                if (strlen(buffer) > 0)
                   temp_strm << ":  " << buffer << "\"";
                else
                   temp_strm << "\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

                pclose(fp);

                fp = 0;


            }  /* |if (ret_val == 0)|  */

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            else /* |ret_val != 0|  */
            {

                 lock_cerr_mutex(); 
                 cerr << thread_str << "ERROR!  "
                      << "In `Scan_Parse_Parameter_Type::put':"
                      << "`iput' failed:"
                      << endl
                      << "`buffer' == " << buffer
                      << endl
                      << "Will send failure message to client."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 temp_strm.str("");

                 temp_strm <<  "PUT RESPONSE \"" << response.local_filename 
                           << "\" 1 \"Server error:  "
                           << "`iput' command failed, returning " << ret_val;

                 if (strlen(buffer) > 0)
                     temp_strm << ":" << endl << buffer << "\"";
                 else 
                     temp_strm << "\"";

                 new_response.command = temp_strm.str();

                 response_deque.push_back(new_response);

                 pclose(fp);

                 ++errors_occurred;

                 return 1;


            }  /* |else| (|ret_val != 0|)  */

@q ******** (8) @>

        }  /* |else|.  |fread| succeeded and read valid number of characters  */

@q ******* (7) @>

    }  /* |else| (|fp != 0|).  |popen| succeeded  */




@q ****** (6) Handle |pid_options|.  @>

@ Handle |pid_options|.  
\initials{LDF 2012.09.28.}

A PID (a.k.a.~``handle'') is only created if 
the \.{+pid} option is specified in the \.{put} command in the input.  
If the \.{+gen} option is also specified, the PID is generated.  Otherwise, 
a particular PID may be specified.  
\initials{LDF 2013.01.09.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

@q ******* (7) @>

#if DEBUG_COMPILE
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
              << endl 
              << "response.pid_options == " << oct << response.pid_options << dec 
              << endl
              << "`response.pid_str' == " << response.pid_str 
              << endl
              << "`response.pid_prefix_str' == " << response.pid_prefix_str
              << endl
              << "`response.pid_suffix_str' == " << response.pid_suffix_str
              << endl
              << "`response.pid_institute_str' == " << response.pid_institute_str
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
     if (DEBUG)
     {
          lock_cerr_mutex(); 

          cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
               << endl;

          if (response.pid_options & 1U && !response.pid_str.empty())
          {
               cerr << "`response.pid_options & 1U' == " << (response.pid_options & 1U) 
                    << " and `response.pid_str' is "
                    << "non-empty."
                    << endl 
                    << "`response.pid_str' == " << response.pid_str
                    << endl;


          }  /* |if (response.pid_options & 1U)|  */

          else if (response.pid_options & 1U && response.pid_str.empty())
          {
                 cerr << "`response.pid_options & 1U' == " << (response.pid_options & 1U) 
                      << " and `response.pid_str' is "
                      << "empty."
                      << endl 
                      << "Will generate a PID string."
                      << endl;

          }  /* |if (response.pid_options & 1U)|  */

          else /* |!(response.pid_options & 1U)|  */
          {
                 cerr << "`(response.pid_options & 1U)' == " << (response.pid_options & 1U)
                      << endl
                      << "Not generating a PID."
                      << endl;

          }  /* |else| (|!(response.pid_options & 1U)|)  */

          unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */

#endif  /* |DEBUG_COMPILE|  */ 
 
@q ******* (7) @>

     if (response.pid_options & 1U)
     {
@q ******** (8) @>

        string prefix_str;

        if (!response.pid_prefix_str.empty())
           prefix_str = response.pid_prefix_str;

@ If |response.pid_str| contains a slash, then the substring before it is
a prefix.  In this case, |prefix_str| should be empty and {\it not\/} 
be set to |default_handle_prefix| before passing it to |generate_pids|.
Otherwise, if |prefix_str| and the prefix in |response.pid_str| differ, this will 
cause an error in |generate_pids|, which is not what we want.  That is, 
it should be possible to choose a non-default prefix by including it
at the front of |response.pid_str|.  This is an alternative to using the \.{+pid} 
option.
\initials{LDF 2012.10.08.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

        else  
        {
             pos = response.pid_str.find("/");

             if (pos == string::npos)
                prefix_str = default_handle_prefix;

        }

@q ******** (8) @>
        
@ @:TODO@> !! TODO: Add similar code for setting a |string institute_str|.
Currently, the institute abbrev.~is not used in the handle.
\initials{LDF 2012.10.08.}  

@<|Scan_Parse_Parameter_Type::put| definition@>=

        status = generate_pids(mysql_ptr, 
                              prefix_str,
                              response.pid_str, 
                              0,      /* PID vector pointer */
                              1,      /* Number of PIDS  */
                              &curr_irods_object.handle_id_vector,
                              &curr_irods_object.handle_value_id_vector,
                              true,   /* standalone handle server  */
                              response.pid_institute_str, 
                              response.pid_suffix_str,
                              &handle_vector,
                              "", /* |fifo_pathname|  */
                              user_id,
                              username);

@q ******** (8) @>
@
\LOG
\initials{LDF 2012.10.08.}
Now sending return value of |generate_pids| as error code in |new_response|.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

        if (status != 0)
        {
            cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                 << endl 
                 << "`generate_pids' failed, returning "
                 << status << "." 
                 << endl
                 << "Exiting function unsuccessfully with exit status 1."
                 << endl;

             temp_strm.str("");
             temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" " 
                       << status 
                       << " \"Server error:  "
                       << "Failed to generate PID\"";

             new_response.command = temp_strm.str();

             response_deque.push_back(new_response);

             ++errors_occurred;

             return 1;

        }  /* |if (status != 0)|  */

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                 << endl 
                 << "`generate_pids' succeeded, returning 0."
                 << endl
                 << "`response.pid_str' == " << response.pid_str 
                 << endl
                 << "`curr_irods_object.handle_id_vector.size()' == " 
                 << curr_irods_object.handle_id_vector.size()
                 << endl;
             
             cerr << "`handle_vector.size()' == " << handle_vector.size() 
                         << endl;                        

               if (curr_irods_object.handle_id_vector.size() > 0)
               {
                   cerr << "Showing `curr_irods_object.handle_id_vector':"
                        << endl;

                    for (vector<unsigned long int>::const_iterator iter 
                            = curr_irods_object.handle_id_vector.begin();
                         iter != curr_irods_object.handle_id_vector.end();
                         ++iter)
                     {
                         cerr << *iter << endl;
                     }

                     cerr << endl;

               }  /* |if|  */

               else
                   cerr << "`curr_irods_object.handle_id_vector' is empty." << endl;

               if (curr_irods_object.handle_value_id_vector.size() > 0)
               {
                   cerr << "Showing `curr_irods_object.handle_value_id_vector':"
                        << endl;

                    for (vector<unsigned long int>::const_iterator iter 
                            = curr_irods_object.handle_value_id_vector.begin();
                         iter != curr_irods_object.handle_value_id_vector.end();
                         ++iter)
                     {
                         cerr << *iter << endl;
                     }

                     cerr << endl;

               }  /* |if|  */

               else
                   cerr << "`curr_irods_object.handle_value_id_vector' is empty." << endl;
              unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

        temp_strm.str("");
        temp_strm <<  "PUT RESPONSE \"" << response.local_filename 
                  << "\" 0 \"Success:  "
                  << "Generated PID `" << response.pid_str << "'\"";

        new_response.command = temp_strm.str();

        response_deque.push_back(new_response);

@q ******** (8) @>
@
\LOG
\initials{LDF 2013.01.31.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "response.local_filename == " << response.local_filename << endl
                 << "handle_vector.size() == " << handle_vector.size() << endl;
            handle_vector.back().show("handle_vector.back():");
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */              

@q ******** (8) @>

        if (handle_vector.size() > 0)
        {
@q ********* (9) @>

@ |handle_vector| should only contain one element, so we use |back()| to access it.
That is, there's no need to iterate through |handle_vector|.
\initials{LDF 2013.02.05.}


\LOG
\initials{LDF 2013.07.03.}
Added code for adding handle value with |type == "CREATOR"|.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                distinguished_name.show("distinguished_name:");

                cerr << "distinguished_name.output() == " << distinguished_name.output()
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */    

            hvt_vector.clear();

            hvt_vector.push_back(Handle_Value_Triple(Handle_Value_Type::IRODS_OBJECT_INDEX, 
                                                     "IRODS_OBJECT",
                                                     response.local_filename));


            hvt_vector.push_back(Handle_Value_Triple(Handle_Value_Type::CREATOR_INDEX,
                                                     "CREATOR",
                                                     distinguished_name.output()));
            if (encrypt)
               hvt_vector.push_back(Handle_Value_Triple(Handle_Value_Type::ENCRYPTED_INDEX,
                                                        "ENCRYPTED",
                                                   curr_irods_object.gpg_key_fingerprint_encrypt));

            if (sign)
               hvt_vector.push_back(Handle_Value_Triple(Handle_Value_Type::SIGNED_INDEX,
                                                        "SIGNED",
                                                   curr_irods_object.gpg_key_fingerprint_sign));


            if (clearsign)
               hvt_vector.push_back(Handle_Value_Triple(Handle_Value_Type::CLEARSIGNED_INDEX,
                                                        "CLEARSIGNED",
                                                   curr_irods_object.gpg_key_fingerprint_sign));

            if (verify && !detached)
               hvt_vector.push_back(Handle_Value_Triple(Handle_Value_Type::VERIFIED_INDEX,
                                                        "VERIFIED",
                                                   curr_irods_object.gpg_key_fingerprint_sign));

            if (verify && !detached)
               hvt_vector.push_back(Handle_Value_Triple(Handle_Value_Type::VERIFIED_INDEX,
                                                        "VERIFIED",
                                                   curr_irods_object.gpg_key_fingerprint_sign));


            if (is_tar_file)
               hvt_vector.push_back(Handle_Value_Triple(
                  Handle_Value_Type::COMPRESSED_TAR_FILE_INDEX,
                  "COMPRESSED_TAR_FILE",
                  ""));

            if (compressed_gzip)
               hvt_vector.push_back(Handle_Value_Triple(Handle_Value_Type::COMPRESSED_GZIP_INDEX,
                                                        "COMPRESSED_GZIP",
                                                        ""));

            else if (compressed_bzip2)
               hvt_vector.push_back(Handle_Value_Triple(
                  Handle_Value_Type::COMPRESSED_BZIP2_INDEX,
                  "COMPRESSED_BZIP2",
                  ""));

            status = handle_vector.back().add_values(mysql_ptr, 
                                                     hvt_vector,
                                                     user_id);
            if (status != 0)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':  "
                     << "`Handle_Type::add_values' failed, returning " << status << "."
                     << endl
                     << "Failed to add handle values."
                     << endl 
                     << "Exiting `Scan_Parse_Parameter_Type::put' "
                     << "unsuccessfully with return value 1."
                     << endl;
                unlock_cerr_mutex(); 

                temp_strm.str("");

                temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                          << "1 \"Server error:  "
                          << "Failed to add handle values\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

                ++errors_occurred;

                return 1;

            }  /* |if (status != 0)|  */

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            else /* |status == 0|  */
            {
#if DEBUG_COMPILE
                     if (DEBUG)
                     {
                         lock_cerr_mutex(); 
                         cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':  "
                              << "`Handle_Type::add_values' succeeded, returning 0."
                              << endl;
                         unlock_cerr_mutex(); 

                     }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

                     temp_strm.str("");

                     temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                               << "0 \"Added handle values successfully\"";

                     new_response.command = temp_strm.str();

                     response_deque.push_back(new_response);

                 }  /* |else| (|status == 0|)  */

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            sql_strm.str("");

            if (result)
            {
               mysql_free_result(result);
               result = 0;
            }

            sql_strm << "select distinct handle_id from handlesystem_standalone.handles "
                     << "where type = 'IRODS_OBJECT_REF' "
                     << "and data = '" << response.local_filename << "'";

               
#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "sql_strm.str() == " << sql_strm.str() << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>


            status = submit_mysql_query(sql_strm.str().c_str(), 
                                        result,
                                        &row_ctr,
                                        &field_ctr);

@q ********* (9) @>

            if (status != 0)
            {
                 lock_cerr_mutex(); 
                 cerr << thread_str << "ERROR!  "
                      << "In `Scan_Parse_Parameter_Type::put':"
                      << endl 
                      << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                      << status << "."
                      << endl
                      << mysql_error(mysql_ptr)
                      << endl 
                      << "Failed to test for existing metadata handles."
                      << endl 
                      << "Exiting function unsuccessfully with return value 1."
                      << endl;
                 unlock_cerr_mutex(); 

                 if (result)
                 {
                     mysql_free_result(result);
                 }          

                 temp_strm.str("");

                 temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                           << "1 \"Server error:  "
                           << "Failed to test for existing metadata handles\"";

                 new_response.command = temp_strm.str();

                 response_deque.push_back(new_response);

                 ++errors_occurred;

                 return 1;


            }  /* |if (status != 0)|  */


@q ********* (9) @>

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "`submit_mysql_query' succeeded." << endl
                     << "`row_ctr' == " << row_ctr << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
                
@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            if (row_ctr > 0)
            {
@q ********** (10) @>

#if DEBUG_COMPILE   
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << "`row_ctr' == " << row_ctr << " (> 0)."
                         << endl
                         << row_ctr << " metadata handle(s) exist(s)."
                         << endl
                         << "Will create cross-references."
                         << endl;
                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

                for (int i = 0; i < row_ctr; ++i)
                {    
@q *********** (11) @>

                    if ((curr_row = mysql_fetch_row(result)) == 0)
                    {
                        lock_cerr_mutex(); 
                        cerr << thread_str << "ERROR!  "
                             << "In `Scan_Parse_Parameter_Type::put':"
                             << endl 
                             << "`mysql_fetch_row' failed:"
                             << endl
                             << mysql_error(mysql_ptr)
                             << endl 
                             << "Exiting function unsuccessfully with return value 1."
                             << endl;
                        unlock_cerr_mutex(); 

                        mysql_free_result(result);

                        temp_strm.str("");

                        temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                                  << "1 \"Server error:  "
                                  << "MySQL error:  Failed to fetch rows for existing "
                                  << "metadata handles\"";

                        new_response.command = temp_strm.str();

                        response_deque.push_back(new_response);

                        ++errors_occurred;

                        return 1;


                    }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q *********** (11) @>

#if DEBUG_COMPILE           
                    else if (DEBUG)
                    {
                        lock_cerr_mutex(); 
                        cerr << "`mysql_fetch_row' succeeded."
                             << endl
                             << "`curr_row[0]' == " << curr_row[0] 
                             << endl;
                        unlock_cerr_mutex(); 

                    }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */                                      

@q *********** (11) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

                    errno = 0;
                    curr_metadata_handle_id = strtoul(curr_row[0], 0, 10);

                    if (curr_metadata_handle_id == ULONG_MAX)
                    {
                        lock_cerr_mutex(); 
                        cerr << thread_str << "ERROR!  "
                             << "In `Scan_Parse_Parameter_Type::put':"
                             << endl 
                             << "`strtoul' failed, returning `ULONG_MAX':"
                             << endl
                             << strerror(errno)
                             << endl 
                             << "Exiting function unsuccessfully with return value 1."
                             << endl;
                        unlock_cerr_mutex(); 

                        mysql_free_result(result);

                        temp_strm.str("");

                        temp_strm <<  "PUT RESPONSE \"" 
                                  << response.local_filename << "\" "
                                  << "1 \"Server error:  "
                                  << "Failed to convert `handle_id' for existing "
                                  << "metadata handle\"";

                        new_response.command = temp_strm.str();

                        response_deque.push_back(new_response);

                        ++errors_occurred;

                        return 1;

                    }   /* |if|  */

@q *********** (11) @>

#if DEBUG_COMPILE
                    else if (DEBUG)            
                    {
                        lock_cerr_mutex(); 
                        cerr << "`strtoul' succeeded.  `curr_metadata_handle_id' == "
                             << curr_metadata_handle_id << "."
                             << endl;
                        unlock_cerr_mutex(); 

                    }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

                    metadata_handle_id_vector.push_back(curr_metadata_handle_id);

@q *********** (11) @>

                }  /* |for|  */


@q ********** (10) @>

            }  /* |if (row_ctr > 0)|  */

@q ********* (9) @>

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "`row_ctr' == 0.  No existing metadata handles for "
                     << "iRODS object `response.local_filename'." 
                     << endl
                     << "No need to create cross-references."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
     
@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            mysql_free_result(result);
            result = 0;
            sql_strm.str("");

#if DEBUG_COMPILE
            if (DEBUG)
            {            
                lock_cerr_mutex(); 
                cerr << "metadata_handle_id_vector.size() == " 
                     << metadata_handle_id_vector.size() << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */    


@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            if (metadata_handle_id_vector.size() > 0)
            {
@q ********** (10) @>

#if DEBUG_COMPILE
                if (DEBUG)        
                {
                    lock_cerr_mutex(); 
                    cerr << "`metadata_handle_id_vector':"
                         << endl;
                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

                status = fetch_handles_from_database(metadata_handle_id_vector, 
                                                     metadata_handle_vector);

                if (status != 0)
                {
                     lock_cerr_mutex(); 
                     cerr << thread_str << "ERROR!  "
                          << "In `Scan_Parse_Parameter_Type::put':"
                          << endl 
                          << "`Scan_Parse_Parameter_Type::fetch_handles_from_database' "
                          << "failed, returning " << status << "."
                          << endl 
                          << "Exiting function unsuccessfully with return value 1."
                          << endl;
                     unlock_cerr_mutex(); 

                     temp_strm.str("");

                     temp_strm <<  "PUT RESPONSE \"" 
                               << response.local_filename << "\" "
                               << "1 \"Server error:  "
                               << "Failed fetch metadata existing metadata handle(s) "
                               << "from database\"";

                     new_response.command = temp_strm.str();

                     response_deque.push_back(new_response);

                     ++errors_occurred;

                     return 1;

                }  /* |if (status != 0)|  */

@q ********** (10) @>

#if DEBUG_COMPILE
                else if (DEBUG)  
                {
                     lock_cerr_mutex(); 
                     cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                          << endl 
                          << "`Scan_Parse_Parameter_Type::fetch_handles_from_database' "
                          << "succeeded, returning 0." 
                          << endl
                          << "`metadata_handle_vector.size()' == " 
                          << metadata_handle_vector.size() 
                          << endl;
                     unlock_cerr_mutex(); 

                }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */               

@q ********** (10) @>

            }  /* |if (metadata_handle_id_vector.size() > 0)|  */


@q ********* (9) @>

#if DEBUG_COMPILE
            else if (DEBUG) 
            {
                lock_cerr_mutex(); 
                cerr << "`metadata_handle_id_vector' is empty.  Not creating cross-references."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>

        }  /* |if (handle_vector.size() > 0)|  */

@q ******** (8) @>

@ |handle_vector.size() == 0|.  This probably shouldn't ever happen.  However, I am not 
treating it as an error case at present.
\initials{LDF 2013.01.31.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

        else /* |handle_vector.size() == 0|  */
        {
#if DEBUG_COMPILE
            if (DEBUG)  
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':  "
                     << "`handle_vector.size()' == 0.  Not adding handle value."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        }  /* |else| (|handle_vector.size() == 0|)  */

@q ******** (8) @>

@ If |metadata_handle_id_vector| was empty, then |metadata_handle_vector| will
also be empty.  However, I've put this conditional here in order not to have
the code nested too deeply.
\initials{LDF 2013.02.07.}

@<|Scan_Parse_Parameter_Type::put| definition@>=


        if (metadata_handle_vector.size() > 0)
        {
@q ********* (9) @>

#if DEBUG_COMPILE
           if (DEBUG)  
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':  "
                    << "`metadata_handle_vector.size()' == " 
                    << metadata_handle_vector.size() << " (> 0)."
                    << endl 
                    << "Will add cross-references."
                    << endl;

               handle_vector.back().show("handle_vector.back():");

               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ********* (9) @>

           for (vector<Handle_Type>::iterator iter 
                   = metadata_handle_vector.begin();
                iter != metadata_handle_vector.end();
                ++iter)
           {   
@q ********** (10) @>

#if DEBUG_COMPILE
               if (DEBUG)     
               {
                   lock_cerr_mutex(); 
                   iter->show("*iter:");
                   unlock_cerr_mutex(); 

               }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

               status = handle_vector.back().add_value(
                                                   mysql_ptr, 
                                                   Handle_Value_Type::DC_METADATA_PID_INDEX,
                                                   "DC_METADATA_PID", 
                                                   iter->handle,
                                                   user_id);
               if (status != 0)
               {
@q *********** (11) @>

                     lock_cerr_mutex(); 
                     cerr << thread_str << "ERROR!  "
                          << "In `Scan_Parse_Parameter_Type::put':"
                          << endl 
                          << "`Handle_Type::add_value' "
                          << "failed, returning " << status << "."
                          << endl 
                          << "Exiting function unsuccessfully with return value 1."
                          << endl;
                     unlock_cerr_mutex(); 

                     temp_strm.str("");

                     temp_strm <<  "PUT RESPONSE \"" 
                               << response.local_filename << "\" "
                               << "1 \"Server error:  "
                               << "Failed to add cross-reference to existing "
                               << "metadata handle\"";

                     new_response.command = temp_strm.str();

                     response_deque.push_back(new_response);

                     ++errors_occurred;

                     return 1;


@q *********** (11) @>

               }  /* |if (status != 0)|  */

@q ********** (10) @>

               else 
               {
#if DEBUG_COMPILE  
                   if (DEBUG)
                   {
                       lock_cerr_mutex(); 
                       cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                            << endl 
                            << "`Handle_Type::add_value' succeeded, returning 0."
                            << endl;
                       unlock_cerr_mutex(); 

                   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */                

                   temp_strm.str("");

                   temp_strm <<  "PUT RESPONSE \"" 
                             << response.local_filename << "\" "
                             << "0 \"Success:  "
                             << "Added cross-reference to existing "
                             << "metadata handle `" << iter->handle << "'\"";

                   new_response.command = temp_strm.str();

                   response_deque.push_back(new_response);

               }  /* |else|  */  

@q ********** (10) @>
@ Call |Handle_Value_Type::add_value| to add a cross-reference in the metadata handles.
\initials{LDF 2013.02.27.}

@<|Scan_Parse_Parameter_Type::put| definition@>=


               status = iter->add_value(mysql_ptr, 
                                        Handle_Value_Type::IRODS_OBJECT_PID_INDEX, 
                                        "IRODS_OBJECT_PID", 
                                        handle_vector.back().handle,
                                        user_id);
   
               cerr << "WARNING!  Testing:  Not calling |Handle_Value_Type::add_value|."
                    << endl
                    << "Working on this.  Setting `status' to 0 and continuing."
                    << endl;

               if (status != 0)
               {
@q *********** (11) @>

                     lock_cerr_mutex(); 
                     cerr << thread_str << "ERROR!  "
                          << "In `Scan_Parse_Parameter_Type::put':"
                          << endl 
                          << "`Handle_Value_Type::add_value' "
                          << "failed, returning " << status << "."
                          << endl 
                          << "Exiting function unsuccessfully with return value 1."
                          << endl;
                     unlock_cerr_mutex(); 

                     temp_strm.str("");

                     temp_strm <<  "PUT RESPONSE \"" 
                               << response.local_filename << "\" "
                               << "1 \"Server error:  "
                               << "Failed to add cross-reference to new "
                               << "iRODS object PID in existing "
                               << "metadata handle\"";

                     new_response.command = temp_strm.str();

                     response_deque.push_back(new_response);

                     ++errors_occurred;

                     return 1;


@q *********** (11) @>

               }  /* |if (status != 0)|  */

@q ********** (10) @>

               else 
               {
#if DEBUG_COMPILE  
                   if (DEBUG)
                   {
                       lock_cerr_mutex(); 
                       cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                            << endl 
                            << "`Handle_Value_Type::add_value' succeeded, returning 0."
                            << endl;
                       unlock_cerr_mutex(); 

                   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */                

                   temp_strm.str("");

                   temp_strm <<  "PUT RESPONSE \"" 
                             << response.local_filename << "\" "
                             << "0 \"Success:  "
                             << "In existing metadata handle `" << iter->handle << "':  "
                             << "Added cross-reference to new iRODS object PID "
                             << "`" << handle_vector.back().handle << "'\"";

                   new_response.command = temp_strm.str();

                   response_deque.push_back(new_response);

               }  /* |else|  */  

@q ********** (10) @>
@
\LOG
\initials{LDF 2013.06.06.}
@:BUG FIX@> BUG FIX:  Now calling \.{imeta rm} to remove the AVU, if it already exists.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::put| definition@>=

               curr_avu.clear();
               curr_avu.set("DC_METADATA_PID", iter->handle);

               temp_strm.str("");

               temp_strm << "env irodsEnvFile=" << irods_env_filename
                         << " imeta rm -d \"" << response.local_filename 
                         << "\" DC_METADATA_PID \"" << iter->handle << "\" >/dev/null 2>&1; "
                         << "env irodsEnvFile=" << irods_env_filename
                         << " imeta add -d \"" << response.local_filename 
                         << "\" DC_METADATA_PID \"" << iter->handle << "\"";

#if DEBUG_COMPILE
               if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << "temp_strm.str() == " << temp_strm.str() << endl;

                   cerr << "response.pid_str == " << response.pid_str << endl;
                   cerr << "pid_str == " << pid_str << endl;
                   cerr << "iter->handle == " << iter->handle << endl;

                   unlock_cerr_mutex(); 

               }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */         

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

               status = system(temp_strm.str().c_str());

               if (status == -1 || !WIFEXITED(status))
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':  "
                        << "`system' failed, returning " << status << "."
                        << endl;

                   if (WIFEXITED(status))
                      cerr << "WEXITSTATUS(status) == " << WEXITSTATUS(status) 
                           << endl;
                   else
                      cerr << "Process failed to exit."
                           << endl;
 
                   cerr << "Exiting `Scan_Parse_Parameter_Type::put' "
                        << "unsuccessfully with return value 1."
                        << endl;
                   unlock_cerr_mutex(); 


                   temp_strm.str("");

                   temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                             << "2 \"Server error:  "
                             << "Failed to store Dublin Core Metadata PID `" << iter->handle
                             << "' in iRODS object metadata\"";

                   new_response.command = temp_strm.str();

                   response_deque.push_back(new_response);

                   ++errors_occurred;

                   return 1;

               }   /* |(status == -1 || !WIFEXITED(status))|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

               else if (WEXITSTATUS(status) != 0)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':  "
                        << "`imeta' command (called via `system') failed, "
                        << "returning " << WEXITSTATUS(status) << "."
                        << endl
                        << "Exiting `Scan_Parse_Parameter_Type::put' "
                        << "unsuccessfully with return value 1."
                        << endl;
                   unlock_cerr_mutex(); 

                   temp_strm.str("");

                   temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                             << "2 \"Server error:  "
                             << "Failed to store Dublin Core Metadata PID `" << iter->handle
                             << "' in iRODS object metadata\"";

                   new_response.command = temp_strm.str();

                   response_deque.push_back(new_response);

                   ++errors_occurred;

                   return 1;

               }  /* |else if (WEXITSTATUS(status) != 0)|  */
        
@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

               else  /* \.{imeta} command succeeded.  */
               {

#if DEBUG_COMPILE 
                    if (DEBUG)  
                    {
                        lock_cerr_mutex(); 
                        cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':  "
                             << "`system' succeeded `WEXITSTATUS(status)' == " 
                             << WEXITSTATUS(status) << "." << endl;
                        unlock_cerr_mutex(); 
                     
                    }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

                    curr_irods_object.avu_vector.push_back(curr_avu);

                    curr_avu.clear();

                    temp_strm.str("");

                    temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                              << "0 \"Success:  "
                              << "Stored Dublin Core Metadata PID `" << iter->handle
                              << "' in iRODS object metadata\"";             

                    new_response.command = temp_strm.str();

                    response_deque.push_back(new_response);


               }  /* |else| (\.{imeta} command succeeded.)  */

@q ********** (10) @>

           }  /* |for|  */

@q ********* (9) @>

#if DEBUG_COMPILE
           if (DEBUG)  
           {
               lock_cerr_mutex(); 
               cerr << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>

        }  /* |if (metadata_handle_vector.size() == 0)|  */


@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
        else if (DEBUG)  
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':  "
                 << "`metadata_handle_vector.size()' == 0.  Not adding cross-references."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>
@

\LOG
\initials{LDF 2013.06.06.}
@:BUG FIX@> BUG FIX:  Now calling \.{imeta rm} to remove the AVU, if it already exists.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::put| definition@>=

         curr_avu.clear();

         curr_avu.set("PID", response.pid_str);

         temp_strm.str("");

         temp_strm << "env irodsEnvFile=" << irods_env_filename
                   << " imeta rm -d \"" << response.local_filename 
                   << "\" PID \"" << response.pid_str << "\" >/dev/null 2>&1; "
                   << "env irodsEnvFile=" << irods_env_filename
                   << " imeta add -d \"" << response.local_filename 
                   << "\" PID \"" << response.pid_str << "\"";

#if DEBUG_COMPILE
         if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "temp_strm.str() == " << temp_strm.str() << endl;
             unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */         

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

         status = system(temp_strm.str().c_str());

         if (status == -1 || !WIFEXITED(status))
         {
             lock_cerr_mutex(); 
             cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':  "
                  << "`system' failed, returning " << status << "."
                  << endl;

             if (WIFEXITED(status))
                cerr << "WEXITSTATUS(status) == " << WEXITSTATUS(status) 
                     << endl;
             else
                cerr << "Process failed to exit."
                     << endl;
 
             cerr << "Exiting `Scan_Parse_Parameter_Type::put' "
                  << "unsuccessfully with return value 1."
                  << endl;
             unlock_cerr_mutex(); 


             temp_strm.str("");

             temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                       << "2 \"Server error:  "
                       << "Failed to store PID `" << response.pid_str 
                       << "' in iRODS object metadata\"";

             new_response.command = temp_strm.str();

             response_deque.push_back(new_response);

             ++errors_occurred;

             return 1;

         }   /* |(status == -1 || !WIFEXITED(status))|  */

@q ******** (8) @>
@
\LOG
\initials{LDF 2013.01.31.}
Added this section.

\initials{LDF 2013.01.31.}
@:BUG FIX@> BUG FIX:  Now testing |WEXITSTATUS(status)|.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

         else if (WEXITSTATUS(status) != 0)
         {
             lock_cerr_mutex(); 
             cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':  "
                  << "`imeta' command (called via `system') failed, "
                  << "returning " << WEXITSTATUS(status) << "."
                  << endl
                  << "Exiting `Scan_Parse_Parameter_Type::put' "
                  << "unsuccessfully with return value 1."
                  << endl;
             unlock_cerr_mutex(); 

             temp_strm.str("");

             temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                       << "2 \"Server error:  "
                       << "Failed to store PID `" << response.pid_str 
                       << "' in iRODS object metadata\"";

             new_response.command = temp_strm.str();

             response_deque.push_back(new_response);

             ++errors_occurred;

             return 1;

         }  /* |else if (WEXITSTATUS(status) != 0)|  */
        
@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

         else  /* \.{imeta} command succeeded.  */
         {

#if DEBUG_COMPILE 
              if (DEBUG)  
              {
                  lock_cerr_mutex(); 
                  cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':  "
                       << "`system' succeeded `WEXITSTATUS(status)' == " 
                       << WEXITSTATUS(status) << "." << endl;
                  unlock_cerr_mutex(); 
               
              }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

              curr_irods_object.avu_vector.push_back(curr_avu);
              curr_avu.clear();

              temp_strm.str("");

              temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" 0 \"Success:  "
                        << "Stored PID `" << response.pid_str 
                        << "' in iRODS object metadata\"";             

              new_response.command = temp_strm.str();

              response_deque.push_back(new_response);


         }  /* |else| (\.{imeta} command succeeded.)  */

@q ******** (8) @>

     }  /* |if (response.pid_options & 1U)|  */
 

@q ******* (7) @>

@ At this point, we only need to know whether a row corresponding to |curr_irods_object| exists 
in the \.{Irods\_Objects} table and if so, what its |id| is;  
We don't need to have the data from the database entry 
fetched into |curr_irods_object|.  We therefore pass |true| as the |id_only| argument 
to |Irods_Object_Type::get_from_database|.  
\initials{LDF 2013.01.09.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

     if (irods_object_ctr == 0)  /* |curr_irods_object.get_from_database| returned 0  */
     {
@q ******** (8) @>

#if DEBUG_COMPILE
         if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                  << endl
                  << "`Irods_Object_Type::get_from_database' succeeded, returning 0."
                  << endl 
                  << "No row exists for iRODS object `" << response.local_filename << "' "
                  << "in `Irods_Objects' table yet."
                  << endl 
                  << "Will create."
                  << "`curr_irods_object.id' == " << curr_irods_object.id
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */
#endif   /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>
@ 
@<|Scan_Parse_Parameter_Type::put| definition@>=

         status = curr_irods_object.write_to_database(mysql_ptr);

         if (status != 0)
         {
            lock_cerr_mutex(); 
            cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                 << endl
                 << "`Irods_Object_Type::write_to_database' failed, returning " 
                 << status << "."
                 << endl 
                 << "Failed to write data for `Irods_Object_Type curr_irods_object' "
                 << "to `gwirdsif.Irods_Objects' database table."
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            temp_strm.str("");

            temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                      << "1 \"Server error:  "
                      << "C++ error:  Failed to write data for `Irods_Object_Type' object "
                      << "to `gwirdsif.Irods_Objects' database table";

            new_response.command = temp_strm.str();

            response_deque.push_back(new_response);

            ++errors_occurred;

            return 1;


         }  /* |if (status != 0)|  */
  
@q ******** (8) @>

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                 << endl
                 << "`Irods_Object_Type::write_to_database' succeeded, returning 0." 
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ******** (8) Add AVUs for iRODS objects created with compression options.  @>

@ Add AVUs for iRODS objects created with compression options.  
\initials{LDF 2014.01.23.}

\LOG
\initials{LDF 2014.01.23.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

@q ********* (9) @>


        if (is_tar_file)
        {
            curr_avu.clear();
            curr_avu.set("COMPRESSED_TAR_FILE", 
                         "compressed tar file",
                         "",
                         0U,
                         curr_irods_object.id);

            status = curr_irods_object.add_avu(curr_avu, 
                                               irods_env_filename, 
                                               true, 
                                               true,
                                               true, 
                                               mysql_ptr, 
                                               thread_ctr);

            if (status != 0)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' failed, returning " 
                     << status << "."
                     << endl 
                     << "Failed to add AVU with `attribute' == `COMPRESSED_TAR_FILE' "
                     << "to `Irods_Object_Type curr_irods_object'."
                     << endl
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;
                unlock_cerr_mutex(); 

                temp_strm.str("");

                temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                          << GW_ERROR << " \"Server error:  "
                          << "Failed to created AVU with attribute \002COMPRESSED_TAR_FILE\003 "
                          << "for `Irods_Object_Type' object.\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

                ++errors_occurred;

                return 1;

            }  /* |if (status != 0)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                     << endl 
                     << "Added AVU to `Irods_Object_Type curr_irods_object' successfully."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>

        }

@q ********* (9) @>

        if (compressed_gzip)
        {
            curr_avu.clear();
            curr_avu.set("COMPRESSED_GZIP", 
                         "compressed gzip",
                         "",
                         0U,
                         curr_irods_object.id);

            status = curr_irods_object.add_avu(curr_avu, 
                                               irods_env_filename, 
                                               true, 
                                               true,
                                               true, 
                                               mysql_ptr, 
                                               thread_ctr);

            if (status != 0)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' failed, returning " 
                     << status << "."
                     << endl 
                     << "Failed to add AVU with `attribute' == `COMPRESSED_GZIP' "
                     << "to `Irods_Object_Type curr_irods_object'."
                     << endl
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;
                unlock_cerr_mutex(); 

                temp_strm.str("");

                temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                          << GW_ERROR << " \"Server error:  "
                          << "Failed to created AVU with attribute \002COMPRESSED_GZIP\003 "
                          << "for `Irods_Object_Type' object.\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

                ++errors_occurred;

                return 1;

            }  /* |if (status != 0)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                     << endl 
                     << "Added AVU to `Irods_Object_Type curr_irods_object' successfully."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>

        }

@q ********* (9) @>

        else if (compressed_bzip2)
        {
            curr_avu.clear();
            curr_avu.set("COMPRESSED_BZIP2", 
                         "compressed bzip2",
                         "",
                         0U,
                         curr_irods_object.id);

            status = curr_irods_object.add_avu(curr_avu, 
                                               irods_env_filename, 
                                               true, 
                                               true,
                                               true, 
                                               mysql_ptr, 
                                               thread_ctr);

            if (status != 0)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' failed, returning " 
                     << status << "."
                     << endl 
                     << "Failed to add AVU with `attribute' == `COMPRESSED_BZIP2' "
                     << "to `Irods_Object_Type curr_irods_object'."
                     << endl
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;
                unlock_cerr_mutex(); 

                temp_strm.str("");

                temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                          << GW_ERROR << " \"Server error:  "
                          << "Failed to created AVU with attribute \002COMPRESSED_BZIP2\003 "
                          << "for `Irods_Object_Type' object.\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

                ++errors_occurred;

                return 1;

            }  /* |if (status != 0)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                     << endl 
                     << "Added AVU to `Irods_Object_Type curr_irods_object' successfully."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>

        }

@q ******** (8) Add AVUs for iRODS objects created with encryption options.  @>

@ Add AVUs for iRODS objects created with encryption options.  
\initials{LDF 2014.01.15.}

\LOG
\initials{LDF 2014.01.14.}
Added this section.
\ENDLOG

@q ********* (9) Encrypted.  @>

@ Encrypted.  
\initials{LDF 2014.01.15.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

        if (encrypt)
        {
@q ********** (10) @>

            curr_avu.clear();
            curr_avu.set("ENCRYPTED", 
                         curr_irods_object.gpg_key_fingerprint_encrypt,
                         "",
                         0U,
                         curr_irods_object.id);

            status = curr_irods_object.add_avu(curr_avu, 
                                               irods_env_filename, 
                                               true, 
                                               true,
                                               true, 
                                               mysql_ptr, 
                                               thread_ctr);

            if (status != 0)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' failed, returning " 
                     << status << "."
                     << endl 
                     << "Failed to add AVU with `attribute' == `ENCRYPTED' "
                     << "to `Irods_Object_Type curr_irods_object'."
                     << endl
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;
                unlock_cerr_mutex(); 

                temp_strm.str("");

                temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                          << GW_ERROR << " \"Server error:  "
                          << "Failed to created AVU with attribute \002ENCRYPTED\003 "
                          << "for `Irods_Object_Type' object.\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

                ++errors_occurred;

                return 1;

            }  /* |if (status != 0)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                     << endl 
                     << "Added AVU to `Irods_Object_Type curr_irods_object' successfully."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>

        }  /* |if (encrypt)|  */

@q ********* (9) Signed.  @>

@ Signed.  
\initials{LDF 2014.01.15.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

        if (sign)
        {
@q ********** (10) @>

            curr_avu.clear();
            curr_avu.set("SIGNED", 
                         curr_irods_object.gpg_key_fingerprint_sign,
                         "",
                         0U,
                         curr_irods_object.id);

            status = curr_irods_object.add_avu(curr_avu, 
                                               irods_env_filename, 
                                               true, 
                                               true,
                                               true, 
                                               mysql_ptr, 
                                               thread_ctr);

            if (status != 0)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' failed, returning " 
                     << status << "."
                     << endl 
                     << "Failed to add AVU with `attribute' == `SIGNED' "
                     << "to `Irods_Object_Type curr_irods_object'."
                     << endl
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;
                unlock_cerr_mutex(); 

                temp_strm.str("");

                temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                          << GW_ERROR << " \"Server error:  "
                          << "Failed to created AVU with attribute \002SIGNED\003 "
                          << "for `Irods_Object_Type' object.\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

                ++errors_occurred;

                return 1;

            }  /* |if (status != 0)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                     << endl 
                     << "Added AVU to `Irods_Object_Type curr_irods_object' successfully."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>

        }  /* |if (sign)|  */

@q ********* (9) Verified (not detached).  @>

@ Verified (not detached).
\initials{LDF 2014.01.15.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

        if (verify && !(detached || signature))
        {
@q ********** (10) @>

            curr_avu.clear();
            curr_avu.set("VERIFIED", 
                         curr_irods_object.gpg_key_fingerprint_sign,
                         "",
                         0U,
                         curr_irods_object.id);

            status = curr_irods_object.add_avu(curr_avu, 
                                               irods_env_filename, 
                                               true, 
                                               true,
                                               true, 
                                               mysql_ptr, 
                                               thread_ctr);

            if (status != 0)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' failed, returning " 
                     << status << "."
                     << endl 
                     << "Failed to add AVU with `attribute' == `VERIFIED' (1) "
                     << "to `Irods_Object_Type curr_irods_object'."
                     << endl
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;
                unlock_cerr_mutex(); 

                temp_strm.str("");

                temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                          << GW_ERROR << " \"Server error:  "
                          << "Failed to created AVU with attribute \002VERIFIED\003 "
                          << "for `Irods_Object_Type' object.\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

                ++errors_occurred;

                return 1;

            }  /* |if (status != 0)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                     << endl 
                     << "Added AVU to `Irods_Object_Type curr_irods_object' successfully."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>

        }  /* |if (verify && !detached)|  */



@q ********* (9) Clearsigned.  @>

@ Clearsigned.  
\initials{LDF 2014.01.15.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

        if (clearsign)
        {
@q ********** (10) @>

            curr_avu.clear();
            curr_avu.set("CLEARSIGNED", 
                         curr_irods_object.gpg_key_fingerprint_sign,
                         "",
                         0U,
                         curr_irods_object.id);

            status = curr_irods_object.add_avu(curr_avu, 
                                               irods_env_filename, 
                                               true, 
                                               true,
                                               true, 
                                               mysql_ptr, 
                                               thread_ctr);

            if (status != 0)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' failed, returning " 
                     << status << "."
                     << endl 
                     << "Failed to add AVU with `attribute' == `CLEARSIGNED' "
                     << "to `Irods_Object_Type curr_irods_object'."
                     << endl
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;
                unlock_cerr_mutex(); 

                temp_strm.str("");

                temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                          << GW_ERROR << " \"Server error:  "
                          << "Failed to created AVU with attribute \002CLEARSIGNED\003 "
                          << "for `Irods_Object_Type' object.\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

                ++errors_occurred;

                return 1;

            }  /* |if (status != 0)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                     << endl 
                     << "Added AVU to `Irods_Object_Type curr_irods_object' successfully."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>

        }  /* |if (clearsign)|  */

@q ********* (9) @>


@q ********* (9) @>

@q ******** (8) @>
@
\LOG
\initials{LDF 2014.01.10.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

        if (signature)
        {
@q ********* (9) @>

#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`signature' == `true'."
                     << endl
                     << "`curr_irods_object.id' == " << curr_irods_object.id
                     << endl;

                response.show("response:");
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
            
@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            if (response.string_val.empty())
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "WARNING! In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`signature' == `true', but `response.string_val' is empty."
                     << endl
                     << "Base file for detached signature file unknown.  Can't update."
                     << endl
                     << "Will send error message to client and try to continue."
                     << endl;
                unlock_cerr_mutex(); 

                temp_strm.str("");
                temp_strm <<  "PUT RESPONSE \"" << response.local_filename 
                          << "\" " << GW_ERROR << " \"Base file for detached signature file "
                          << "unknown:  Can't update.\"";

                new_response.command = temp_strm.str();
                response_deque.push_back(new_response);

                ++warnings_occurred;

            }  /* |if (response.string_val.empty())|  */

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            else
            {
@q ********** (10) @>

                sql_strm.str("");

                sql_strm << "select irods_object_id from gwirdsif.Irods_Objects "
                         << "where user_id = " << user_id << " and irods_object_path = '";

                pos = response.string_val.find("/");

                if (pos == string::npos)
                    sql_strm << irods_current_dir << "/";
                
                sql_strm << response.string_val << "'";

@q ********** (10) @>

#if DEBUG_COMPILE
                if (DEBUG)   
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                         << endl
                         << "`sql_strm.str()' == " << sql_strm.str()
                         << endl;
                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

                status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);

@q ********** (10) @>

                if (status != 0 || row_ctr == 0)
                {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                        << endl;


                   if (status != 0)
                      cerr << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                           << status 
                           << endl 
                           << mysql_error(mysql_ptr) << ":"
                           << endl;
                         
                   else
                      cerr << "`row_ctr' == 0:"
                           << endl;

                   cerr << "Failed to retrieve entry for base file for detached signature "
                        << "from the `gwirdsif.Irods_Objects' database table."
                        << endl
                        << "Exiting function unsuccessfully with return value 1."
                        << endl;
                   unlock_cerr_mutex(); 

                   if (result)
                      mysql_free_result(result);
   
                   temp_strm.str("");

                   temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                             << GW_SERVER_SIDE_DATABASE_ERROR << "\"Server-side database error\"";

                   new_response.command = temp_strm.str();

                   response_deque.push_back(new_response);

                   ++errors_occurred;

                   return 1;

                }  /* |if (status != 0 || row_ctr == 0)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
                else if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                         << endl
                         << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded, "
                         << "returning 0." 
                         << endl
                         << "`row_ctr' == " << row_ctr
                         << endl;
                     unlock_cerr_mutex(); 

                }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


            }  /* |else|  */

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            curr_row = mysql_fetch_row(result);

            if (curr_row == 0 || curr_row[0] == 0 || strlen(curr_row[0]) == 0)
            {
               lock_cerr_mutex(); 
               cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':" 
                    << endl;

               if (curr_row == 0)
                  cerr << "`mysql_fetch_row' failed, returning 0:" 
                       << endl 
                       << mysql_error(mysql_ptr) << "."
                       << endl;

               else if (curr_row[0] == 0)
                   cerr << "`curr_row[0]' is NULL."
                        << endl;
          
               else 
                   cerr << "`curr_row[0]' is empty."
                        << endl;

               cerr << "Failed to retrieve entry for base file for detached signature "
                    << "from the `gwirdsif.Irods_Objects' database table."
                    << endl
                    << "Exiting function unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               if (result)
                  mysql_free_result(result);
   
               temp_strm.str("");

               temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                         << GW_SERVER_SIDE_DATABASE_ERROR << "\"Server-side database error\"";

               new_response.command = temp_strm.str();

               response_deque.push_back(new_response);

               ++errors_occurred;

               return 1;

            }  /* |if|  */ 

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':" 
                     << endl
                     << "`curr_row[0]' == " << curr_row[0]
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            errno = 0;
            temp_val = strtoul(curr_row[0], 0, 10);

            if (temp_val == ULONG_MAX)
            {
               lock_cerr_mutex(); 
               cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':" 
                    << endl
                    << "`strtoul' failed, returning `ULONG_MAX':"
                    << endl
                    << strerror(errno)
                    << endl 
                    << "Failed to retrieve entry for base file for detached signature "
                    << "from the `gwirdsif.Irods_Objects' database table."
                    << endl
                    << "Exiting function unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               if (result)
                  mysql_free_result(result);
   
               temp_strm.str("");

               temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                         << GW_ERROR << "\"Failed to retrieve base file (iRODS object) ID for "
                         << "detached signature.\"";

               new_response.command = temp_strm.str();

               response_deque.push_back(new_response);

               ++errors_occurred;

               return 1;

            }  /* |if|  */ 

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':" 
                     << endl
                     << "`strtoul' succeeded:  `temp_val' == " << temp_val
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            if (result)
            {
               mysql_free_result(result);
               result = 0;
            }

            sql_strm.str("");

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            sql_strm << "update gwirdsif.Irods_Objects set detached_signature_irods_object_id "
                     << "= " << curr_irods_object.id << " where irods_object_id = " << temp_val;

#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`sql_strm.str()' == " << sql_strm.str()
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

            status = submit_mysql_query(sql_strm.str(), result, 0, 0, &affected_rows);

@q ********* (9) @>

            if (status != 0 || affected_rows == 0)
            {
               lock_cerr_mutex(); 
               cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                    << endl;


               if (status != 0)
                  cerr << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                       << status 
                       << endl 
                       << mysql_error(mysql_ptr) << ":"
                       << endl;
                          
               else
                  cerr << "`affected_rows' == 0:"
                       << endl;

               cerr << "Failed to update entry for base file for detached signature "
                    << "in the `gwirdsif.Irods_Objects' database table."
                    << endl
                    << "Exiting function unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               if (result)
                  mysql_free_result(result);
   
               ++errors_occurred;

               temp_strm.str("");

               temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                         << GW_SERVER_SIDE_DATABASE_ERROR << "\"Server-side database error\"";

               new_response.command = temp_strm.str();

               response_deque.push_back(new_response);

               return 1;

            }  /* |if (status != 0 || affected_rows == 0)|  */

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded, "
                     << "returning 0." 
                     << endl
                     << "`affected_rows' == " << affected_rows
                     << endl;
                 unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>


            mysql_free_result(result);
            result = 0;
            sql_strm.str("");

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

            sql_strm << "update gwirdsif.Irods_Objects set irods_object_ref_id "
                     << "= " << temp_val << ", detached_signature_irods_object_id = "
                     << curr_irods_object.id << " where irods_object_id = " 
                     << curr_irods_object.id;

#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`sql_strm.str()' == " << sql_strm.str()
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


            status = submit_mysql_query(sql_strm.str(), result, 0, 0, &affected_rows);

@q ********* (9) @>

            if (status != 0 || affected_rows == 0)
            {
               lock_cerr_mutex(); 
               cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                    << endl;

               if (status != 0)
                  cerr << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
                       << status 
                       << endl 
                       << mysql_error(mysql_ptr) << ":"
                       << endl;
                          
               else
                  cerr << "`affected_rows' == 0:"
                       << endl;

               cerr << "Failed to update entry for detached signature file "
                    << "in the `gwirdsif.Irods_Objects' database table."
                    << endl
                    << "Exiting function unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               if (result)
                  mysql_free_result(result);
   
               ++errors_occurred;

               temp_strm.str("");

               temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                         << GW_SERVER_SIDE_DATABASE_ERROR << "\"Server-side database error\"";

               new_response.command = temp_strm.str();

               response_deque.push_back(new_response);

               return 1;

            }  /* |if (status != 0 || affected_rows == 0)|  */

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
            else if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                     << endl
                     << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded, "
                     << "returning 0." 
                     << endl
                     << "`affected_rows' == " << affected_rows
                     << endl;
                 unlock_cerr_mutex(); 

            }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>

            curr_irods_object.irods_object_ref_id = temp_val;
            curr_irods_object.detached_signature_irods_object_id = curr_irods_object.id;


            mysql_free_result(result);
            result = 0;
            sql_strm.str("");

@q ********* (9) |verify == true|.  Verify signature.  @>
@ |verify == true|.  Verify signature.  
\initials{LDF 2014.01.13.}

\LOG
\initials{LDF 2014.01.13.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

           if (verify == true)
           {
@q ********** (10) @>

#if DEBUG_COMPILE
               if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                        << endl
                        << "`signature' and `verify' == `true':"
                        << endl
                        << "Will try to verify signature."
                        << endl;
#if 0 

                    curr_irods_object.show("curr_irods_object:");
#endif 

                    unlock_cerr_mutex(); 

               }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>

               status = curr_irods_object.verify_signature(mysql_ptr, 
                                                           response,
                                                           base_irods_object,
                                                           thread_str);

               if (status != 0)
               {
                  lock_cerr_mutex(); 
                  cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                       << endl
                       << "`Irods_Object_Type::verify_signature' failed, returning " 
                       << status  << ":"
                       << "Failed to verify detached signature file "
                       << "in the `gwirdsif.Irods_Objects' database table."
                       << endl
                       << "Exiting function unsuccessfully with return value 1."
                       << endl;
                  unlock_cerr_mutex(); 

                  temp_strm.str("");

                  temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                            << GW_ERROR << "\"Failed to verify detached GPG signature.\"";

                  new_response.command = temp_strm.str();

                  response_deque.push_back(new_response);

                  ++errors_occurred;

                  return 1;

               }  /* |if (status != 0)|  */

@q ********** (10) @>

#if DEBUG_COMPILE
               else if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                        << endl
                        << "`Irods_Object_Type::verify_signature' succeeded, returning 0."
                        << endl;

                   base_irods_object.show("base_irods_object:");

                   unlock_cerr_mutex(); 

               }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=


                temp_strm.str("");

                temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                          << GW_SUCCESS << "\"Verified detached GPG signature successfully.\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

@q ********** (10) @>

           }  /* |if (verify == true)|  */

@q ********* (9) @>

#if DEBUG_COMPILE
           else if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                    << endl
                    << "`signature' == `true' but `verify' == `false':"
                    << endl
                    << "Won't try to verify signature."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>
@
\LOG
\initials{LDF 2014.01.15.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::put| definition@>=

@q ********* (9) @>

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               base_irods_object.show("base_irods_object:");
               cerr << "temp_val == " << temp_val << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>

           if (base_irods_object.id == 0 && temp_val == 0)
           {
                  lock_cerr_mutex(); 
                  cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                       << endl
                       << "`base_irods_object.id' == 0 and `temp_val' == 0:"
                       << endl 
                       << "Base file (iRODS object) for detached signature unknown."
                       << endl
                       << "Exiting function unsuccessfully with return value 1."
                       << endl;
                  unlock_cerr_mutex(); 

                  temp_strm.str("");

                  temp_strm << "PUT RESPONSE \"" << response.local_filename << "\" "
                            << GW_ERROR << "\"Failed to find base file (iRODS object) "
                            << "for detached GPG signature.\"";

                  new_response.command = temp_strm.str();

                  response_deque.push_back(new_response);

                  ++errors_occurred;

                  return 1;

           }  /* |if (base_irods_object.id == 0 && temp_val == 0)|  */


@q ********* (9) @>

           else if (base_irods_object.id == 0)
           {
               base_irods_object.id = temp_val;

               status = base_irods_object.get_from_database(mysql_ptr, false, thread_str);

@q ********** (10) @>

               if (status <= 0)
               {
                  lock_cerr_mutex(); 
                  cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                       << endl
                       << "`Irods_Object_Type::get_from_database' failed, returning "
                       << status << ":"
                       << endl 
                       << "Failed to retrieve base file (iRODS object) for detached signature."
                       << endl
                       << "Exiting function unsuccessfully with return value 1."
                       << endl;
                  unlock_cerr_mutex(); 

                  temp_strm.str("");

                  temp_strm << "PUT RESPONSE \"" << response.local_filename << "\" "
                            << GW_ERROR << "\"Failed retrieve database entry for base file "
                            << "(iRODS object) for detached GPG signature.\"";

                  new_response.command = temp_strm.str();

                  response_deque.push_back(new_response);

                  ++errors_occurred;

                  return 1;

               }  /* |if (status <= 0)|  */

@q ********** (10) @>

#if DEBUG_COMPILE
               else if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                        << endl
                        << "`Irods_Object_Type::get_from_database' succeeded, returning "
                        << status << "."
                        << endl;

                   base_irods_object.show("base_irods_object:");

                   curr_irods_object.show("curr_irods_object:");

                   unlock_cerr_mutex(); 

               }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>

           }  /* |else if (base_irods_object.id == 0)|  */

@q ********* (9) Add AVUs on |curr_irods_object|.  @>

@ Add AVUs on |curr_irods_object|.  
\initials{LDF 2014.01.15.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

           curr_avu.clear();
           curr_avu.set("DETACHED_SIGNATURE", 
                        curr_irods_object.gpg_key_fingerprint_sign,
                        "",
                        0U,
                        curr_irods_object.id);

           status = curr_irods_object.add_avu(curr_avu, 
                                              irods_env_filename, 
                                              true, 
                                              true,
                                              true, 
                                              mysql_ptr, 
                                              thread_ctr);

           if (status != 0)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                    << endl
                    << "`Irods_Object_Type::add_avu' failed, returning " 
                    << status << "."
                    << endl 
                    << "Failed to add AVU with `attribute' == `DETACHED_SIGNATURE' "
                     << "to `Irods_Object_Type curr_irods_object'."
                    << endl
                    << "Exiting function unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               temp_strm.str("");

               temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                         << GW_ERROR << " \"Server error:  "
                         << "Failed to created AVU with attribute \002DETACHED_SIGNATURE\003 "
                         << "for `Irods_Object_Type' object.\"";

               new_response.command = temp_strm.str();

               response_deque.push_back(new_response);

               ++errors_occurred;

               return 1;

           }  /* |if (status != 0)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
           else if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                    << endl
                    << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                    << endl 
                    << "Added AVU to `Irods_Object_Type curr_irods_object' successfully."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

           if (verify)
           {
@q *********** (11) @>

               curr_avu.clear();
               curr_avu.set("VERIFIED", 
                            curr_irods_object.gpg_key_fingerprint_sign,
                            "",
                            0U,
                            curr_irods_object.id);

               status = curr_irods_object.add_avu(curr_avu, 
                                                  irods_env_filename, 
                                                  true, 
                                                  true,
                                                  true, 
                                                  mysql_ptr, 
                                                  thread_ctr);

               if (status != 0)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                        << endl
                        << "`Irods_Object_Type::add_avu' failed, returning " 
                        << status << "."
                        << endl 
                        << "Failed to add AVU with `attribute' == `VERIFIED' (2) "
                        << "to `Irods_Object_Type curr_irods_object'."
                        << endl
                        << "Exiting function unsuccessfully with return value 1."
                        << endl;
                   unlock_cerr_mutex(); 

                   temp_strm.str("");

                   temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                             << GW_ERROR << " \"Server error:  "
                             << "Failed to created AVU with attribute \002VERIFIED\003 "
                             << "for `Irods_Object_Type' object.\"";

                   new_response.command = temp_strm.str();

                   response_deque.push_back(new_response);

                   ++errors_occurred;

                   return 1;

               }  /* |if (status != 0)|  */

@q *********** (11) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
               else if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                        << endl
                        << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                        << endl 
                        << "Added AVU to `Irods_Object_Type curr_irods_object' successfully."
                        << endl;
                   unlock_cerr_mutex(); 

               }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q *********** (11) @>

               }  /* |if (verify)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

           curr_avu.clear();
           curr_avu.set("IRODS_OBJECT_REF", 
                        base_irods_object.path,
                        "",
                        0U,
                        curr_irods_object.id);

           status = curr_irods_object.add_avu(curr_avu, 
                                              irods_env_filename, 
                                              true, 
                                              true,
                                              true, 
                                              mysql_ptr, 
                                              thread_ctr);

           if (status != 0)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                    << endl
                    << "`Irods_Object_Type::add_avu' failed, returning " 
                    << status << "."
                    << endl 
                    << "Failed to add AVU with `attribute' == `IRODS_OBJECT_REF' "
                    << "to `Irods_Object_Type curr_irods_object'."
                    << endl
                    << "Exiting function unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               temp_strm.str("");

               temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                         << GW_ERROR << " \"Server error:  "
                         << "Failed to created AVU with attribute \002IRODS_OBJECT_REF\003 "
                         << "for `Irods_Object_Type' object.\"";

               new_response.command = temp_strm.str();

               response_deque.push_back(new_response);

               ++errors_occurred;

               return 1;

           }  /* |if (status != 0)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
           else if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                    << endl
                    << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                    << endl 
                    << "Added AVU to `Irods_Object_Type curr_irods_object' successfully."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) IRODS_OBJECT_REF_PID @>

@ \.{IRODS\_OBJECT\_REF\_PID}.
\initials{LDF 2014.01.15.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

@q *********** (11) @>

           avu_iter = base_irods_object.find_avu("PID", "", true, thread_str);

           if (avu_iter == base_irods_object.avu_vector.end())
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "WARNING!  In `Scan_Parse_Parameter_Type::put':"
                    << endl
                    << "`Irods_Object_Type::find_avu' failed, returning "
                    << "`base_irods_object.avu_vector.end()':"
                    << endl 
                    << "Failed to find AVU with `attribute' == \"PID\" on "
                    << "`base_irods_object.avu_vector'."
                    << endl
                    << "Not adding AVU with `attribute' == \"IRODS_OBJECT_REF_PID\" "
                    << "on `curr_irods_object'."
                    << endl
                    << "Continuing."
                    << endl;
               unlock_cerr_mutex(); 

           }

@q *********** (11) @>

           else
           {
@q ************ (12) @>

#if DEBUG_COMPILE
               if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                        << endl
                        << "`Irods_Object_Type::find_avu' succeeded:"
                        << "`base_irods_object.avu_vector.end()':"
                        << endl 
                        << "Found AVU with `attribute' == \"PID\" on "
                        << "`base_irods_object.avu_vector':"
                        << endl;
                    
                   avu_iter->show("*avu_iter:");

                    cerr << "Will add AVU with `attribute' == \"IRODS_OBJECT_REF_PID\" "
                        << "on `curr_irods_object'."
                        << endl;
                   unlock_cerr_mutex(); 

               }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

               base_irods_object_pid = avu_iter->value;

@q ************ (12) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

               curr_avu.clear();
               curr_avu.set("IRODS_OBJECT_REF_PID", 
                            base_irods_object_pid,
                            "",
                            0U,
                            curr_irods_object.id);

               status = curr_irods_object.add_avu(curr_avu, 
                                                  irods_env_filename, 
                                                  true, 
                                                  true,
                                                  true, 
                                                  mysql_ptr, 
                                                  thread_ctr);

               if (status != 0)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                        << endl
                        << "`Irods_Object_Type::add_avu' failed, returning " 
                        << status << "."
                        << endl 
                        << "Failed to add AVU with `attribute' == `IRODS_OBJECT_REF_PID' "
                        << "to `Irods_Object_Type curr_irods_object'."
                        << endl
                        << "Exiting function unsuccessfully with return value 1."
                        << endl;
                   unlock_cerr_mutex(); 

                   temp_strm.str("");

                   temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                             << GW_ERROR << " \"Server error:  "
                             << "Failed to created AVU with attribute "
                             << "\002IRODS_OBJECT_REF_PID\003 "
                             << "for `Irods_Object_Type' object.\"";

                   new_response.command = temp_strm.str();

                   response_deque.push_back(new_response);

                   ++errors_occurred;

                   return 1;

               }  /* |if (status != 0)|  */

@q ************ (12) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
               else if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                        << endl
                        << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                        << endl 
                        << "Added AVU to `Irods_Object_Type curr_irods_object' successfully."
                        << endl;
                   unlock_cerr_mutex(); 

               }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ************ (12) @>

           }  /* |else|  */

@q *********** (11) @>

@q ********** (10) @>

@q ********* (9) Add AVUs on |base_irods_object|.  @>

@ Add AVUs on |base_irods_object|.  
\initials{LDF 2014.01.15.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

@q ********** (10) DETACHED_SIGNATURE_REF @>

@ \.{DETACHED\_SIGNATURE\_REF}.
\initials{LDF 2014.01.15.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

           curr_avu.clear();
           curr_avu.set("DETACHED_SIGNATURE_REF", 
                        curr_irods_object.path,
                        "",
                        0U,
                        base_irods_object.id);

           status = base_irods_object.add_avu(curr_avu, 
                                              irods_env_filename, 
                                              true, 
                                              true,
                                              true, 
                                              mysql_ptr, 
                                              thread_ctr);

           if (status != 0)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                    << endl
                    << "`Irods_Object_Type::add_avu' failed, returning " 
                    << status << "."
                    << endl 
                    << "Failed to add AVU with `attribute' == `DETACHED_SIGNATURE_REF' "
                    << "to `Irods_Object_Type base_irods_object'."
                    << endl
                    << "Exiting function unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               temp_strm.str("");

               temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                         << GW_ERROR << " \"Server error:  "
                         << "Failed to created AVU with attribute "
                         << "\002DETACHED_SIGNATURE_REF\003 "
                         << "for `Irods_Object_Type' object.\"";

               new_response.command = temp_strm.str();

               response_deque.push_back(new_response);

               ++errors_occurred;

               return 1;

           }  /* |if (status != 0)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
           else if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                    << endl
                    << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                    << endl 
                    << "Added AVU to `Irods_Object_Type base_irods_object' successfully."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) DETACHED_SIGNATURE_PID @>

@ \.{DETACHED\_SIGNATURE\_PID}.
\initials{LDF 2014.01.15.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

           curr_avu.clear();
           curr_avu.set("DETACHED_SIGNATURE_PID", 
                        response.pid_str,
                        "",
                        0U,
                        base_irods_object.id);

           status = base_irods_object.add_avu(curr_avu, 
                                              irods_env_filename, 
                                              true, 
                                              true,
                                              true, 
                                              mysql_ptr, 
                                              thread_ctr);

           if (status != 0)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                    << endl
                    << "`Irods_Object_Type::add_avu' failed, returning " 
                    << status << "."
                    << endl 
                    << "Failed to add AVU with `attribute' == `DETACHED_SIGNATURE_PID' "
                    << "to `Irods_Object_Type base_irods_object'."
                    << endl
                    << "Exiting function unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               temp_strm.str("");

               temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                         << GW_ERROR << " \"Server error:  "
                         << "Failed to created AVU with attribute "
                         << "\002DETACHED_SIGNATURE_PID\003 "
                         << "for `Irods_Object_Type' object.\"";

               new_response.command = temp_strm.str();

               response_deque.push_back(new_response);

               ++errors_occurred;

               return 1;

           }  /* |if (status != 0)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
           else if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                    << endl
                    << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                    << endl 
                    << "Added AVU to `Irods_Object_Type base_irods_object' successfully."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) DETACHED_SIGNATURE_GPG_KEY_FINGERPRINT @>

@ \.{DETACHED\_SIGNATURE\_GPG\_KEY\_FINGERPRINT}.
\initials{LDF 2014.01.15.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

           curr_avu.clear();
           curr_avu.set("DETACHED_SIGNATURE_GPG_KEY_FINGERPRINT", 
                        curr_irods_object.gpg_key_fingerprint_sign,
                        "",
                        0U,
                        base_irods_object.id);

           status = base_irods_object.add_avu(curr_avu, 
                                              irods_env_filename, 
                                              true, 
                                              true,
                                              true, 
                                              mysql_ptr, 
                                              thread_ctr);

           if (status != 0)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                    << endl
                    << "`Irods_Object_Type::add_avu' failed, returning " 
                    << status << "."
                    << endl 
                    << "Failed to add AVU with `attribute' == "
                    << "`DETACHED_SIGNATURE_GPG_KEY_FINGERPRINT' "
                    << "to `Irods_Object_Type base_irods_object'."
                    << endl
                    << "Exiting function unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               temp_strm.str("");

               temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                         << GW_ERROR << " \"Server error:  "
                         << "Failed to created AVU with attribute "
                         << "\002DETACHED_SIGNATURE_GPG_KEY_FINGERPRINT\003 "
                         << "for `Irods_Object_Type' object.\"";

               new_response.command = temp_strm.str();

               response_deque.push_back(new_response);

               ++errors_occurred;

               return 1;

           }  /* |if (status != 0)|  */

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
           else if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                    << endl
                    << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                    << endl 
                    << "Added AVU to `Irods_Object_Type base_irods_object' successfully."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

           if (verify)
           {
@q *********** (11) @>

               curr_avu.clear();
               curr_avu.set("VERIFIED", 
                            curr_irods_object.gpg_key_fingerprint_sign,
                            "",
                            0U,
                            base_irods_object.id);

               status = base_irods_object.add_avu(curr_avu, 
                                                  irods_env_filename, 
                                                  true, 
                                                  true,
                                                  true, 
                                                  mysql_ptr, 
                                                  thread_ctr);

               if (status != 0)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                        << endl
                        << "`Irods_Object_Type::add_avu' failed, returning " 
                        << status << "."
                        << endl 
                        << "Failed to add AVU with `attribute' == `VERIFIED' (3) "
                        << "to `Irods_Object_Type base_irods_object'."
                        << endl
                        << "Exiting function unsuccessfully with return value 1."
                        << endl;
                   unlock_cerr_mutex(); 

                   temp_strm.str("");

                   temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                             << GW_ERROR << " \"Server error:  "
                             << "Failed to created AVU with attribute \002VERIFIED\003 "
                             << "for `Irods_Object_Type' object.\"";

                   new_response.command = temp_strm.str();

                   response_deque.push_back(new_response);

                   ++errors_occurred;

                   return 1;

               }  /* |if (status != 0)|  */

@q *********** (11) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
               else if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                        << endl
                        << "`Irods_Object_Type::add_avu' succeeded, returning 0:" 
                        << endl 
                        << "Added AVU to `Irods_Object_Type base_irods_object' successfully."
                        << endl;
                   unlock_cerr_mutex(); 

               }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q *********** (11) @>

           }  /* |if (verify)|  */


@q ********** (10) @>

@q ********* (9) Add handle values to the handle for |curr_irods_object|.  @>

@ Add handle values to the handle for |curr_irods_object|.  
\initials{LDF 2014.01.15.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE
           if (DEBUG)
           {
                lock_cerr_mutex(); 
                handle_vector.back().show("handle_vector.back():");

                cerr << "base_irods_object_pid == " << base_irods_object_pid << endl;

                unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */    

           hvt_vector.clear();

           hvt_vector.push_back(Handle_Value_Triple(Handle_Value_Type::IRODS_OBJECT_REF_INDEX,
                                                    "IRODS_OBJECT_REF",
                                                    base_irods_object.path));


           hvt_vector.push_back(Handle_Value_Triple(Handle_Value_Type::IRODS_OBJECT_REF_PID_INDEX,
                                                    "IRODS_OBJECT_REF_PID",
                                                    base_irods_object_pid));

           hvt_vector.push_back(Handle_Value_Triple(Handle_Value_Type::DETACHED_SIGNATURE_INDEX,
                                                    "DETACHED_SIGNATURE",
                                                    curr_irods_object.gpg_key_fingerprint_sign));

           hvt_vector.push_back(Handle_Value_Triple(Handle_Value_Type::GPG_KEY_FINGERPRINT_INDEX,
                                                    "GPG_KEY_FINGERPRINT",
                                                    curr_irods_object.gpg_key_fingerprint_sign));

           status = handle_vector.back().add_values(mysql_ptr, 
                                                    hvt_vector,
                                                    user_id);

           if (status != 0)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':  "
                    << "`Handle_Type::add_values' failed, returning " << status << "."
                    << endl
                    << "Failed to add handle values."
                    << endl 
                    << "Exiting `Scan_Parse_Parameter_Type::put' "
                    << "unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               temp_strm.str("");

               temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                         << GW_ERROR << " \"Server error:  "
                         << "Failed to add handle values\"";

               new_response.command = temp_strm.str();

               response_deque.push_back(new_response);

               ++errors_occurred;

               return 1;

           }  /* |if (status != 0)|  */

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

           else /* |status == 0|  */
           {
#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':  "
                         << "`Handle_Type::add_values' succeeded, returning 0."
                         << endl;
                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

                temp_strm.str("");

                temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                          << GW_SUCCESS << " \"Added handle values successfully\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

           }  /* |else| (|status == 0|)  */

@q ********* (9) Add handle values to the handle for |base_irods_object|.  @>

@ Add handle values to the handle for |base_irods_object|.  
\initials{LDF 2014.01.15.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

@q ********** (10) @>

#if DEBUG_COMPILE
           if (DEBUG)
           {
                lock_cerr_mutex(); 
                base_irods_object.show("base_irods_object:");
                unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */    

@q ********** (10) @>

           Handle_Type base_handle;

           status = fetch_handle_from_database(base_irods_object.handle_id_vector.back(), 
                                               base_handle);

           if (status != 0)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':  "
                    << "`Scan_Parse_Parameter_Type::fetch_handle_from_database' failed, "
                    << "returning " << status << "."
                    << endl
                    << "Failed to retrieve handle."
                    << endl 
                    << "Exiting `Scan_Parse_Parameter_Type::put' "
                    << "unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               temp_strm.str("");

               temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                         << GW_ERROR << " "
                         << "\"Failed to retrieve handle for base file (iRODS object).\"";

               new_response.command = temp_strm.str();

               response_deque.push_back(new_response);

               ++errors_occurred;

               return 1;

           }  /* |if (status != 0)|  */

@q ********** (10) @>

#if DEBUG_COMPILE
           else if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':  "
                    << "`Scan_Parse_Parameter_Type::fetch_handle_from_database' succeeded, "
                    << "returning 0."
                    << endl;

               base_handle.show("base_handle:");
               unlock_cerr_mutex(); 

           }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

           hvt_vector.clear();

           hvt_vector.push_back(Handle_Value_Triple(
                                   Handle_Value_Type::DETACHED_SIGNATURE_REF_INDEX,
                                   "DETACHED_SIGNATURE_REF",
                                   curr_irods_object.path));


           hvt_vector.push_back(Handle_Value_Triple(
                                   Handle_Value_Type::DETACHED_SIGNATURE_PID_INDEX,
                                   "DETACHED_SIGNATURE_PID",
                                   response.pid_str));


           hvt_vector.push_back(Handle_Value_Triple(
                                   Handle_Value_Type::GPG_KEY_FINGERPRINT_INDEX,
                                   "GPG_KEY_FINGERPRINT",
                                   curr_irods_object.gpg_key_fingerprint_sign));


           if (verify)
              hvt_vector.push_back(Handle_Value_Triple(
                                   Handle_Value_Type::VERIFIED_INDEX,
                                   "VERIFIED",
                                   curr_irods_object.gpg_key_fingerprint_sign));

           status = base_handle.add_values(mysql_ptr, 
                                           hvt_vector,
                                           user_id);

           if (status != 0)
           {
               lock_cerr_mutex(); 
               cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':  "
                    << "`Handle_Type::add_values' failed, returning " << status << "."
                    << endl
                    << "Failed to add handle values."
                    << endl 
                    << "Exiting `Scan_Parse_Parameter_Type::put' "
                    << "unsuccessfully with return value 1."
                    << endl;
               unlock_cerr_mutex(); 

               temp_strm.str("");

               temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                         << GW_ERROR << " \"Server error:  "
                         << "Failed to add handle values\"";

               new_response.command = temp_strm.str();

               response_deque.push_back(new_response);

               ++errors_occurred;

               return 1;

           }  /* |if (status != 0)|  */

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

           else /* |status == 0|  */
           {
#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':  "
                         << "`Handle_Type::add_values' succeeded, returning 0."
                         << endl;
                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

                temp_strm.str("");

                temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                          << GW_SUCCESS << " \"Added handle values successfully\"";

                new_response.command = temp_strm.str();

                response_deque.push_back(new_response);

           }  /* |else| (|status == 0|)  */

@q ********* (9) @>

        }  /* |if (signature)|  */   

@q ******** (8) @>
      
     }  /* |if (irods_object_ctr == 0)|  (|curr_irods_object.get_from_database| returned 0)  */

@q ******* (7) @>

     else if (irods_object_ctr == 1)  /* |curr_irods_object.get_from_database| returned 1  */
     {
@q ******** (8) @>

#if DEBUG_COMPILE
         if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                  << endl
                  << "`Irods_Object_Type::get_from_database' succeeded, returning 1."
                  << endl 
                  << "A row already exists for iRODS object `" << response.local_filename << "' "
                  << "in `Irods_Objects' table."
                  << endl 
                  << "Will modify."
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
 
@q ******** (8) @>

@ The |last_modified| field in the \.{Irods\_Objects} table must be updated.
If a new PID has been generated, an entry must be written in 
|Irods_Objects_Handles|.
\initials{LDF 2013.01.09.}

\LOG
\initials{LDF 2014.02.13.}
@:BUG FIX@> BUG FIX:  Now passing |1U| to |Irods_Object_Type::update| to ensure
that the \.{last\_modified} field is updated.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::put| definition@>=

         status = curr_irods_object.update(mysql_ptr, 1U);

@q ******** (8) @>

         if (status != 0)
         {
            lock_cerr_mutex(); 
            cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                 << endl
                 << "`Irods_Object_Type::update' failed, returning " 
                 << status << "."
                 << endl 
                 << "Failed to update `gwirdsif.Irods_Objects' database table."
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            temp_strm.str("");

            temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                      << "1 \"Server error:  "
                      << "C++ error:  Failed to update `Irods_Objects' database table.\"";

            new_response.command = temp_strm.str();

            response_deque.push_back(new_response);

            ++errors_occurred;

            return 1;


         }  /* |if (status != 0)|  */

@q ******** (8) @>

#if DEBUG_COMPILE
         else if (DEBUG)
         {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Scan_Parse_Parameter_Type::put':"
                 << endl
                 << "`Irods_Object_Type::update' succeeded, returning 0." 
                 << endl;
            unlock_cerr_mutex(); 

         }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ******** (8) @>

     }  /* |else if (irods_object_ctr == 1)|  
           (|curr_irods_object.get_from_database| returned 1)  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

     else if (irods_object_ctr > 1)  
     {
@q ******** (8) @>

            lock_cerr_mutex(); 
            cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                 << endl
                 << "`Irods_Object_Type::get_from_database' returned " << status 
                 << " (> 1)."
                 << endl 
                 << "Multiple rows exists for iRODS object `" << response.local_filename << "' "
                 << "in `Irods_Objects' table."
                 << endl 
                 << "This is currently not allowed.  It may be in the future, if "
                 << "there's a reason to do so."
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            temp_strm.str("");

            temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                      << "1 \"Server error:  "
                      << "Database error:  Multiple rows in `Irods_Objects' table "
                      << "for filename `" << response.local_filename << "'\"";

            new_response.command = temp_strm.str();

            response_deque.push_back(new_response);

            ++errors_occurred;

            return 1;

@q ******** (8) @>

     }  /* |else if (irods_object_ctr > 1)|  */


@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

    else  /* |irods_object_ctr < 0|  */
    {
@q ******** (8) @>

            lock_cerr_mutex(); 
            cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::put':"
                 << endl
                 << "`Irods_Object_Type::get_from_database' failed, returning " << status 
                 << " (< 0)."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            temp_strm.str("");

            temp_strm <<  "PUT RESPONSE \"" << response.local_filename << "\" "
                      << "1 \"Server error:  "
                      << "Database error:  Failed to check `Irods_Objects' database table "
                      << "for filename `" << response.local_filename << "'\"";

            new_response.command = temp_strm.str();

            response_deque.push_back(new_response);

            ++errors_occurred;

            return 1;

@q ******** (8) @>

    }  /* |else| (|irods_object_ctr < 0|)  */


@q ******* (7) @>

@q ****** (6) Clean up.  @>

@ Clean up.  
\initials{LDF 2012.09.27.}

@<|Scan_Parse_Parameter_Type::put| definition@>=

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::put| definition@>=

#if DEBUG_COMPILE 
 if (DEBUG)
 {
     lock_cerr_mutex(); 
     cerr << thread_str << "Exiting `Scan_Parse_Parameter_Type::put' "
          << "successfully with return value 0."
          << endl;
     unlock_cerr_mutex(); 

 }  /* |if (DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */

 return 0;

}  /* End of |Scan_Parse_Parameter_Type::put| definition  */

@q **** (4) get.  @>
@ get.
\initials{LDF 2012.10.02.}

\LOG
\initials{LDF 2012.10.02.}
Added this function.

\initials{LDF 2013.04.04.}
Added arguments |char *buffer_ptr| and |unsigned int buff_size|.  
Made |string flags| and |string client_side_filename| non-optional.  
Now calling this function from |exchange_data_with_client| 
instead of |yyparse|.  Now using |buffer_ptr| to pass back a text response to 
|exchange_data_with_client|.  Currently, this is only done in the case of an 
error.  Otherwise, a response of |type == Response_Type::SEND_FILE_TYPE| is 
pushed onto |response_deque|, as before.
\par
Calling this function from |exchange_data_with_client| ensures that commands 
such as \.{cd}, that can affect the operation of this and other functions,
are performed first.  When functions are called in the parser rules, they are 
executed while operations may be pending because the corresponding responses are 
on |response_deque| waiting to be processed.

\initials{LDF 2014.01.16.}
Removed the arguments |char *buffer_ptr| and |unsigned int buff_size|.
Replaced the arguments |string filename|, |string flags| and |string client_side_filename|
with |Response_Type &response|.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
int
get(Response_Type &response,
    string thread_str = "");

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=
int
Scan_Parse_Parameter_Type::get(Response_Type &response,
                               string thread_str)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG, 0, 0); 

    stringstream temp_strm;

    int status = 0;

    ofstream out_strm;

    size_t pos;

    string client_side_filename = response.remote_filename;

    Response_Type new_response;
    new_response.type = Response_Type::COMMAND_ONLY_TYPE;

    string detached_signature_str;

    FILE *fp = 0;
    char buffer[1024];

    bool detached_signature = false;

    bool verify             = (response.options & 2U)  ? true : false;

    bool decrypt            = (response.options & 4U)  ? true : false;

    bool store_signature    = (response.options & 8U)  ? true : false;

    bool expand             = (response.options & 16U) ? true : false;

#if DEBUG_COMPILE 
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::get'."
             << endl;

        response.show("response:");

        cerr << "`verify'        == " << verify 
             << endl 
             << "decrypt         == " << decrypt 
             << endl
             << "store_signature == " << store_signature  
             << endl
             << "expand          == " << expand
             << endl;

        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */

@q ****** (6) Test |response.flags| for \.{-f} (force) option.  @>

@ Test |response.flags| for \.{-f} (force) option.  If present, set |bool overwrite| to |true|.
@:NOTE@> !! PLEASE NOTE:  This only works if \.{-f} is used separately from other options,
or if it is the first option in a list preceded by a single hyphen.

\LOG
\initials{LDF 2012.11.19.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get| definition@>=

    bool overwrite = false;

    pos = response.flags.find("-f");

    if (pos != string::npos)
    {
#if DEBUG_COMPILE 
         if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                  << endl
                  << "`response.flags' contains `-f' (force) option.  "
                  << "Setting `bool overwrite' to `true' and "
                  << "setting bit 1 in `response.options'."
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */

         overwrite = true;
         response.options |= 1U;

    }  /* |if (pos != string::npos)|  */

    else  /* The temporary file already exists, so the \.{-f} option must be
             used to overwrite it.  This {\it does not\/} affect whether the 
             remote (client-side) file will be overwritten!
             \initials{LDF 2012.11.19.}  */
    {
         response.flags.insert(0, "-f ");  

#if DEBUG_COMPILE
         if (DEBUG)
         {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                 << endl
                 << "`response.flags' does not contain `-f' (force) option.  `bool overwrite' "
                 << "remains set to `false'."
                 << endl
                 << "Using the `-f' option to overwrite the local (server-side) temporary file, "
                 << "but the remote (client-side) file will not be overwritten, if it already "
                 << "exists."
                 << endl;
            unlock_cerr_mutex(); 
         }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    }  /* |else|  */

@q ****** (6) Create temporary file.  @>

@ Create temporary file.  The name will be stored in |new_response.local_filename|.  
\initials{LDF 2012.11.16.}

\LOG
\initials{LDF 2012.11.16.}
Added this section.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::get| definition@>=

    char temp_filename[] = "/tmp/gwirdsif.XXXXXX";

    int fd = mkstemp(temp_filename);

    if (fd == -1)
    {
        lock_cerr_mutex(); 
        cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get':"
             << endl
             << "`mkstemp' failed, returning -1.  Failed to create temporary file."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        ++errors_occurred;

        return 1;

    }  /* |if (fd == -1)|  */

#if DEBUG_COMPILE
    else if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
             << endl
             << "`mkstemp' succeeded.  `temp_filename' == `" << temp_filename << "'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */         

    close(fd);
    fd = 0;

    new_response.local_filename = temp_filename;
    temp_file_vector.push_back(temp_filename);

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

#if DEBUG_COMPILE
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
             << endl
             << "`response.local_filename' == " << response.local_filename
             << endl
             << "`irods_current_dir' == " << irods_current_dir
             << endl
             << "new_response.local_filename == " << new_response.local_filename 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

    pos = response.local_filename.find_last_of("/");

    if (pos == string::npos)  
    {   
@q ******* (7) @>

        /* |response.local_filename| doesn't contain any directories  */

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                 << endl
                 << "`response.local_filename' == " << response.local_filename 
                 << " doesn't contain any directories."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */         

@q ******* (7) @>

    }  /* |if (pos == string::npos)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

    else if (response.local_filename[response.local_filename.size() - 1] == '/')
    {

        lock_cerr_mutex(); 
        cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get':"
             << endl
             << "`response.local_filename' == " << response.local_filename 
             << " is a directory and cannot be ``gotten''."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        temp_strm.str("");
        temp_strm <<  "GET FILE RESPONSE \"" << response.local_filename
                  << "\" " << GW_ERROR << " " << response.options << "U \"Error:  "
                  << "Filename is a directory:  " 
                  << response.local_filename << ".  Can't get.\"";

        new_response.command = temp_strm.str();
        response_deque.push_back(new_response);

        ++errors_occurred;

        return 1;

    }  /* |else if (response.local_filename[response.local_filename.size() - 1] == '/')|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

    if (response.local_filename[0] == '/')
    {
@q ******* (7) @>

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                 << endl
                 << "`response.local_filename' == `" << response.local_filename << "' "
                 << "is an absolute path.  "
                 << endl
                 << "Not inserting `irods_current_dir' == `" << irods_current_dir << "' "
                 << "at the front of it."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

    }  /* |if (response.local_filename[0] == '/')|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

   else /* |response.local_filename[0] != '/'|  */
   {
       response.local_filename.insert(0, "/");
       response.local_filename.insert(0, irods_current_dir);
 
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "After inserting `irods_current_dir':  "
                << "response.local_filename == " << response.local_filename 
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |else| (|response.local_filename[0] != '/'|)  */

@q ****** (6) @>
@ @:TODO@> !! TODO: I could try to implement some way of changing the directory  
on the client-side during the dialogue between client and server.
I'm not sure that this is really practicable (or even possible), though.
\initials{LDF 2013.04.05.}

\LOG
\initials{LDF 2013.04.04.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get| definition@>=

@q ******* (7) @>

    if (response.remote_filename.empty())
    {
@q ******** (8) @>

        response.remote_filename = basename(response.local_filename.c_str());
 
        if (response.remote_filename.empty())
        {

            lock_cerr_mutex(); 
            cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get':"
                 << endl
                 << "`basename' failed, returning the empty string."
                 << endl 
                 << "`response.local_filename' == " << response.local_filename 
                 << " is invalid."
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            temp_strm.str("");
            temp_strm <<  "GET FILE RESPONSE \"" << response.local_filename
                      << "\" " << GW_ERROR << " " << response.options << "U \"Error:  "
                      << "Filename is invalid:  " 
                      << response.local_filename << ".  Can't get.\"";
 
            new_response.command = temp_strm.str();
            response_deque.push_back(new_response);

            ++errors_occurred;

            return 1;

        }  /* |if (response.remote_filename.empty())| (inner) */

@q ******** (8) @>

    }  /* |if (response.remote_filename.empty())| (outer)  */

@q ******* (7) @>

    new_response.remote_filename = response.remote_filename;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "new_response.remote_filename == " << new_response.remote_filename << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

@q ******* (7) @>

   Irods_Object_Type curr_irods_object;
   curr_irods_object.set(user_id, response.local_filename);

   Irods_Object_Type detached_signature_irods_object;

   status = curr_irods_object.get_from_database(mysql_ptr, false, thread_str);

   if (status <= 0)
   {
@q ******** (8) @>

        if (verify == true)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get':"
                 << endl 
                 << "`Irods_Object_Type::get_from_database' failed, returning " << status << ":"
                 << endl
                 << "Failed to retrieve entry for `" << response.local_filename << "' "
                 << "from `gwirdsif.Irods_Objects' database table and `verify' == `true'."
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
             unlock_cerr_mutex(); 

            temp_strm.str("");
            temp_strm <<  "GET FILE RESPONSE \"" << response.local_filename << "\" "
                      << GW_ERROR << " " << response.options << "U "
                      << "\"Failed to retrieve entry for iRODS object from the "
                      << "`gwirdsif.Irods_Object' database table and `verify' "
                      << "option specified.\"";

            if (!response.remote_filename.empty())
            {
               temp_strm << " CLIENT_SIDE_FILENAME "
                         << "\"" << response.remote_filename << "\"";
            }           

            new_response.command = temp_strm.str();
            response_deque.push_back(new_response);
    
            ++errors_occurred;

            return 1;

        }  /* |if (verify == true)|  */

@q ******** (8) @>

        else
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "WARNING!  In `Scan_Parse_Parameter_Type::get':"
                 << endl 
                 << "`Irods_Object_Type::get_from_database' failed, returning " << status << ":"
                 << endl
                 << "Failed to retrieve entry for `" << response.local_filename << "' "
                 << "from `gwirdsif.Irods_Objects' database table."
                 << endl
                 << "If iRODS object exists, it will be sent to the client."
                 << endl
                 << "Continuing." 
                 << endl;
             unlock_cerr_mutex(); 

            temp_strm.str("");
            temp_strm <<  "GET FILE RESPONSE \"" << response.local_filename << "\" "
                      << GW_WARNING << " " << response.options << "U "
                      << "\"Failed to retrieve entry for iRODS object from the "
                      << "`gwirdsif.Irods_Object' database table.\"";

            if (!response.remote_filename.empty())
            {
               temp_strm << " CLIENT_SIDE_FILENAME "
                         << "\"" << response.remote_filename << "\"";
            }           

            new_response.command = temp_strm.str();
            response_deque.push_back(new_response);
    
            ++warnings_occurred; 

        }  /* |else|  */

@q ******** (8) @>

   }  /* |if (status <= 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
            << endl 
            << "`Irods_Object_Type::get_from_database' succeeded, returning " << status << ":"
            << endl
            << "Retrieved entry for `" << response.local_filename << "' "
            << "from `gwirdsif.Irods_Objects' database table successfully."
            << endl;

       curr_irods_object.show("curr_irods_object:");
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   if (curr_irods_object.compressed_tar_file)
      response.options |= 32U;

   if (curr_irods_object.compressed_gzip)
      response.options |= 64U;

   else if (curr_irods_object.compressed_bzip2)
      response.options |= 128U;


@q ******* (7) @>
@
\LOG
\initials{LDF 2014.01.19.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get| definition@>=

   if (decrypt == true && curr_irods_object.encrypted == false)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "WARNING!  In `Scan_Parse_Parameter_Type::get':"
            << endl 
            << "`decrypt' == `true', but `curr_irods_object' does not seem to have been "
            << "encrypted:"
            << endl
            << "`curr_irods_object.encrypted' == " << curr_irods_object.encrypted
            << endl 
            << "Setting `decrypt' to `false' and sending a warning to the client."
            << endl
            << "Continuing."            
            << endl;
        unlock_cerr_mutex(); 

        temp_strm.str("");
        temp_strm <<  "GET FILE RESPONSE \"" << response.local_filename << "\" "
                  << GW_WARNING << " " << response.options << "U "
                  << "\"`decrypt' option specified, but the iRODS object "
                  << "does not seem to have been encrypted.  Not decrypting.\"";

       if (!response.remote_filename.empty())
       {
          temp_strm << " CLIENT_SIDE_FILENAME "
                    << "\"" << response.remote_filename << "\"";
       }           

       new_response.command = temp_strm.str();
       response_deque.push_back(new_response);
    
       ++warnings_occurred;

       decrypt = false;

       response.options &= ~4U;

   }  /* |if|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

   if (verify)
   {
@q ******** (8) @>

       if (    (   curr_irods_object.signed_gpg == false 
                && curr_irods_object.detached_signature_irods_object_id == 0)
           || curr_irods_object.gpg_key_fingerprint_sign.empty())
       {

            lock_cerr_mutex(); 
            cerr << thread_str << "WARNING!  In `Scan_Parse_Parameter_Type::get':"
                 << endl 
                 << "`verify' == `true', but `curr_irods_object' doesn't seem to "
                 << "have been signed:"
                 << endl
                 << "`curr_irods_object.signed_gpg' == " << curr_irods_object.signed_gpg
                 << endl 
                 << "`curr_irods_object.detached_signature_irods_object_id' == " 
                 << curr_irods_object.detached_signature_irods_object_id
                 << endl 
                 << "`curr_irods_object.gpg_key_fingerprint_sign' == " 
                 << curr_irods_object.gpg_key_fingerprint_sign
                 << endl 
                 << "Setting `verify' to `false' and sending a warning to the client."
                 << endl
                 << "Continuing."
                 << endl;
             unlock_cerr_mutex(); 

             temp_strm.str("");
             temp_strm <<  "GET FILE RESPONSE \"" << response.local_filename << "\" "
                       << GW_WARNING << " " << response.options << "U "
                       << "\"`verify' option specified, but the iRODS object "
                       << "does not seem to have been signed.  Not verifying.\"";

            if (!response.remote_filename.empty())
            {
               temp_strm << " CLIENT_SIDE_FILENAME "
                         << "\"" << response.remote_filename << "\"";
            }           

            new_response.command = temp_strm.str();
            response_deque.push_back(new_response);
    
            ++warnings_occurred;

            verify = false;

            response.options &= ~2U;

       }  /* |if|  */

@q ******** (8) @>

       else if (curr_irods_object.detached_signature_irods_object_id > 0)
       {
@q ********* (9) @>

            detached_signature = true;

            detached_signature_irods_object.user_id = user_id;
            detached_signature_irods_object.id 
               = curr_irods_object.detached_signature_irods_object_id;

            status = detached_signature_irods_object.get_from_database(mysql_ptr, 
                                                                       false,     
                                                                       thread_str);

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

            if (status <= 0)
            {
                lock_cerr_mutex(); 
                cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get':"
                     << endl 
                     << "`Irods_Object_Type::get_from_database' failed, returning " 
                     << status << ":"
                     << endl
                     << "Failed to retrieve entry for detached signature file for "
                     << "`" << response.local_filename << "' "
                     << "from `gwirdsif.Irods_Objects' database table."
                     << endl
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;
                 unlock_cerr_mutex(); 

                 temp_strm.str("");
                 temp_strm <<  "GET FILE RESPONSE \"" << response.local_filename << "\" "
                           << GW_ERROR << " " << response.options << "U "
                           << "\"Failed to retrieve entry for detached signature file for "
                           << "iRODS object from the `gwirdsif.Irods_Object' database table.\"";

                 if (!response.remote_filename.empty())
                 {
                    temp_strm << " CLIENT_SIDE_FILENAME "
                              << "\"" << response.remote_filename << "\"";
                 }           

                 new_response.command = temp_strm.str();
                 response_deque.push_back(new_response);
    
                 ++errors_occurred;

                 return 1;

            }  /* |if (status <= 0)|  */

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

            else
            {

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                         << endl 
                         << "`Irods_Object_Type::get_from_database' succeeded, returning " 
                         << status << ":"
                         << endl
                         << "Retrieved entry for detached signature file for "
                         << "`" << response.local_filename << "' "
                         << "from `gwirdsif.Irods_Objects' database table successfully."
                         << endl;

                    detached_signature_irods_object.show("detached_signature_irods_object:");


                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

                temp_strm.str("");
 
                temp_strm << "a=`env irodsEnvFile=" << irods_env_filename 
                          << " iget " << detached_signature_irods_object.path << " - "
                          << "2>/dev/null`;"
                          << "echo $?; echo \"$a\"";

#if DEBUG_COMPILE
                if (DEBUG)   
                {
                    lock_cerr_mutex(); 
                    cerr << "temp_strm.str() == " << temp_strm.str() << endl;
                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

                errno = 0;
                fp = popen(temp_strm.str().c_str(), "r");

                if (fp == 0)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get':"
                         << endl 
                         << "`popen' failed, returning NULL:  " << strerror(errno)
                         << endl
                         << "`iget' failed for detached signature file."
                         << endl 
                         << "Will send failure notice to client."
                         << endl
                         << "Exiting function unsuccessfully with return value 1."
                          << endl;
                    unlock_cerr_mutex(); 
    
                    temp_strm.str("");
                    temp_strm <<  "GET FILE RESPONSE \"" << response.local_filename << "\" "
                              << GW_ERROR << " " << response.options << "U \"Server error:  "
                              << "Failed to retrieve detached signature file "
                              << "`" << detached_signature_irods_object.path << "' "
                              << "from iRODS server\"";

                     if (!response.remote_filename.empty())
                     {
                        temp_strm << " CLIENT_SIDE_FILENAME "
                                  << "\"" << response.remote_filename << "\"";
                     }           

                    new_response.command = temp_strm.str();
                    response_deque.push_back(new_response);
    
                    ++errors_occurred;

                    return 1;
    
                }  /* |if (fp == 0)|  */
    
@q ********** (10) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

                else /* |fp != 0|  */
                {
#if DEBUG_COMPILE
                    if (DEBUG)
                    {
                        lock_cerr_mutex(); 
                        cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                             << "`popen' succeeded."
                             << endl;
                        unlock_cerr_mutex(); 

                    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q *********** (11) @>

                    memset(buffer, 0, 1024);

                    status = fread(buffer, 1, 1023, fp);

                    if (status == 0)
                    {
                            lock_cerr_mutex(); 
                            cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get':"
                                 << "`fread' failed, returning 0.  Failed to read from pipe."
                                 << endl
                                 << "Failed to \"get\" detached signature file.  "
                                 << "Will send failure notice "
                                 << "to client."
                                 << endl 
                                 << "Exiting function unsuccessfully with return value 1."
                                 << endl;
                            unlock_cerr_mutex(); 

                            temp_strm.str("");
                            temp_strm <<  "GET RESPONSE FILE \"" 
                                      << response.local_filename << "\" " << GW_ERROR << " " 
                                      << response.options << "U \"Server error:  "
                                      << "Failed to read output and/or exit status from "
                                      << "`iget' command for detached signature file.\"";

                            if (!response.remote_filename.empty())
                            {
                               temp_strm << " CLIENT_SIDE_FILENAME "
                                         << "\"" << response.remote_filename << "\"";
                            }           

                            new_response.command = temp_strm.str();

                            response_deque.push_back(new_response);

                            pclose(fp);

                            ++errors_occurred;

                            return 1;

                    }  /* |if (status == 0)|  */

@q *********** (11) @>

                    else if (status == 1023)
                    {
                            lock_cerr_mutex(); 
                            cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get':"
                                 << "`fread' returned 1023:  Pipe output exceeds maximum length "
                                 << "(1022 characters)."
                                 << endl
                                 << "`buffer' =="
                                 << endl 
                                 << buffer
                                 << endl 
                                 << "Failed to \"get\" detached signature file.  "
                                 << "Will send failure notice to client."
                                 << endl 
                                 << "Exiting function unsuccessfully with return value 1."
                                 << endl;
                            unlock_cerr_mutex(); 

                            temp_strm.str("");
                            temp_strm <<  "GET FILE RESPONSE \"" 
                                      << response.local_filename << "\" " << GW_ERROR << " " 
                                      << response.options << "U \"Server error:  "
                                      << "Output from `iget' command for detached signature file "
                                      << "exceeds maximum length "
                                      << "(1022 characters).\"";

                            if (!response.remote_filename.empty())
                            {
                               temp_strm << " CLIENT_SIDE_FILENAME "
                                         << "\"" << response.remote_filename << "\"";
                            }

                            new_response.command = temp_strm.str();

                            response_deque.push_back(new_response);

                            pclose(fp);
                         
                            ++errors_occurred;

                            return 1;

                    }  /* |else if (status == 1023)|  */


@q *********** (11) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

                    else  /* |fread| succeeded and read valid number of characters  */
                    {
@q ************ (12) @>

#if DEBUG_COMPILE
                        if (DEBUG)
                        {
                            lock_cerr_mutex(); 
                            cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                                 << "`popen' succeeded."
                                 << endl
                                 << "`buffer' == " << buffer
                                 << endl;
                            unlock_cerr_mutex(); 

                        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ************ (12) @>

                        temp_strm.str("");

                        status = -1;

                        temp_strm << buffer;

                        temp_strm.clear();

                        temp_strm >> status;

                        if (status != 0)
                        {
                                lock_cerr_mutex(); 
                                cerr << thread_str << "ERROR!  "
                                     << "In `Scan_Parse_Parameter_Type::get':"
                                     << "`iget' command, executed in shell, failed, returning "
                                     << status << ":"
                                     << endl
                                     << "Failed to \"get\" detached signature file.  "
                                     << "Will send failure notice to client."
                                     << endl 
                                     << "Exiting function unsuccessfully with return value 1."
                                     << endl;
                                unlock_cerr_mutex(); 

                                temp_strm.str("");
                                temp_strm <<  "GET FILE RESPONSE \"" 
                                          << response.local_filename << "\" " << GW_ERROR << " " 
                                          << response.options << "U \"Server error:  "
                                          << "`iget' command for detached signature file "
                                          << "failed.\"";

                                if (!response.remote_filename.empty())
                                {
                                   temp_strm << " CLIENT_SIDE_FILENAME "
                                             << "\"" << response.remote_filename << "\"";
                                }

                                new_response.command = temp_strm.str();

                                response_deque.push_back(new_response);

                                pclose(fp);
                             
                                ++errors_occurred;

                                return 1;

                        }  /* |else if (status != 0)|  */

@q ************ (12) @>


#if DEBUG_COMPILE
                        else if (DEBUG)      
                        {
                            lock_cerr_mutex(); 
                            cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                                 << "`iget' command, executed in shell, succeeded, returning 0:"
                                 << endl
                                 << "\"get\" succeeded for detached signature file."
                                 << endl
                                 << "`temp_strm.str()' == " << temp_strm.str()
                                 << endl;
                            unlock_cerr_mutex(); 

                        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ************ (12) @>

                        
                        detached_signature_str = temp_strm.str();

                        pos = detached_signature_str.find("\n");

                        if (pos != string::npos)
                           detached_signature_str.erase(0, pos);
                           
                        temp_strm.str("");
                        temp_strm.clear();

#if DEBUG_COMPILE
                        if (DEBUG)      
                        {
                            lock_cerr_mutex(); 
                            cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                                 << "`iget' command, executed in shell, succeeded, returning 0:"
                                 << endl
                                 << "\"get\" succeeded for detached signature file."
                                 << endl
                                 << "`detached_signature_str' == " << detached_signature_str
                                 << endl;
                            unlock_cerr_mutex(); 

                        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
                       


@q ************ (12) @>
                    
                    }  /* |else|  */

@q *********** (11) @>

                    pclose(fp);
                    fp = 0;

@q *********** (11) @>


                }  /* |else| (|fp != 0|)  */

                
 

@q ********** (10) @>

            }  /* |else|  */

@q ********* (9) @>

       }  /* |else if|  */

@q ******** (8) @>

   }  /* |if (verify)|  */


@q ******* (7) @>
@
\LOG
\initials{LDF 2014.01.24.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get| definition@>=

   if (expand)
   {
@q ******** (8) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                << endl 
                << "`expand' == `true'."
                << endl;

           curr_irods_object.show("curr_irods_object:");

           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

       if (!(   curr_irods_object.compressed_tar_file 
             || curr_irods_object.compressed_gzip
             || curr_irods_object.compressed_bzip2))
       {
           lock_cerr_mutex(); 
           cerr << thread_str << "WARNING!  In `Scan_Parse_Parameter_Type::get':"
                << endl 
                << "`expand' == `true', but `curr_irods_object' does not seem to have been "
                << "compressed:"
                << endl
                << "`curr_irods_object.compressed_tar_file' == " 
                << curr_irods_object.compressed_tar_file 
                << endl
                << "`curr_irods_object.compressed_gzip' == " 
                << curr_irods_object.compressed_gzip 
                << endl
                << "`curr_irods_object.compressed_bzip2' == " 
                << curr_irods_object.compressed_bzip2 
                << endl 
                << "Setting `expand' to `false' and sending a warning to the client."
                << endl
                << "Continuing."            
                << endl;
            unlock_cerr_mutex(); 

            temp_strm.str("");
            temp_strm <<  "GET FILE RESPONSE \"" << response.local_filename << "\" "
                      << GW_WARNING << " " << response.options << "U "
                      << "\"`expand' option specified, but the iRODS object "
                      << "does not seem to have been compressed."
                      << endl 
                      << "Not expanding.\"";

           if (!response.remote_filename.empty())
           {
              temp_strm << " CLIENT_SIDE_FILENAME "
                        << "\"" << response.remote_filename << "\"";
           }           

           new_response.command = temp_strm.str();
           response_deque.push_back(new_response);
    
           ++warnings_occurred;

           expand = false;

           response.options &= ~16U;

       }  /* |if|  */
 
@q ******** (8) @>

   }  /* |if (expand)|  */

@q ******* (7) @>

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

    temp_strm.str("");

    temp_strm << "env irodsEnvFile=" << irods_env_filename 
              << " iget " << response.flags << " " << response.local_filename << " " 
              << new_response.local_filename << " 2>&1; echo $?";

#if DEBUG_COMPILE
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "temp_strm.str() == " << temp_strm.str() << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

    errno = 0;
    fp = popen(temp_strm.str().c_str(), "r");
    
    if (fp == 0)
    {
        lock_cerr_mutex(); 
        cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get':"
             << endl 
             << "`popen' failed, returning NULL:  " << strerror(errno)
             << endl
             << "Can't \"get\" file.  Will send failure notice to client."
             << endl
             << "Exiting function unsuccessfully with return value 1."
              << endl;
        unlock_cerr_mutex(); 
    
        temp_strm.str("");
        temp_strm <<  "GET FILE RESPONSE \"" << response.local_filename << "\" "
                  << GW_ERROR << " " << response.options << "U \"Server error:  "
                  << "Failed to retrieve file `" << response.local_filename << "' "
                  << "from iRODS server\"";

        if (!response.remote_filename.empty())
        {
           temp_strm << " CLIENT_SIDE_FILENAME "
                     << "\"" << response.remote_filename << "\"";
        }           
    
        new_response.command = temp_strm.str();
        response_deque.push_back(new_response);
    
        ++errors_occurred;

        return 1;
    
    }  /* |if (fp == 0)|  */
    
@q ****** (6) @>
    
    else /* |fp != 0|  */
    {
@q ******* (7) @>

#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                         << "`popen' succeeded."
                         << endl;
                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

                memset(buffer, 0, 1024);

                status = fread(buffer, 1, 1024, fp);

                if (status == 0)
                {
                        lock_cerr_mutex(); 
                        cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get':"
                             << "`fread' failed, returning 0.  Failed to read from pipe."
                             << endl
                             << "Failed to \"get\" file.  Will send failure notice "
                             << "to client."
                             << endl 
                             << "Exiting function unsuccessfully with return value 1."
                             << endl;
                        unlock_cerr_mutex(); 

                        temp_strm.str("");
                        temp_strm <<  "GET RESPONSE FILE \"" 
                                  << response.local_filename << "\" " << GW_ERROR << " " 
                                  << response.options << "U \"Server error:  "
                                  << "Failed to read output and/or exit status from "
                                  << "`iget' command.\"";

                        if (!response.remote_filename.empty())
                        {
                           temp_strm << " CLIENT_SIDE_FILENAME "
                                     << "\"" << response.remote_filename << "\"";
                        }           

                        new_response.command = temp_strm.str();

                        response_deque.push_back(new_response);

                        pclose(fp);

                        ++errors_occurred;

                        return 1;

                }  /* |if (status == 0)|  */

@q ******* (7) @>

                else if (status == 1024)
                {
                        lock_cerr_mutex(); 
                        cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get':"
                             << "`fread' returned 1024:  Pipe output exceeds maximum length."
                             << endl
                             << "Failed to \"get\" file.  "
                             << "Will send failure notice to client."
                             << endl 
                             << "Exiting function unsuccessfully with return value 1."
                             << endl;
                        unlock_cerr_mutex(); 

                        temp_strm.str("");
                        temp_strm <<  "GET FILE RESPONSE \"" 
                                  << response.local_filename << "\" " << GW_ERROR << " " 
                                  << response.options << "U \"Server error:  "
                                  << "Output from `iget' command exceeds maximum length "
                                  << "(1023 characters).\"";

                        if (!response.remote_filename.empty())
                        {
                           temp_strm << " CLIENT_SIDE_FILENAME "
                                     << "\"" << response.remote_filename << "\"";
                        }

                        new_response.command = temp_strm.str();

                        response_deque.push_back(new_response);

                        pclose(fp);
                         
                        ++errors_occurred;

                        return 1;


                }  /* |else if (status == 1024)|  */

@q ******* (7) @>

                else  /* |fread| succeeded and read valid number of characters  */
                {
@q ******** (8) @>

#if DEBUG_COMPILE
                    if (DEBUG)
                    {
                        lock_cerr_mutex(); 
                        cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                             << "`popen' succeeded."
                             << endl
                             << "`buffer' == " << buffer
                             << endl;
                        unlock_cerr_mutex(); 

                    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

                    /* Get the return value of \.{iget} command.  */

                    char *ret_val_ptr = buffer + strlen(buffer) - 1;

#if DEBUG_COMPILE
                    if (DEBUG)       
                    {
                        lock_cerr_mutex(); 
                        cerr << "ret_val_ptr == " << ret_val_ptr << endl;
                        unlock_cerr_mutex(); 

                    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

                    --ret_val_ptr;

                    while (isdigit(ret_val_ptr[0]))
                       --ret_val_ptr;

                    if (!(ret_val_ptr[0] == '-' || ret_val_ptr[0] == '+'))
                       ++ret_val_ptr;

                    int ret_val;

                    sscanf(ret_val_ptr, "%d", &ret_val);

                    ret_val_ptr[0] = '\0';  /* Remove exit status from end of |buffer|  */



#if DEBUG_COMPILE
                    if (DEBUG)
                    {
                        lock_cerr_mutex(); 
                        cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                             << endl 
                             << "ret_val_ptr == " << ret_val_ptr 
                             << endl
                             << "ret_val == " << ret_val 
                             << endl
                             << "`buffer' == " << buffer
                             << endl;
                        unlock_cerr_mutex(); 

                    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=
                   
                    if (ret_val == 0)
                    {
@q ********* (9) @>

#if DEBUG_COMPILE
                        if (DEBUG)             
                        {
                            lock_cerr_mutex(); 
                            cerr << thread_str << "In `Scan_Parse_Parameter_Type::get':"
                                 << "`iget' succeeded."
                                 << endl;
                            unlock_cerr_mutex(); 

                        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */                           

@q ********* (9) @>

                        pclose(fp);
                        fp = 0;

                        temp_strm.str("");
                        temp_strm << "GET FILE RESPONSE \"" << response.local_filename << "\" "
                                  << GW_SUCCESS << " " << response.options << "U \"" 
                                  << "`iget' command succeeded, returning 0";


                        if (strlen(buffer) > 0)
                           temp_strm << ":  " << buffer;
                        else
                           temp_strm << ".";

                        temp_strm  << "\"";

                        if (!response.remote_filename.empty())
                        {
                           temp_strm << " CLIENT_SIDE_FILENAME "
                                     << "\"" << response.remote_filename << "\"";
                        }


@q ********* (9) @>
@
\LOG
\initials{LDF 2014.01.16.}
Added this section.
\ENDLOG
@<|Scan_Parse_Parameter_Type::get| definition@>=

                        if (verify)
                        {
@q ********** (10) @>

                           temp_strm << " GPG_KEY_FINGERPRINT "
                                     << "\"" << curr_irods_object.gpg_key_fingerprint_sign << "\"";

                            if (detached_signature)
                            {
                               temp_strm << " DETACHED SIGNATURE " 
                                         << "\"" << detached_signature_str << "\"";
                            }

@q ********** (10) @>

                        } /* |if (verify)|  */

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

                        new_response.command = temp_strm.str();

                        new_response.type = Response_Type::SEND_FILE_TYPE;

                        response_deque.push_back(new_response);

                        temp_strm.str("");

@q ********* (9) @>


                    }  /* |if (ret_val == 0)|  */

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::get| definition@>=

                    else /* |ret_val != 0|  */
                    {

                         lock_cerr_mutex(); 
                         cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get':"
                              << "`iget' failed, returning " << ret_val << ":"
                              << endl
                              << "`buffer' == " << buffer
                              << endl
                              << "Will send failure message to client."
                              << endl 
                              << "Exiting function unsuccessfully with return value 1."
                              << endl;
                         unlock_cerr_mutex(); 

                         temp_strm.str("");

                         temp_strm <<  "GET FILE RESPONSE \"" 
                                   << response.local_filename << "\" " << GW_ERROR << " " 
                                   << response.options << "U \"Server error:  "
                                   << "`iget' command failed, returning " << ret_val << ":  "
                                   << buffer << "\"";

                        if (!response.remote_filename.empty())
                           temp_strm << " CLIENT_SIDE_FILENAME "
                                     << "\"" << response.remote_filename << "\"";


                         pclose(fp);

                         new_response.command = temp_strm.str();
                         response_deque.push_back(new_response);

                         ++errors_occurred;

                         return 1;


                    }  /* |else| (|ret_val != 0|)  */

@q ******** (8) @>

                }  /* |else|.  |fread| succeeded and read valid number of characters  */

@q ******* (7) @>

    }  /* |else| (|fp != 0|).  |popen| succeeded  */

@q ****** (6) Exit.  @>

@ Exit.
\initials{LDF 2012.10.02.}

@<|Scan_Parse_Parameter_Type::get| definition@>=

#if DEBUG_COMPILE 
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_str << "Exiting `Scan_Parse_Parameter_Type::get' "
             << "successfully with return value 0."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */

    return 0;

}  /* End of |Scan_Parse_Parameter_Type::get| definition  */

@q ***** (5) @>

@q **** (4) Send to peer.  @>
@ Send to peer.
\initials{LDF 2012.10.02.}

@q ***** (5) Main version.  @>
@ Main version.
\initials{LDF 2012.10.02.}

\LOG
\initials{LDF 2012.10.02.}
Added this function.

\initials{LDF 2012.11.20.}
Changed so that |*buffer_ptr| and the contents of |filename| can both be sent to 
the peer in a single call to this function.
\ENDLOG

@q ****** (6) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
int
send_to_peer(char **buffer_ptr, unsigned int char_ctr = 0, string filename = "");

@q ****** (6) Definition  @>
@
@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

int
Scan_Parse_Parameter_Type::send_to_peer(char **buffer_ptr, 
                                        unsigned int char_ctr, 
                                        string filename)
{
@q ******* (7) @>

     bool DEBUG = false;  /* |true|  */
     set_debug_level(DEBUG, 0, 0);

     stringstream temp_strm;

     int status = 0;

     string send_func_str = (remote_connection == true) ? "`gnutls_record_send'" : "`send'";


#if DEBUG_COMPILE 
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] Entering "
              << "`Scan_Parse_Parameter_Type::send_to_peer'."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

    if (buffer_ptr == 0 && char_ctr != 1 && filename.empty())
    {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] WARNING!  "
              << "In `Scan_Parse_Parameter_Type::send_to_peer':"
              << endl 
              << "`buffer_ptr' == 0, `char_ctr' == " << char_ctr << " (<> 1) "
              << "and `filename' is empty."
              << endl
              << "Nothing to send to peer."
              << endl
              << "Exiting function unsuccessfully with return value 2."
              << endl;
         unlock_cerr_mutex(); 
        
         ++errors_occurred;

         return 2;

    }  /* |if (buffer_ptr == 0 && filename.empty())|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

    else if (buffer_ptr == 0 && char_ctr == 1 && filename.empty())
    {

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::send_to_peer':"
                 << endl 
                 << "`buffer_ptr' == 0, `char_ctr' == 1 and `filename' is empty."
                 << endl
                 << "Sending single NULL byte to peer."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    }  /* |else if (buffer_ptr == 0 && char_ctr == 1 && filename.empty())|  */


@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

    if (buffer_ptr != 0)
    {

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::send_to_peer':"
                 << endl 
                 << "`buffer_ptr' != 0, `char_ctr' == " << char_ctr << "."
                 << endl
                 << "Sending all or part of `*buffer_ptr' to peer."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    }  /* |if (buffer_ptr != 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

    if (!filename.empty())
    {

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::send_to_peer':"
                 << endl 
                 << "`char_ctr' == " << char_ctr << " and `filename' "
                 << "is non-empty."
                 << endl
                 << "Sending all or part of file `" << filename << "' to peer."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    }  /* |if (filename.empty())|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);

    if (buffer_ptr == 0 && filename.empty() && char_ctr == 1)
    {
@q ******** (8) @>

        if (remote_connection == true)
        {
            status = gnutls_record_send (session, buffer, 1);
        }
        else
        {
            status = send(sock, buffer, 1, 0);     
        }

        if (status == -1) 
        {

            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr
                 << "] ERROR!  In `Scan_Parse_Parameter_Type::send_to_peer':  "
                 << send_func_str << " failed, returning -1." << endl;

            if (remote_connection == true)
                cerr << "Error:  " << gnutls_strerror(status) << endl;
            else 
                cerr << "Error:  " << strerror(errno) << endl;

            cerr << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            close(sock);
            sock = 0;

            ++errors_occurred;

            return 1;      

        }   /* |if (status == -1)|  */

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr
                 << "] In `Scan_Parse_Parameter_Type::send_to_peer':  "
                 << send_func_str << " succeeded, returning " << status << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

    }  /* |if (buffer_ptr == 0 && filename.empty() && char_ctr == 1)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

    if (buffer_ptr != 0 && strlen(*buffer_ptr) < BUFFER_SIZE)
    {
@q ******** (8) @>

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr
                 << "] In `Scan_Parse_Parameter_Type::send_to_peer':  "
                 << "`buffer_ptr' != 0 && `strlen(*buffer_ptr)' < `BUFFER_SIZE'."
                 << endl 
                 << "`strlen(*buffer_ptr)' == " << strlen(*buffer_ptr)
                 << endl
                 << "`BUFFER_SIZE' == " << BUFFER_SIZE
                 << endl 
                 << "`char_ctr' == " << char_ctr << ".  "
                 << endl;

            if (char_ctr == 0 || char_ctr >= strlen(*buffer_ptr))
                cerr << "Will send entire contents of `*buffer_ptr' to peer."
                     << endl;
            else
                cerr << "Will send the first " << char_ctr << " characters "
                     << "of `*buffer_ptr' to peer."
                     << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

@ @:BUG FIX@> BUG FIX:  If |*buffer_ptr| is empty, now setting |char_ctr| to 1, so that at
least one byte will be sent to the peer.  Previously, |char_ctr| was set 
to |strlen(*buffer_ptr) == 0|, so that 0 bytes were ``sent'',
which caused the peer to block.  Of course, |*buffer_ptr| should 
normally never be empty in this case, but it can happen by mistake.
\initials{LDF 2012.11.21.}

@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=


        if (char_ctr == 0 || char_ctr > strlen(*buffer_ptr))
           char_ctr = strlen(*buffer_ptr);

        if (strlen(*buffer_ptr) == 0)
            char_ctr = 1;

        if (remote_connection == true)
        {
            status = gnutls_record_send (session, *buffer_ptr, char_ctr);
        }
        else
        {
            status = send(sock, *buffer_ptr, char_ctr, 0);         
        }

        if (status < 0)
        {
             lock_cerr_mutex(); 
             cerr << "[Thread " << thread_ctr
                  << "] ERROR!  In `Scan_Parse_Parameter_Type::send_to_peer':  "
                  << send_func_str << " failed, returning " << status << "."
                  << endl;

             if (remote_connection == true)
                 cerr << "Error:  " << gnutls_strerror(status) << endl;
             else 
                 cerr << "Error:  " << strerror(errno) << endl;

             cerr << "Exiting function unsuccessfully with return value 1."
                  << endl;
             unlock_cerr_mutex(); 

             close(sock);
             sock = 0;

             ++errors_occurred;

             return 1;

        }  /* |if (status == -1)|  */

        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr 
                 << "]  In `Scan_Parse_Parameter_Type::send_to_peer':  "
                 << send_func_str << " succeeded, returning " << status << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */ 

@q ******** (8) @>

    }  /* |if (buffer_ptr != 0 && strlen(*buffer_ptr) < BUFFER_SIZE)|  */

@q ******* (7) @>

@ @:TODO@> !! TODO: \initials{LDF 2012.11.20.}  Account for cases |*buffer_ptr| is larger
than |BUFFER_SIZE|.  Must send contents in loop.  After loop,
must make sure that number of characters send is not |BUFFER_SIZE|, as above, so 
peer won't block.

Normally, this case should never occur, because the bytes to be transferred would have 
been stored in a file.
\initials{LDF 2013.06.06.}

@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

    else if (buffer_ptr != 0)
    {
         lock_cerr_mutex(); 

         cerr << "[Thread " << thread_ctr
              << "] WARNING!  In `Scan_Parse_Parameter_Type::send_to_peer':"
              << endl 
              << "This case hasn't been accounted for:"
              << "`*buffer_ptr' != 0 && `strlen(*buffer_ptr)' >= `BUFFER_SIZE'"
              << endl
              << "`strlen(*buffer_ptr)' == " << strlen(*buffer_ptr)
              << endl 
              << "`BUFFER_SIZE' == " << BUFFER_SIZE
              << endl
              << "Exiting function unsuccessfully with return value 3."
              << endl;
         unlock_cerr_mutex(); 

         ++errors_occurred;

         return 3;


    }  /* |else if (buffer_ptr != 0)|  */


@q ******* (7) Send file |filename| to peer.  @>
@ Send file |filename| to peer.  
\initials{LDF 2012.11.16.}

\LOG
\initials{LDF 2012.11.16.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

    if (!filename.empty())
    {
@q ******** (8) @>

#if DEBUG_COMPILE
         if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "[Thread " << thread_ctr
                   << "] In `Scan_Parse_Parameter_Type::send_to_peer':  "
                   << "`filename' == " << filename << ".  Will send file contents to peer."
                   << endl;
              unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

         errno = 0;
         FILE *fp = fopen(filename.c_str(), "r");

         if (fp == 0)
         {
              lock_cerr_mutex(); 
              cerr << "[Thread " << thread_ctr
                   << "] ERROR!  In `Scan_Parse_Parameter_Type::send_to_peer':  "
                   << "`fopen' failed, returning NULL:" << endl
                   << strerror(errno)
                   << endl 
                   << "Failed to open file `" << filename << "'."
                   << endl 
                   << "Exiting function unsuccessfully with return value 1."
                   << endl;
              unlock_cerr_mutex(); 

              ++errors_occurred;

              return 1;      

         }  /* |if (fp == 0)|  */

@q ******** (8) @>

#if DEBUG_COMPILE
         else if (DEBUG)
         {
             lock_cerr_mutex(); 
              cerr << "[Thread " << thread_ctr
                   << "] In `Scan_Parse_Parameter_Type::send_to_peer':  "
                   << "`fopen' succeeded.  Opened file `" << filename << "' successfully."
                   << endl;
             unlock_cerr_mutex(); 

         }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
         
@q ******** (8) @>
   
         for (;;)
         {
@q ********* (9) @>

                memset(buffer, 0, BUFFER_SIZE);
                char_ctr = fread(buffer, 1, BUFFER_SIZE, fp);

#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << "[Thread " << thread_ctr
                         << "] In `Scan_Parse_Parameter_Type::send_to_peer':"
                         << endl
                         << "`char_ctr' == " << char_ctr << "."
                         << endl;
                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ********* (9) @>

                if (char_ctr == 0)
                {

                    break;

                }  /* |if (char_ctr == 0)|  */
                
@q ********* (9) @>

               if (remote_connection == true)
               {
                   status = gnutls_record_send (session, buffer, char_ctr);
               }

@q ********* (9) Local connection using Unix domain socket.  @>

@ Local connection using Unix domain socket.  
\initials{LDF Date unknown.}

@:Kludge@> !! KLUDGE:  Calling |sleep| to allow server and client to synchronize.
Currently sleeping for 1 second.  Problems may occur if this isn't long enough.
If the program calling this function doesn't sleep briefly when UNIX domain sockets
are being used, then the call to |recv| on the side of the peer may fail to receive
the bytes sent by the |send| function and block waiting for bytes.  This problem 
does not occur when using Inet sockets with the GNUTLS functions, which should be 
the normal usage.
\par
@:TODO@> !! TODO:  Look up how |send| and |recv| work.  I don't think |recv|
should be blocking.
\initials{LDF 2012.11.19.}

@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

               else
               {
#if DEBUG_COMPILE
                  if (DEBUG)     
                  {
                      lock_cerr_mutex(); 
                      cerr << "[Thread " << thread_ctr
                           << "] In `Scan_Parse_Parameter_Type::send_to_peer':"
                           << "`remote_connection' == `false'.  Using a UNIX domain socket."
                           << endl 
                           << "Going to sleep for 1/2 second in order to synchronize with client."
                           << endl
                           << "If this isn't done, the call to `recv' on the client-side "
                           << "may fail to receive the bytes sent and block."
                           << endl;
                      unlock_cerr_mutex(); 

                  }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


                   struct timespec t;
                   t.tv_sec = 0;
                   t.tv_nsec = 1000000000 / 2;  /* sleep for .5 seconds  */

                   nanosleep(&t, 0);   

                   status = send(sock, buffer, char_ctr, 0);         
               }

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

               if (status < 0)
               {
                    lock_cerr_mutex(); 
                    cerr << "[Thread " << thread_ctr
                         << "] ERROR!  In `Scan_Parse_Parameter_Type::send_to_peer':  "
                         << send_func_str << " failed, returning " << status << "."
                         << endl;

                    if (remote_connection == true)
                        cerr << "Error:  " << gnutls_strerror(status) << endl;
                    else 
                        cerr << "Error:  " << strerror(errno) << endl;

                    cerr << "Exiting function unsuccessfully with return value 1."
                         << endl;
                    unlock_cerr_mutex(); 

                    close(sock);
                    sock = 0;

                    ++errors_occurred;

                    return 1;

               }  /* |if (status == -1)|  */

@q ********* (9) @>

               else if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr 
                        << "]  In `Scan_Parse_Parameter_Type::send_to_peer':  "
                        << send_func_str << " succeeded, returning " << status << "."
                        << endl;
                   unlock_cerr_mutex(); 

               }  /* |else if (DEBUG)|  */ 

@q ********* (9) @>

         }  /* |for|  */

@q ******** (8) @>

         fclose(fp);
         fp = 0;

@q ******** (8) @>

@ If |send| sent exactly |BUFFER_SIZE| bytes on the final iteration of the loop above, 
then we send a single NULL byte, so the client won't block.
\initials{LDF 2012.07.27.} 
\initials{LDF 2012.12.13.}

@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

         if (status == BUFFER_SIZE)  
         {

#if DEBUG_COMPILE
               if (DEBUG)
               {
                   lock_cerr_mutex();
                   cerr << "[Thread " << thread_ctr
                        << "] In `Scan_Parse_Parameter_Type::send_to_peer':  "
                        << send_func_str << " sent exactly `BUFFER_SIZE' bytes."
                        << endl 
                        << "Sending a single NULL byte, so the client won't block, waiting "
                        << "for more bytes."
                        << endl; 
                   unlock_cerr_mutex(); 

               }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

               memset(buffer, 0, BUFFER_SIZE);

               if (remote_connection == true)
               {
                   status = gnutls_record_send (session, buffer, 1);
               }
               else
               {
                   status = send(sock, buffer, 1, 0);     
               }

               if (status == -1) 
               {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr
                        << "] ERROR!  In `Scan_Parse_Parameter_Type::send_to_peer':  "
                        << send_func_str << " failed, returning -1." << endl;

                   if (remote_connection == true)
                       cerr << "Error:  " << gnutls_strerror(status) << endl;
                   else 
                       cerr << "Error:  " << strerror(errno) << endl;

                   cerr << "Exiting function unsuccessfully with return value 1."
                        << endl;
                   unlock_cerr_mutex(); 

                   close(sock);
                   sock = 0;

                   ++errors_occurred;

                   return 1;      

               }   /* |if (status == -1)|  */

#if DEBUG_COMPILE
               else if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr
                        << "] In `Scan_Parse_Parameter_Type::send_to_peer':  "
                        << send_func_str << " succeeded, returning " << status << "."
                        << endl;
                   unlock_cerr_mutex(); 

               }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

         }  /* |if (status == BUFFER_SIZE)|  */

@q ******** (8) @>

    }  /*  |if (!filename.empty())|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

#if DEBUG_COMPILE 
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "] "
             << "Exiting `Scan_Parse_Parameter_Type::send_to_peer' "
             << "successfully with return value 0."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */

    return 0;

}  /* |Scan_Parse_Parameter_Type::send_to_peer|  */

@q ****** (6) @>

@q ***** (5) Version with |const Response_Type&| argument.  @>
@ Version with |const Response_Type&| argument.
\initials{LDF 2012.11.22.}

\LOG
\initials{LDF 2012.11.22.}
Added this function.

\initials{LDF 2012.12.13.}
@:BUG FIX@> BUG FIX:  Now checking whether |send| or |gnutls_record_send| sent
|BUFFER_SIZE| longer correct, because when |Scan_Parse_Parameter_Type::receive_file| 
or any other function tries to read in a loop, it reads |BUFFER_SIZE| bytes at a time, 
not |BUFFER_SIZE - 1| bytes.  |BUFFER_SIZE - 1| is only used when calling |recv| 
or |gnutls_record_recv| a single time, i.e., not in a loop, so it won't block, unless 
there are no bytes to receive at all.  Using |BUFFER_SIZE - 1| ensures that there will be
a NULL byte at the end of the buffer, so that it can be used as a C string (assuming it's 
been set to NULL before the call to |recv| or |gnutls_record_recv|).
\ENDLOG

@q ****** (6) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
int
send_to_peer(const Response_Type &response);


@q ****** (6) Definition  @>
@
@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>=

int
Scan_Parse_Parameter_Type::send_to_peer(const Response_Type &response)
{
    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);

    char *buff_ptr = buffer;

    if (!response.command.empty())
       strcpy(buffer, response.command.c_str());
       
    return send_to_peer(&buff_ptr, 0, response.local_filename);

}  /* End of 
      |Scan_Parse_Parameter_Type::send_to_peer(const Response_Type &response)| definition  */

@q ***** (5) @>

@q **** (4) Receive file.  @>
@ Receive file.
\initials{LDF 2012.09.27.}

The automatic variable |bool gen_temp_file| is initialized to |false| and set to
|true| if the |string| arguments |remote_filename| and |local_filename| are both
empty.  This makes it possible to have the file contents written to a temporary
file.  If |temp_filename_ptr| is non-null, the name of the temporary is stored
in |*temp_filename_ptr|, so that it can be made available to the caller.
\initials{LDF 2012.11.22.}


\vskip\baselineskip
\halign{#:\quad&#\hfil\cr
%
{\bf Return values}\span\cr
\noalign{\vskip.5\baselineskip}
%%0&\cr
%
0&Success\cr
%
1&|access| error for local filename\cr
%
2&Local file already exists and |overwrite == false|\cr
%
3&|mkdir| error\cr
%
4&|access| error for local path\cr
%
5&|ofstream::open| error for local file\cr
%
}


\LOG
\initials{LDF 2012.09.27.}
Added this function.

\initials{LDF 2012.11.19.}
Added arguments.

\initials{LDF 2012.11.22.}
Added automatic variable |bool gen_temp_file = false|.  See 
{\TeX} text above for explanation.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
int
receive_file(string remote_filename = "", 
             string local_filename = "", 
             bool overwrite = false,
             string *new_local_filename_ptr = 0,
             string *temp_filename_ptr = 0);

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

int
Scan_Parse_Parameter_Type::receive_file(string remote_filename, 
                                        string local_filename, 
                                        bool overwrite,
                                        string *new_local_filename_ptr,
                                        string *temp_filename_ptr)
{
@q ****** (6) @>

     bool DEBUG = false;  /* |true|  */
     set_debug_level(DEBUG, 0, 0); 

     int status = 0;
 
     int err_ret_val = 0;

     bool discard = false;

     bool gen_temp_file = false;

     ofstream out_strm;
     size_t pos;
     string local_path;
     string temp_path;

     string temp_str;

     deque<string> dir_list;

     char temp_filename[21];

     if (is_gwirdcli)
        strcpy(temp_filename, "/tmp/gwirdcli.XXXXXX");
     else
        strcpy(temp_filename, "/tmp/gwirdsif.XXXXXX");

     int fd;

     string save_local_filename;

     char *pwd_str;

#if DEBUG_COMPILE 
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] Entering "
              << "`Scan_Parse_Parameter_Type::receive_file'."
              << endl
              << "`remote_filename' == " << remote_filename
              << endl 
              << "`local_filename' == " << local_filename
              << endl 
              << "`overwrite' == " << overwrite
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */

     if (new_local_filename_ptr != 0)
         *new_local_filename_ptr = "";

@q ****** (6) @>
@
\LOG
\initials{LDF 2012.11.22.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

     if (local_filename.empty() && remote_filename.empty())
     {
          gen_temp_file = true;
          goto RECEIVE_FILE_CONTENTS;
     }


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

     else if (local_filename.empty())
     {
#if DEBUG_COMPILE
         if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "`local_filename' is empty.  Setting to `remote_filename' == "
                  << remote_filename << "."
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

         local_filename = remote_filename;

     }  /* |else if (local_filename.empty())|  */

@q ****** (6) @>

@ If |local_filename| is a path ending in a directory, i.e., 
if it ends with a slash, append the filename part of |remote_filename|
to it.  That is, if |remote_filename| is a path containing directories, 
only append the actual filename without the directories to |local_filename|.
\initials{LDF 2012.11.20.}

\LOG
\initials{LDF 2012.11.20.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::receive_file| definition@>=
 
    else if (local_filename[local_filename.size() - 1] == '/')
    {

          pos = remote_filename.find_last_of("/");

          if (pos != string::npos)
          {

#if 0 
              cerr << "temp_str == " << temp_str << endl;
#endif 


              temp_str = remote_filename.substr(pos + 1);
              local_filename += temp_str;

          }  /* |if (pos != string::npos)|  */
 
          else
            local_filename += remote_filename;

#if 0 
         cerr << "remote_filename == " << remote_filename << endl
              << "local_filename == " << local_filename << endl;
#endif 

    }  /* |else if (local_filename[local_filename.size() - 1] == '/')|  */


@q ****** (6) If |overwrite == false|, check |local_filename|.  @>

@ If |overwrite == false|, check |local_filename|.  If the file already exists,
issue an error message and write file contents to a temporary file in \filename{/tmp/}.
If the latter can't be opened for some reason, the file contents are discarded.
\par  
@:NOTE@> !! PLEASE NOTE:  This function cannot just exit, because the file contents 
must be handled somehow.  Otherwise, they will be read when the scanner tries to read
input again, which will cause an error.
\initials{LDF 2012.11.19.}

\LOG
\initials{LDF 2012.11.19.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

   save_local_filename = local_filename;

   pwd_str = getenv("PWD");
    
   if (pwd_str)
   {
      local_filename.insert(0, "/");
      local_filename.insert(0, pwd_str);
   }

#if 0 /* 1 */
   cerr << "local_filename == " << local_filename << endl;
#endif 

   if (overwrite == false)
   {
@q ******* (7) @>

       errno = 0;
       status = access(local_filename.c_str(), F_OK);

       if (status == -1 && errno == ENOENT)
       {   
#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] In "
                    << "`Scan_Parse_Parameter_Type::receive_file':"
                    << endl 
                    << "`access' returned -1 and `errno' == `ENOENT'."
                    << endl 
                    << "File doesn't already exist.  Will create."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       }  /* |if (status == -1 && errno == ENOENT)|  */

       else if (status == -1)
       {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] WARNING!  In "
                 << "`Scan_Parse_Parameter_Type::receive_file':"
                 << endl 
                 << "`access' returned -1 and `errno' != `ENOENT':"
                 << endl 
                 << strerror(errno)
                 << endl 
                 << "Setting `discard' == `true'."
                 << endl;
            unlock_cerr_mutex(); 

            err_ret_val = 1;

            ++warnings_occurred;
            discard = true;
            goto RECEIVE_FILE_CONTENTS;

       }  /* |else if (status == -1)|  */

       else if (status == 0)
       {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] WARNING!  In "
                 << "`Scan_Parse_Parameter_Type::receive_file':"
                 << endl 
                 << "File `" << local_filename << "' already exists"
                 << endl 
                 << "and `overwrite' == `false'."
                 << endl 
                 << "Setting `discard' == `true'."
                 << endl;
            unlock_cerr_mutex(); 

            err_ret_val = 2;

            ++warnings_occurred;
            discard = true;
            goto RECEIVE_FILE_CONTENTS;

       }  /* |else if (status == 0)|  */

@q ******* (7) @>

   }  /* |if (overwrite == false)|  */

@q ****** (6) Check whether |local_filename| is a path containing one or more directories.  @>

@ Check whether |local_filename| is a path containing one or more directories.  
\initials{LDF 2012.11.20.}

\LOG
\initials{LDF 2012.11.20.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

    local_filename = save_local_filename;

    pos = local_filename.find_last_of("/");

    if (pos != string::npos)
    {
@q ******* (7) @>

        local_path += local_filename.substr(0, pos);

        local_filename.erase(0, pos + 1);

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "local_path == " << local_path << endl
                 << "local_filename == " << local_filename << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) Test whether |local_path| already exists below the current working directory.  @>
@ Test whether |local_path| already exists below the current working directory.  
\initials{LDF 2012.11.20.}

\LOG
\initials{LDF 2012.11.20.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

        string save_local_path = local_path;

        if (pwd_str)
        {
           local_path.insert(0, "/");
           local_path.insert(0, pwd_str);
        }

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "local_path == " << local_path << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        errno = 0;
        status = access(local_path.c_str(), F_OK);

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

        if (status == -1 && errno == ENOENT)
        {   
@q ******** (8) @>

#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "] In "
                     << "`Scan_Parse_Parameter_Type::receive_file':"
                     << endl 
                     << "`access' returned -1 and `errno' == `ENOENT'."
                     << endl 
                     << "Path `" << local_path << "' doesn't already exist.  Will create."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

            temp_path = save_local_path;        

            temp_path.insert(0, "/");

            for (;;)
            {   
@q ********* (9) @>

                 pos = temp_path.find_last_of("/");

                 if (pos == string::npos)
                    break;

                 temp_str = temp_path.substr(pos + 1);

#if 0 /* 1 */  
                 cerr << "temp_path.substr(pos + 1) == " << temp_path.substr(pos + 1) << endl;
#endif 
      
                 if (!temp_str.empty())        
                    dir_list.push_front(temp_str);

                 temp_path.erase(pos);
#if 0 /* 1 */  
                 cerr << "temp_path == " << temp_path << endl;
#endif 

@q ********* (9) @>

            }  /* |for|  */

            temp_path = pwd_str;

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

            for (deque<string>::const_iterator iter = dir_list.begin();
                 iter != dir_list.end();
                 ++iter)
            {   
@q ********* (9) @>

                 temp_path += "/";
                 temp_path += *iter;

#if DEBUG_COMPILE
                 if (DEBUG)
                 {
                     lock_cerr_mutex(); 
                     cerr << "*iter == " << *iter << endl
                          << "temp_path == " << temp_path 
                          << endl;
                     unlock_cerr_mutex(); 

                 }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>
@
\LOG
\initials{LDF 2012.11.29.}
Now calling |::mkdir| instead of |mkdir|.  This is necessary because I've added
a member function |Scan_Parse_Parameter_Type::mkdir|.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::receive_file| definition@>=
         
                 errno = 0;
                 status = ::mkdir(temp_path.c_str(), S_IRWXU | S_IRGRP | S_IXGRP);

                 if (status == -1 && errno == EEXIST)
                 {
                   
#if DEBUG_COMPILE
                      if (DEBUG)
                      {
                          lock_cerr_mutex(); 
                          cerr << "[Thread " << thread_ctr << "] In "
                               << "`Scan_Parse_Parameter_Type::receive_file':"
                               << endl 
                               << "`mkdir' failed, returning -1 and `errno' == `EEXIST'."
                               << endl 
                               << "Path `" << temp_path << "' already exists.  Not creating."
                               << endl 
                               << "Continuing."
                               << endl;
                          unlock_cerr_mutex(); 

                      }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

                      continue;

                 }  /* |if (status == -1 && errno == EEXIST)|  */

                 else if (status == -1)
                 {

                      lock_cerr_mutex(); 
                      cerr << "[Thread " << thread_ctr << "] ERROR!  In "
                           << "`Scan_Parse_Parameter_Type::receive_file':"
                           << endl 
                           << "`mkdir' failed, returning -1:"
                           << endl 
                           << strerror(errno)
                           << endl 
                           << "Setting `discard' == `true'."
                           << endl;
                      unlock_cerr_mutex(); 

                      err_ret_val = 3;

                      ++errors_occurred;
                      discard = true;
                      goto RECEIVE_FILE_CONTENTS;                  

                 }  /* |if (status == -1)|  */

@q ********* (9) @>

#if DEBUG_COMPILE
                 else if (DEBUG)
                 {
                      lock_cerr_mutex(); 
                      cerr << "[Thread " << thread_ctr << "] In "
                           << "`Scan_Parse_Parameter_Type::receive_file':"
                           << endl 
                           << "`mkdir' succeeded.  Created path `" << temp_path << "' "
                           << "successfully."
                           << endl;
                      unlock_cerr_mutex(); 


                 }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

            }  /* |for|  */

@q ******** (8) @>

        }  /* |if (status == -1 && errno == ENOENT)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

        else if (status == -1)
        {
             lock_cerr_mutex(); 
             cerr << "[Thread " << thread_ctr << "] WARNING!  In "
                  << "`Scan_Parse_Parameter_Type::receive_file':"
                  << endl 
                  << "`access' returned -1 and `errno' != `ENOENT':"
                  << endl 
                  << strerror(errno)
                  << endl 
                  << "Setting `discard' == `true'."
                  << endl;
             unlock_cerr_mutex(); 

             err_ret_val = 4;
             ++warnings_occurred;
             discard = true;
             goto RECEIVE_FILE_CONTENTS;

        }  /* |if (status == -1)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

        else if (status == 0)
        {
#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << "[Thread " << thread_ctr << "] In "
                      << "`Scan_Parse_Parameter_Type::receive_file':"
                      << endl 
                      << "Path `" << local_path << "' already exists.  Not creating."
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        }  /* |else if (status == 0)|  */

@q ******* (7) @>

    }  /* |if (pos != string::npos)|  */


@q ****** (6) @>
@
\LOG
\initials{LDF 2012.11.19.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

RECEIVE_FILE_CONTENTS:

    if(!local_path.empty())
    {
       local_filename.insert(0, "/");
       local_filename.insert(0, local_path);
    }

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "local_filename == " << local_filename << endl
            << "local_path == " << local_path << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   if (new_local_filename_ptr != 0)
      *new_local_filename_ptr = local_filename;

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::receive_file| definition@>=


#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "About to open file:  local_filename == " << local_filename << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


    if (!(discard || gen_temp_file))
    {
@q ******** (8) @>

        out_strm.open(local_filename.c_str(), ios_base::out | ios_base::binary);

        if (!out_strm.is_open())
        {
             lock_cerr_mutex(); 
             cerr << "[Thread " << thread_ctr << "] ERROR!  In "
                  << "`Scan_Parse_Parameter_Type::receive_file':"
                  << endl 
                  << "Failed to open file `" << local_filename << "'."
                  << endl 
                  << "Will discard file contents."
                  << endl;
             unlock_cerr_mutex(); 

             err_ret_val = 5;
             ++errors_occurred;
             discard = true;

        }  /* |if (!out_strm.is_open())|  */

@q ******** (8) @>

        else 
        {

#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "] In "
                     << "`Scan_Parse_Parameter_Type::receive_file':"
                     << endl 
                     << "Opened file `" << local_filename << "' successfully."
                     << endl;
                unlock_cerr_mutex(); 
            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       }  /* |else|  */

@q ******** (8) @>

    }  /* |if (!(discard || gen_temp_file))|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

   else /* |discard == true || gen_temp_file == true|  */
   {
@q ******** (8) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] In "
                << "`Scan_Parse_Parameter_Type::receive_file':"
                << endl 
                << "`discard' == `true' || `gen_temp_file' == `true'."
                << endl
                << "Will create temporary file to store file contents "
                << "sent from server."
                << endl;
           unlock_cerr_mutex(); 
       }  /* |if (DEBUG)|  */

#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

       errno = 0;
       fd = mkstemp(temp_filename);

       if (fd == -1)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  In "
                << "`Scan_Parse_Parameter_Type::receive_file':"
                << endl 
                << "`mkstemp' failed, returning -1:"
                << endl
                << strerror(errno)
                << endl 
                << "Can't store file contents to temporary file.  "
                << "Continuing."
                << endl;
           unlock_cerr_mutex(); 

           if (temp_filename_ptr)
              *temp_filename_ptr = "";

           strcpy(temp_filename, "");

       }  /* |if (fd == -1)|  */

@q ******** (8) @>

       else  /* |fd != -1|  */
       {
@q ********* (9) @>

#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "] In "
                     << "`Scan_Parse_Parameter_Type::receive_file':"
                     << endl 
                     << "`mkstemp' succeeded.  `temp_filename' == " << temp_filename << "."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

            close(fd);
            fd = 0;

@q ********* (9) @>

            out_strm.open(temp_filename, ios_base::out | ios_base::binary);

            if (!out_strm.is_open())
            {
                 lock_cerr_mutex(); 
                 cerr << "[Thread " << thread_ctr << "] ERROR!  In "
                      << "`Scan_Parse_Parameter_Type::receive_file':"
                      << endl 
                      << "Failed to open file `" << temp_filename << "'."
                      << endl 
                      << "Will discard file contents."
                      << endl;
                 unlock_cerr_mutex(); 

                 if (temp_filename_ptr)
                     *temp_filename_ptr = "";

                 strcpy(temp_filename, "");

            }  /* |if (!out_strm.is_open())|  */

@q ********* (9) @>

            else 
            {
@q ********** (10) @>

                if (temp_filename_ptr)
                   *temp_filename_ptr = temp_filename;

#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    cerr << "[Thread " << thread_ctr << "] In "
                         << "`Scan_Parse_Parameter_Type::receive_file':"
                         << endl 
                         << "Opened file `" << temp_filename << "' successfully."
                         << endl
                         << "Will store file contents sent from server in this file."
                         << endl;
                    unlock_cerr_mutex(); 
                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>

           }  /* |else|  */ 

@q ********* (9) @>

       }  /* |else| (|fd != -1|)  */

@q ******** (8) @>

   }  /* |else| (|discard == true || gen_temp_file == true|)  */

@q ******* (7) @>
@
\LOG
\initials{LDF 2012.12.13.}
@:BUG FIX@> BUG FIX:  Now calling |ofstream::write| to write |buffer| to |out_strm|.
|write| uses unformatted output.  Previously, I used |operator<<|, which uses
formatted output, which didn't work |buffer| was full, i.e., without a NULL 
byte at the end.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

    char buffer[BUFFER_SIZE];

    do
    {
@q ******** (8) @>

        memset(buffer, 0, BUFFER_SIZE);
    
#if DEBUG_COMPILE
        if (DEBUG)
        {

            cerr << "In `Scan_Parse_Parameter_Type::receive_file':  ";

            if (remote_connection)
                cerr << "Calling `gnutls_record_recv' ... " << endl;
            else
                cerr << "Calling `recv' ... " << endl;

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        if (remote_connection == true)
        {
            status = gnutls_record_recv (session, buffer, BUFFER_SIZE);  
        }
        else
        {
            status = recv(sock, buffer, BUFFER_SIZE, 0);
        }   

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] In `receive_file':"
                 << endl;

            if (remote_connection)
                cerr << "`gnutls_record_recv' ";
            else
                cerr << "`recv' ";
 
            cerr << "returned " << status << "." 
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        if (status > 0) 
        {
#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "] In `receive_file':"
                     << endl 
                     << "Received text from client:  buffer == " 
                     << endl;

                fwrite(buffer, 1, status, stderr);

                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

            out_strm.write(buffer, status);

       }  /*  |if (status > 0)|  */

@q ******** (8) @>

    }  /* |do|  */

    while (status == BUFFER_SIZE);

@q ******* (7) @>

    if (out_strm.is_open())
       out_strm.close();

    if (discard)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "] "
             << "In `Scan_Parse_Parameter_Type::receive_file':"
             << endl 
             << "`discard' == " << discard
             << endl
             << "`gen_temp_file' == " << gen_temp_file
             << endl;

        if (temp_filename && strlen(temp_filename) > 0)
        {

            cerr << "Wrote file contents sent from server to temporary file "
                 << "`" << temp_filename << "'."
                 << endl;
    
        }

        else
            cerr << "Discarded file contents sent from server."
                 << endl;

        cerr << "Exiting function unsuccessfully with return value "
             << err_ret_val << "."
             << endl;
        unlock_cerr_mutex(); 
  
        return err_ret_val;

    }  /* |if (discard)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::receive_file| definition@>=

#if DEBUG_COMPILE 
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] "
              << "Exiting `Scan_Parse_Parameter_Type::receive_file' "
              << "successfully with return value 0."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */

     return 0;

}  /* |Scan_Parse_Parameter_Type::receive_file|  */

@q **** (4) Get metadata.  @>
@ Get metadata.
\initials{LDF 2012.10.09.}

\LOG
\initials{LDF 2012.10.09.}
Added this function.

\initials{LDF 2012.12.21.}
Added the optional arguments |bool send_response|, |bool do_output|, 
|bool do_irods_user_metadata| and 
|vector<Dublin_Core_Metadata_Type> *dc_metadata_type_vector_ptr|.  Adapting this
function for use with |Scan_Parse_Parameter_Type::add_metadata|.  For this use, 
|get_metadata| should store the data from the database in |Dublin_Core_Metadata_Type|
objects in |*dc_metadata_type_vector_ptr| but neither output XML code to a temporary file
nor send responses to the peer.

\initials{LDF 2012.12.31.}
Added optional argument |unsigned int options| with the default 0.

\initials{LDF 2013.01.04.}
Added code for sending responses in the error cases.

\initials{LDF 2013.02.13.}
Moved the definition of this function from this file (\filename{scprpmtp.web}) to 
\filename{spptfnc1.web}.

\initials{LDF 2013.05.23.}
Replaced the optional argument |bool send_response = true| with the 
optional arguments |char *buffer_ptr = 0| and |size_t buffer_size = 0|.

\initials{LDF 2013.12.18.}
Replaced optional argument 
|vector<Dublin_Core_Metadata_Type> *dc_metadata_type_vector_ptr = 0|
with 
|map<unsigned long int, Dublin_Core_Metadata_Type> *dc_metadata_type_map_ptr = 0|.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
int
get_metadata(string filename, 
             unsigned int flags, 
             int *ctr = 0, 
             unsigned int options = 0,
             char *buffer_ptr = 0,
             size_t buffer_size = 0,
             bool do_output = true,
             bool do_irods_user_metadata = true,
             map<unsigned long int, Dublin_Core_Metadata_Type>
                                           *dc_metadata_map_ptr = 0);

@q **** (4) Get handle.  (|get_handle|).  @>
@ Get handle.  (|get_handle|).
\initials{LDF 2012.10.15.}

\LOG
\initials{LDF 2012.10.15.}
Added this function.

\initials{LDF 2013.02.13.}
Moved the definition of this function from this file (\filename{scprpmtp.web}) to 
\filename{spptfnc1.web}.

\initials{LDF 2013.12.19.}
Added optional argument |unsigned int options = 0U|.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
get_handle(string s, 
           unsigned int flags, 
           unsigned int options = 0U,
           string filename_1 = "");


@q **** (4) Change working directory.  (|cd|).  @>
@ Change working directory.  (|cd|).
\initials{LDF 2012.11.23.}

\LOG
\initials{LDF 2012.11.23.}
Added this function.

\initials{LDF 2012.11.27.}
Made argument |string dir| optional with default |""|.

\initials{LDF 2013.04.03.}
Made argument |string dir| non-optional again.  Added arguments |char *buffer_ptr|
and |unsigned int buff_size|.  Rewrote this function.  Now calling it in 
|exchange_data_with_client| instead of |yyparse|.

\initials{LDF 2013.04.03.}
@:BUG FIX@> BUG FIX:  Removed code for setting the environment variable 
\.{irodsCwd}.  This won't work properly, because the environment is shared by all 
threads!
\ENDLOG

@q ***** (5) @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
cd(string dir, char *buffer_ptr, unsigned int buff_size);

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=

int
Scan_Parse_Parameter_Type::cd(string dir, char *buffer_ptr, unsigned int buff_size)
{
@q ****** (6) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   int status;

   size_t pos;

   stringstream temp_strm;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] Entering `Scan_Parse_Parameter_Type::cd'."
            << endl
            << "`dir' == " << dir
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

@q ****** (6) @>
@
\LOG
\initials{LDF 2013.04.04.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::cd| definition@>=

   if (buffer_ptr == 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::cd':"
            << endl
            << "`char *buffer_ptr' == NULL.  This isn't permitted."
            << endl 
            << "Exiting function unsuccessfully with return value 3."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 3;

   }  /* |if (buff_size < 1024)|  */


@q ****** (6) @>
@
\LOG
\initials{LDF 2013.04.04.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::cd| definition@>=

   if (buff_size < 1024)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::cd':"
            << endl
            << "`buff_size' < 1024.  This isn't permitted."
            << endl 
            << "Exiting function unsuccessfully with return value 3."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 3;

   }  /* |if (buff_size < 1024)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=

   memset(buffer_ptr, 0, buff_size);

   if (dir.empty())
   {
       dir = irods_homedir;
   }

   /* Erase trailing slash, if any.  \initials{LDF 2012.11.27.}  */

   else if (dir[dir.size() - 1] == '/')  
   {
       dir.erase(dir.size() - 1);
 
#if 0 /* 1 */ 
       cerr << "dir after erasing trailing slash:  " << dir << endl;
#endif 

   }

   pos = dir.find("$HOME");

   if (pos != string::npos)
   {
       dir.replace(pos, 5, irods_homedir);
#if 0 /* 1 */ 
       cerr << "dir after replace == " << dir << endl;
#endif 
   }  

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=

   temp_strm.str("");

   temp_strm << "env irodsEnvFile=" << irods_env_filename << " "
             << "icd -v '" << dir << "';r=$?;echo $r";

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::cd':"
            << endl
            << "`temp_strm.str()' == " << temp_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   FILE *fp = popen(temp_strm.str().c_str(), "r");

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=

   if (fp == 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::cd':"
            << endl
            << "`popen' failed, returning NULL.  `icd' command failed."
            << endl
            << "Can't change iRODS current working directory to `" << dir << "'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       temp_strm.str("");

       temp_strm << "CD RESPONSE 2 \"" << dir << "\" "
                 << " \"" << irods_current_dir << "\" "
                 << " \"" << irods_current_dir << "\" "
                 << "\"`popen' failed\""; 

       strcpy(buffer_ptr, temp_strm.str().c_str());
   
       return 1;

   }  /* |if (fp == 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::cd':"
            << endl
            << "`popen' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=
     
   char buffer[1024];

   memset(buffer, 0, 1024);

   status = fread(buffer, 1, 1024, fp);


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=

   if (status == 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::cd':"
            << endl
            << "`fread' read 0 bytes:"
            << "`feof(fp)' == " << feof(fp)
            << endl 
            << "` ferror(fp)' == " << ferror(fp)
            << endl 
            << "`icd' failed."
            << endl 
            << "iRODS current working directory is in an undefined state."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "CD RESPONSE 3 \"" << dir << "\" "
                 << " \"" << irods_current_dir << "\" "
                 << " \"" << irods_current_dir << "\" "
                 << "\"Failed to read output and/or exit status of `icd' command\""; 

       pclose(fp);
       fp = 0;

       strcpy(buffer_ptr, temp_strm.str().c_str());

       ++errors_occurred;

       return 1;

   }  /* |if (status == 0)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=

   else if (status == 1024)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::cd':"
            << endl
            << "`fread' read 1024 bytes.  This exceeds the maximum number of permitted "
            << "bytes for the output of `icd'."
            << endl 
            << "iRODS current working directory is in an undefined state."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "CD RESPONSE 4 \"" << dir << "\" "
                 << " \"" << irods_current_dir << "\" "
                 << " \"" << irods_current_dir << "\" "
                 << "\"`icd' command produced too much output (>= 1024 bytes)\""; 

       strcpy(buffer_ptr, temp_strm.str().c_str());

       pclose(fp);
       fp = 0;

       ++errors_occurred;

       return 1;

   }  /* |else if (status == 1024)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::cd':"
            << endl
            << "`fread' read " << status << " bytes."
            << endl 
            << "`buffer' == " 
            << endl 
            << buffer 
            << endl;

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */        

   while (buffer[strlen(buffer) - 1] == '\n')
        buffer[strlen(buffer) - 1] = '\0';

   buffer[strlen(buffer)] = '\n';  /* Put one newline back on the end of 
                                      |buffer|.
                                      There will always be enough room
                                      for this newline, because the \.{echo}
                                      command will have produced one.
                                      We therefore don't need to test for this.
                                      \initials{LDF 2012.11.23.}  */
#if 0 /* 1 */ 
   cerr << "After removing trailing newlines:  buffer == (delimited with single quotes)" 
        << endl 
        << "'" << buffer << "'" 
        << endl;
#endif 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=

   string output_str = buffer;

   long int ret_val;

   pos = output_str.find_last_of('\n', output_str.size() - 2);

   errno = 0;

   if (pos == string::npos)
   {
#if 0 /* 1 */ 
       cerr << "Only one line" << endl;
#endif 
       ret_val = strtol(output_str.c_str(), 0, 10);
       output_str = "";

   }
   else
   {
#if 0 /* 1 */ 
       cerr << "More than one line." << endl;
#endif 
       output_str.erase(0, pos);

       ret_val = strtol(output_str.c_str(), 0, 10);
       output_str = buffer;
       output_str.erase(pos);

#if 0 /* 1 */ 
       cerr << "output_str after second erase == " << output_str << endl;
#endif 

   }  /* |else|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=

#if 0 
       cerr << "ret_val == " << ret_val << endl;
#endif 

   if (ret_val == LONG_MIN || ret_val == LONG_MAX)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::cd':"
            << endl
            << "`strtol' failed, returning ";
       if (ret_val == LONG_MIN)
           cerr << "`LONG_MIN':" << endl;
       else 
           cerr << "`LONG_MAX':" << endl;

       cerr << strerror(errno) << endl
            << "Failed to read return value of `icd' command, executed in pipe."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "CD RESPONSE 5 \"" << dir << "\" "
                 << " \"" << irods_current_dir << "\" "
                 << " \"" << irods_current_dir << "\" "
                 << "\"Server-side error:  Failed to read return value of "
                 << "`icd' command, executed in pipe\"";

#if 0 /* 1 */ 
       cerr << "temp_strm.str() == " << temp_strm.str() << endl;
#endif 

       strcpy(buffer_ptr, temp_strm.str().c_str());
       
       pclose(fp);
       fp = 0;

       ++errors_occurred;

       return 1;

   }  /* |if (ret_val == LONG_MIN || ret_val == LONG_MAX)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=

   if (ret_val != 0)
   {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::cd':"
             << endl
             << "`icd' command, executed in pipe, failed, returning " << ret_val << "."
             << endl;

        if (!output_str.empty())
             cerr << "Error output:  " << output_str
                  << endl;

        cerr << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        ++errors_occurred;

        temp_strm.str("");

        temp_strm << "CD RESPONSE 6 \"" << dir << "\" "
                  << " \"" << irods_current_dir << "\" "
                  << " \"" << irods_current_dir << "\" "
                  << "\"Server-side error:  `icd' command, executed in pipe, "
                  << "failed, returning " << ret_val << ".";

        if (!output_str.empty())
             temp_strm << "\\n" << right << setw(35) << " " << "Error output:  " 
                       << output_str << endl;

        temp_strm << "\"";

#if 0 /* 1 */ 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
#endif 

        strcpy(buffer_ptr, temp_strm.str().c_str());
       
        pclose(fp);
        fp = 0;

        return 1;

   }  /* |if (ret_val != 0)|  */
      

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::cd':"
            << endl
            << "`icd' command, executed in pipe, succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   pclose(fp);
   fp = 0;
      
@q ****** (6)   @>

@ If |dir| starts with a slash, it is interpreted as an absolute path.  Otherwise,
it is interpreted as a path below |irods_current_dir|.  That is, |dir| is in effect appended
to |irods_current_dir|.

\LOG
\initials{LDF 2012.11.27.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::cd| definition@>=

   temp_strm.str("");
   
   string save_irods_current_dir = irods_current_dir;

   if (dir[0] == '/')  
      temp_strm << dir;
   else 
      temp_strm << irods_current_dir << "/" << dir;

#if 0 /* 1 */ 
      cerr << "temp_strm.str() == " << temp_strm.str() << endl;
#endif 

   errno = 0;

   irods_current_dir = temp_strm.str();

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "irods_current_dir == " << irods_current_dir << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=

   temp_strm.str("");

   temp_strm << "CD RESPONSE 0 \"" << dir << "\" "
             << " \"" << save_irods_current_dir << "\" "
             << " \"" << irods_current_dir << "\" ";

   if (!output_str.empty())
       temp_strm << "\"Command output:  " << output_str << "\"";
   else 
       temp_strm << "\"SUCCESS (No command output).\"";

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "temp_strm.str() == " << temp_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
  
   strcpy(buffer_ptr, temp_strm.str().c_str());

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::cd| definition@>=

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] Exiting `Scan_Parse_Parameter_Type::cd' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::cd| definition  */


@q **** (4) Create directory.  (|mkdir|).  @>
@ Create directory.  (|mkdir|).
\initials{LDF 2012.11.29.}

The length of the string to be copied into |buffer_ptr| is tested against |buffer_size| 
before copying.  If the string is too long, |buffer_ptr| is set to the empty string.
However, this should never occur.  Unlike the output of \.{ils}, which depends on the 
number of existing iRODS objects, the output of \.{imkdir} is not likely to be very long.
Currently, this function is only called in |exchange_data_with_client| where the 
|buffer_size| argument is the preprocessor macro |BUFFER_SIZE| defined 
in \filename{glblvrbl.web}.  As of this date, the value of |BUFFER_SIZE| is 2048, which
should be much more than enough for the output of \.{imkdir}.
\initials{LDF 2013.04.25.}

\LOG
\initials{LDF 2012.11.29.}
Added this function.

\initials{LDF 2012.11.30.}
Removed argument |string flags = ""|.  Now using data member 
|Scan_Parse_Parameter_Type::icommands_flag_str| instead.

\initials{LDF 2013.04.25.}
Added code for disabling thread cancellation and restoring the prior thread cancellation
state before exiting.  Removed code that tests the value of |icommands|:  Currently, only
icommands are used for accessing the iRODS server.

\initials{LDF 2013.04.25.}
Replaced the argument |string flags| with the arguments 
|Response_Type &response|, |char *buffer_ptr| and |size_t buffer_size|.
\ENDLOG

@q ***** (5) @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
mkdir(Response_Type &response, char *buffer_ptr, size_t buffer_size);

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::mkdir| definition@>=

int
Scan_Parse_Parameter_Type::mkdir(Response_Type &response, char *buffer_ptr, size_t buffer_size)
{
@q ****** (6) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   int status;

   size_t pos;

   stringstream temp_strm;

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] Entering `Scan_Parse_Parameter_Type::mkdir'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 


   string directory_list;

   for (vector<string>::const_iterator iter = response.string_vector.begin();
        iter != response.string_vector.end();
        ++iter)
   {

       directory_list += *iter;
       directory_list += " ";       

   }  /* |for|  */

   directory_list.erase(directory_list.length() - 1);  /* Remove trailing space.
                                                          \initials{LDF 2013.04.25.}
                                                       */

   response.string_vector.clear();

@q ****** (6) Disable thread cancellation.  @>

@ Disable thread cancellation.
\initials{LDF 2013.04.25.}

\LOG
\initials{LDF 2013.04.25.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::mkdir| definition@>=
 
   int old_pthread_cancel_state = 0;

   status = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &old_pthread_cancel_state);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::mkdir':"
            << endl
            << "`pthread_setcancelstate' failed, returning " << status << ":"
            << endl
            << strerror(status)
            << endl
            << "Failed to disable thread cancellation."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "MKDIR RESPONSE 7 \"" << directory_list << "\" "
                 << " \"\""
                 << "\"`pthread_setcancelstate' failed\""; 

       if (temp_strm.str().length() < buffer_size) 
          strcpy(buffer_ptr, temp_strm.str().c_str());
       else 
          strcpy(buffer_ptr, "");
       
       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::mkdir':"
            << endl
            << "`pthread_setcancelstate' succeeded, returning 0."
            << endl
            << "Disabled thread cancellation successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mkdir| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::mkdir':"
            << endl
            << "`icommands' == `true'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   string new_flags;

   pos = response.flags.find("-p");
   
   if (pos != string::npos)
      new_flags = "-p ";

   pos = response.flags.find("-v");
   
   if (pos != string::npos)
      new_flags = "-v ";

   pos = response.flags.find("-V");
   
   if (pos != string::npos)
      new_flags = "-V ";

 
   response.flags = "";
   temp_strm.str("");

   temp_strm << "env irodsEnvFile=" << irods_env_filename << " "
             << "imkdir " << new_flags << directory_list << " 2>&1;echo $?";

    
#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "temp_strm.str() == " << temp_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */       

   FILE *fp = popen(temp_strm.str().c_str(), "r");

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mkdir| definition@>=
       
   if (fp == 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::mkdir':"
            << endl
            << "`popen' failed, returning NULL.  `imkdir' command failed."
            << endl
            << "Failed to created new directory or directories."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "MKDIR RESPONSE 2 \"" << directory_list << "\" "
                 << " \"\""
                 << "\"`popen' failed\""; 

       if (temp_strm.str().length() < buffer_size) 
          strcpy(buffer_ptr, temp_strm.str().c_str());
       else 
          strcpy(buffer_ptr, "");

       pthread_setcancelstate(old_pthread_cancel_state, 0);

       ++errors_occurred;

       return 1;

   }  /* |if (fp == 0)|  */
         

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mkdir| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::mkdir':"
            << endl
            << "`popen' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mkdir| definition@>=
     
   char buffer[1024];

   memset(buffer, 0, 1024);

   status = fread(buffer, 1, 1024, fp);
  
@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::mkdir| definition@>=

   if (status == 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::mkdir':"
            << endl
            << "`fread' read 0 bytes:"
            << "`feof(fp)' == " << feof(fp)
            << endl 
            << "` ferror(fp)' == " << ferror(fp)
            << endl 
            << "`imkdir' failed."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "MKDIR RESPONSE 3 \"" << directory_list << "\" "
                 << " \"\""
                 << "\"Failed to read output and/or exit status of `imkdir' command\""; 


       if (temp_strm.str().length() < buffer_size) 
          strcpy(buffer_ptr, temp_strm.str().c_str());
       else 
          strcpy(buffer_ptr, "");
       
       pclose(fp);

       pthread_setcancelstate(old_pthread_cancel_state, 0);

       ++errors_occurred;

       return 1;

   }  /* |if (status == 0)|  */


@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::mkdir| definition@>=

   else if (status == 1024)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::mkdir':"
            << endl
            << "`fread' read 1024 bytes.  This exceeds the maximum number of permitted "
            << "bytes for the output of `imkdir'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "MKDIR RESPONSE 4 \"" << directory_list << "\" "
                 << " \"\"" 
                 << "\"`imkdir' command produced too much output (>= 1024 bytes)\""; 

  
       if (temp_strm.str().length() < buffer_size) 
          strcpy(buffer_ptr, temp_strm.str().c_str());
       else 
          strcpy(buffer_ptr, "");

       pclose(fp);
       fp = 0;

       pthread_setcancelstate(old_pthread_cancel_state, 0);

       ++errors_occurred;

       return 1;

   }  /* |else if (status == 1024)|  */


@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::mkdir| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::mkdir':"
            << endl
            << "`fread' read " << status << " bytes."
            << endl 
            << "`buffer' == " 
            << endl 
            << buffer 
            << endl;

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */        

   while (buffer[strlen(buffer) - 1] == '\n')
        buffer[strlen(buffer) - 1] = '\0';

   buffer[strlen(buffer)] = '\n';  /* Put one newline back on the end of 
                                          |buffer|.
                                      There will always be enough room
                                      for this newline, because the \.{echo}
                                      command will have produced one.
                                      We therefore don't need to test for this.
                                          \initials{LDF 2012.11.23.}  */
#if 0 /* 1 */ 
   cerr << "After removing trailing newlines:  buffer == (delimited with single quotes)" 
        << endl 
        << "'" << buffer << "'" 
        << endl;
#endif 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mkdir| definition@>=

   string output_str = buffer;

   long int ret_val;

   pos = output_str.find_last_of('\n', output_str.size() - 2);

   errno = 0;

   if (pos == string::npos)
   {

#if 0 /* 1 */ 
       cerr << "Only one line" << endl;
#endif 
       ret_val = strtol(output_str.c_str(), 0, 10);
       output_str = "";

   }
   else
   {
#if 0 /* 1 */ 
       cerr << "More than one line." << endl;
#endif 
       output_str.erase(0, pos);

       ret_val = strtol(output_str.c_str(), 0, 10);
       output_str = buffer;
       output_str.erase(pos);

#if 0 /* 1 */ 
       cerr << "output_str after second erase == " << endl 
            << output_str 
            << endl
            << "(End of `output_str')"
            << endl;
#endif 

   }  /* |else|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mkdir| definition@>=


#if 0 /* 1 */  
   cerr << "ret_val == " << ret_val << endl;
#endif 

   if (ret_val == LONG_MIN || ret_val == LONG_MAX)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::mkdir':"
            << endl
            << "`strtol' failed, returning ";
       if (ret_val == LONG_MIN)
           cerr << "`LONG_MIN':" << endl;
       else 
           cerr << "`LONG_MAX':" << endl;

       cerr << strerror(errno) << endl
            << "Failed to read return value of `imkdir' command, executed in pipe."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       temp_strm.str("");

       temp_strm << "MKDIR RESPONSE 5 \"" << directory_list << "\" "
                 << " \"\" "
                 << "\"Server-side error:  Failed to read return value of "
                 << "`imkdir' command, executed in pipe\"";

#if 0 /* 1 */ 
       cerr << "temp_strm.str() == " << temp_strm.str() << endl;
#endif 

       if (temp_strm.str().length() < buffer_size) 
          strcpy(buffer_ptr, temp_strm.str().c_str());
       else 
          strcpy(buffer_ptr, "");

       
       pclose(fp);
       fp = 0;

       pthread_setcancelstate(old_pthread_cancel_state, 0);

       return 1;

   }  /* |if (ret_val == LONG_MIN || ret_val == LONG_MAX)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mkdir| definition@>=

  if (ret_val != 0)
  {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::mkdir':"
            << endl
            << "`imkdir' command, executed in pipe, failed, returning " << ret_val << "."
            << endl;

       if (!output_str.empty())
            cerr << "Error output:  " << output_str
                 << endl;

       cerr << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "MKDIR RESPONSE 6 \"" << directory_list << "\" "
                 << " \"" << output_str << "\" "
                 << "\"Server-side error:  `imkdir' command, executed in pipe, "
                 << "failed, returning " << ret_val << "\"";


#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_strm.str().length() < buffer_size) 
          strcpy(buffer_ptr, temp_strm.str().c_str());
       else 
          strcpy(buffer_ptr, "");
       
       pclose(fp);
       fp = 0;

       pthread_setcancelstate(old_pthread_cancel_state, 0);

       ++errors_occurred;

       return 1;


  }  /* |if (ret_val != 0)|  */
      

#if DEBUG_COMPILE
  else if (DEBUG)
  {
      lock_cerr_mutex(); 
      cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::mkdir':"
           << endl
           << "`imkdir' command, executed in pipe, succeeded, returning 0."
           << endl;
      unlock_cerr_mutex(); 

  }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 



@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mkdir| definition@>=

   temp_strm.str("");

   temp_strm << "MKDIR RESPONSE 0 \"" << directory_list << "\" \"\" \"Success\"";

   if (temp_strm.str().length() < buffer_size) 
      strcpy(buffer_ptr, temp_strm.str().c_str());
   else 
      strcpy(buffer_ptr, "");

   temp_strm.str("");

@q ****** (6) Restore prior thread cancellation state.  @>

@ Restore prior thread cancellation state.  
\initials{LDF 2013.04.25.}

\LOG
\initials{LDF 2013.04.25.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::mkdir| definition@>=

   status = pthread_setcancelstate(old_pthread_cancel_state, 0);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::mkdir':"
            << endl
            << "`pthread_setcancelstate' failed, returning " << status << ":"
            << endl
            << strerror(status)
            << endl
            << "Failed to restore prior thread cancellation state."
            << endl 
            << "Exiting function unsuccessfully with return value 3."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 3;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::mkdir':"
            << endl
            << "`pthread_setcancelstate' succeeded, returning 0."
            << endl
            << "Restored prior thread cancellation state successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::mkdir| definition@>=

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] Exiting `Scan_Parse_Parameter_Type::mkdir' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 


   return 0;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::mkdir| definition  */

@q **** (4) Add metadata.  @>
@ Add metadata.
\initials{LDF 2012.12.14.}

\LOG
\initials{LDF 2012.12.14.}
Added this function.

\initials{LDF 2013.02.13.}
Moved the definition of this function from this file (\filename{scprpmtp.web}) to 
\filename{spptfnc1.web}.
\ENDLOG

@q ***** (5) @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
add_metadata(Response_Type &response);

@q **** (4) Store Dublin Core metadata (|store_dc_metadata|).  @>
@ Store Dublin Core metadata (|store_dc_metadata|).
\initials{LDF 2013.03.01.}

\LOG
\initials{LDF 2013.03.01.}
Added this function.  It's defined in \filename{spptfnc1.web}.

\initials{LDF 2013.03.07.}
Changed arguments:  Now passing |Handle_Type| references instead of a string 
representing the handle and |unsigned long int| values representing the handle ID.

\initials{LDF 2013.11.25.}
Added optional argument |unsigned long irods_object_ref_id = 0UL|.

\initials{LDF 2013.11.27.}
Added required argument |unsigned long dc_metadata_id| and
optional argument |string thread_str = ""|.
\ENDLOG

@q ***** (5) @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
store_dc_metadata(const Response_Type &response,
                  Handle_Type &irods_object_handle,
                  Handle_Type &dc_metadata_handle,
                  bool force,
                  string &irod_object_path,
                  unsigned long int dc_metadata_id,
                  unsigned long int irods_object_ref_id = 0UL,
                  string thread_str = "");



@q **** (4) Parse metadata.  @>
@ Parse metadata..
\initials{LDF 2012.12.14.}

\LOG
\initials{LDF 2012.12.14.}
Added this function.

\initials{LDF 2013.02.13.}
Moved the definition of this function from this file (\filename{scprpmtp.web}) to 
\filename{spptfnc1.web}.
\ENDLOG

@q ***** (5) @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
parse_metadata(vector<Dublin_Core_Metadata_Type> &dc_metadata_vector, Response_Type &response);

@q *** (3) Fetch handle from database.  @>
@ Fetch handle from database.
\initials{LDF 2013.02.07.}

\LOG
\initials{LDF 2013.02.07.}
Added this function.

\initials{LDF 2013.02.13.}
Moved the definition of this function from this file (\filename{scprpmtp.web}) to 
\filename{spptfnc1.web}.

\initials{LDF 2013.02.28.}
Added argument |Handle_Type &handle|.  It replaces the 
old |Handle_Value_Type &| argument.  
\ENDLOG

@q **** (4) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=


int 
fetch_handle_from_database(unsigned long int handle_id,
                           Handle_Type &handle,
                           string type = "");


@q *** (3) Fetch handle from database.  @>
@ Fetch handle from database.
\initials{LDF 2013.06.16.}

\LOG
\initials{LDF 2013.06.16.}
Added this function declaration.
\ENDLOG

@q **** (4) Declaration (version with |string| argument)  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
int
fetch_handle_from_database(string handle_str,
                           Handle_Type &handle,
                           string type = "");

@q *** (3) Fetch handles from database.  @>
@ Fetch handles from database.
\initials{LDF 2013.02.07.}

\LOG
\initials{LDF 2013.02.07.}
Added this function.

\initials{LDF 2013.02.13.}
Moved the definition of this function from this file (\filename{scprpmtp.web}) to 
\filename{spptfnc1.web}.

\initials{LDF 2013.02.28.}
Added argument |vector<Handle_Type> &handle_vector|.  It replaces the 
old |vector<Handle_Value_Type> &| argument.
\ENDLOG

@q **** (4) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=


int 
fetch_handles_from_database(vector<unsigned long int> &handle_id_vector, 
                            vector<Handle_Type> &handle_vector,
                            string type = "");


@q *** (3) Get highest value (|get_highest_value|).  @>
@ Get highest value (|get_highest_value|).  
\initials{LDF 2013.06.06.}

\LOG
\initials{LDF 2013.06.06.}
Added this function declaration.  The definition is in \filename{spptfnc1.web}.
\ENDLOG

@<|Scan_Parse_Parameter_Type| function declarations@>=

static
int
get_highest_value(MYSQL *mysql_ptr,
                  string table, 
                  string column, 
                  unsigned long int &val, 
                  bool incr = false);


@q *** (3) Show certificates  @>
@ Show certificates.
\initials{LDF 2013.05.15.}

\LOG
\initials{LDF 2013.05.15.}
Added this function declaration.  It is defined in \filename{spptfnc1.web}.
\ENDLOG

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
show_certificates(Response_Type &response, char *buffer, size_t buffer_size, string &filename);


@q *** (3) Show privileges.  (|show_privileges|).  @>
@ Show privileges.  (|show_privileges|).
\initials{LDF 2013.05.22.}

This is a |static| function.  The |unsigned int| value representing the privileges
must be passed to it.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this function declaration.
The definition is in \filename{spptfnc1.web}.
\ENDLOG

@q **** (4) @>

@<|Scan_Parse_Parameter_Type| function declarations@>=
static
int
show_privileges(unsigned int privileges, ostream *strm = 0, bool verbose = false);


@q **** (4) Get input (|get_input|) declaration.   @>
@ Get input (|get_input|) declaration.
\initials{LDF 2013.07.11.}

\LOG
\initials{LDF 2013.07.11.}
Added this function declaration.  The definition is in \filename{spptfnc1.web}.
\ENDLOG


@<|Scan_Parse_Parameter_Type| function declarations@>=

int
get_input(void);


@q **** (4) Mark iRODS objects for deletion.  @>
@ Mark iRODS objects for deletion.
\initials{LDF 2013.08.07.}

\LOG
\initials{LDF 2013.08.07.}
Added this function declaration.  The definition is in \filename{spptfnc1.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
mark_irods_objects_for_deletion(Response_Type &response, 
                               char *buffer_ptr, 
                               size_t buffer_size);

@q **** (3) Undelete files (|undelete_files|).  @>
@ Undelete files (|undelete_files|).
\initials{LDF 2013.08.16.}

\LOG
\initials{LDF 2013.08.16.}
Added this function declaration.  The definition is in \filename{spptfnc2.web}.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
undelete_files(Response_Type &response, string thread_str = "");

@q **** (4) Generate checksum (|generate_checksum|)  @>
@ Generate checksum (|generate_checksum|).
\initials{LDF 2013.12.25.}

\LOG
\initials{LDF 2013.12.25.}
Added this function declaration.  The definition is in \filename{spptfnc2.web}.

\initials{LDF 2014.01.03.}
Added optional argument |bool verify_only = false|.
\ENDLOG

@q ***** (5) Declaration  @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
generate_checksum(Response_Type &response, bool verify_only = false, string thread_str = "");


@q **** (4) Store public key (|store_public_key|).  @>

@ Store public key (|store_public_key|).  
\initials{LDF 2014.01.21.}

\LOG
\initials{LDF 2014.01.21.}
Added this function declaration.  This function is defined in \filename{spptfnc2.web}.
\ENDLOG

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
store_public_key(string uid, 
                 string fingerprint, 
                 string public_key, 
                 unsigned int options, 
                 string thread_str = "");



@q **** (4) Process pull request (|process_pull_request|).  @>

@ Process pull request (|process_pull_request|).  
\initials{LDF 2014.02.03.}

\LOG
\initials{LDF 2014.02.03.}
Added this function declaration.  This function is defined in \filename{spptfnc2.web}.
\ENDLOG

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
process_pull_request(Response_Type &response, 
                     Pull_Request_Type *&pull_request, 
                     string thread_str = "");



@q *** (3) Add pull paths (|add_pull_paths|).  @>

@ Add pull paths (|add_pull_paths|).  
\initials{LDF 2014.02.18.}

\LOG
\initials{LDF 2014.02.18.}
Added this function declaration.  The definition is in \filename{spptfnc2.web}.

\initials{LDF 2014.02.20.}
Changed name of this function from |add_pull_path| to |add_pull_paths|.
Removed arguments |local_path| and |remote_path|.
Now using |Scan_Parse_Parameter_Type::filename_list| instead.
Rewrote to make it possible to add multiple pull paths.
\ENDLOG

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
add_pull_paths(Pull_Response_Type &pull_response, 
               int &pull_paths_added,
               string thread_str = "");

@q **** (4) Server action function declarations.  @>
@ Server action function declarations.
\initials{LDF 2013.05.27.}

@q ***** (5) Log @>

\LOG
\initials{LDF 2013.05.27.}
\initials{LDF 2013.05.29.}
Added this section.  The definitions of these functions 
are in \filename{srvractn.web}.  Pointers to these functions are inserted into 
|Scan_Parse_Parameter_Type::server_action_map| by |initialize_maps| (see above).

\initials{LDF 2013.06.15.}
Added declaration of |Scan_Parse_Parameter_Type::server_action_add_handle_value|.

\initials{LDF 2013.07.04.}
Added declaration of |Scan_Parse_Parameter_Type::server_action_delete_handle|.

\initials{LDF 2013.08.07.}
Added declaration of |Scan_Parse_Parameter_Type::server_action_mark_irods_objects_for_deletion|.

\initials{LDF 2013.08.15.}
Added declaration of |Scan_Parse_Parameter_Type::server_action_undelete_file|.

\initials{LDF 2013.08.21.}
Added declaration of |Scan_Parse_Parameter_Type::server_action_undelete_handle|.

\initials{LDF 2013.08.30.}
Added declaration of |Scan_Parse_Parameter_Type::server_action_delete_handle_value| 
and |Scan_Parse_Parameter_Type::server_action_undelete_handle_value|.

\initials{LDF 2013.10.31.}
Added declaration of |Scan_Parse_Parameter_Type::server_action_delete_metadata| and 
|Scan_Parse_Parameter_Type::server_action_undelete_metadata|.

\initials{LDF 2013.12.06.}
Added declaration of |Scan_Parse_Parameter_Type::server_action_show_metadata|.

\initials{LDF 2013.12.18.}
Renamed |Scan_Parse_Parameter_Type::server_action_show_metadata|
to
|Scan_Parse_Parameter_Type::server_action_fetch_metadata|.

\initials{LDF 2013.12.25.}
Added declarations of |server_action_generate_checksum| and 
|server_action_verify_checksum|.

\initials{LDF 2014.01.21.}
Added declaration of |server_action_store_public_key|.

\initials{LDF 2014.01.31.}
Added declaration of |server_action_register_pull|.
\ENDLOG

@q ***** (5) Code @>

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
server_action_command_only(Response_Type &response);

int
server_action_send_file(Response_Type &response);

int
server_action_receive_put_file(Response_Type &response);

int
server_action_receive_metadata_file(Response_Type &response);

int
server_action_send_handle(Response_Type &response);

int
server_action_ls(Response_Type &response);

int
server_action_mv(Response_Type &response);

int
server_action_pwd(Response_Type &response);

int
server_action_cd(Response_Type &response);

int
server_action_mkdir(Response_Type &response);

int
server_action_mark_irods_objects_for_deletion(Response_Type &response);

int
server_action_get(Response_Type &response);

int
server_action_send_metadata(Response_Type &response);

int
server_action_end_server(Response_Type &response);

int
server_action_sleep(Response_Type &response);

int
server_action_show_certificate(Response_Type &response);

int
server_action_get_metadata(Response_Type &response);

int
server_action_get_handle(Response_Type &response);

int
server_action_send_tan_list(Response_Type &response);

int
server_action_process_pending(Response_Type &response);

int
server_action_get_user_info(Response_Type &response);

int
server_action_create_handle(Response_Type &response);

int
server_action_add_handle_value(Response_Type &response);

int
server_action_delete_handle(Response_Type &response);

int
server_action_undelete_handle(Response_Type &response);


int
server_action_delete_handle_value(Response_Type &response);

int
server_action_undelete_handle_value(Response_Type &response);

int
server_action_undelete_file(Response_Type &response);

int
server_action_delete_metadata(Response_Type &response);

int
server_action_undelete_metadata(Response_Type &response);

int
server_action_fetch_metadata(Response_Type &response);

int
server_action_generate_checksum(Response_Type &response);

int
server_action_verify_checksum(Response_Type &response);

int 
server_action_store_public_key(Response_Type &response);

int 
server_action_register_pull(Response_Type &response);

int
server_action_unknown(Response_Type &response);

@q ***** (5) @>

@q **** (4) Client action functions.  @>
@ Client action functions.
\initials{LDF 2013.05.30.}

\LOG
\initials{LDF 2013.05.30.}
Added this section.  These functions are defined in \filename{clntactn.web}.
\ENDLOG

@<|Scan_Parse_Parameter_Type| function declarations@>=

int
client_action_command_only(Response_Type &response);

int
client_action_send_file(Response_Type &response);

int
client_action_send_public_key(Response_Type &response);

int
client_action_unknown(Response_Type &response);


@q **** (4) @>
@
@<Garbage@>=

@q **** (4) @>

@q *** (3) Putting `scprpmtp.web' together.  @>

@ Putting {\tt scprpmtp\PERIOD web} together.

@q **** (4) This is what's compiled.  @>
@ This is what's compiled.
@c
@<Include files@>@;@/
using namespace std;
using namespace gwrdifpk;
class User_Info_Type;
@<External function declarations@>@;@/
@<|class Scan_Parse_Parameter_Type| declaration@>@;@/
@<Initialize |Scan_Parse_Parameter_Type| static data members@>@;@/
@<|Scan_Parse_Parameter_Type| constructor definitions@>@;
@<|Scan_Parse_Parameter_Type| destructor definition@>@;@/
@<Initialize |Scan_Parse_Parameter_Type| maps@>@;@/
@<|Scan_Parse_Parameter_Type::get_database_username| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_user| definition@>@;@/
@<|Scan_Parse_Parameter_Type::show| definition@>@;@/
@<|Scan_Parse_Parameter_Type::submit_mysql_query| definition@>@;@/
@<|Scan_Parse_Parameter_Type::send_tan_list| definition@>@;@/
@<|Scan_Parse_Parameter_Type::set_expires| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_expires| definition@>@;@/
@<|Scan_Parse_Parameter_Type::put| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get| definition@>@;@/
@<|Scan_Parse_Parameter_Type::send_to_peer| definitions@>@;@/
@<|Scan_Parse_Parameter_Type::receive_file| definition@>@;@/
@<|Scan_Parse_Parameter_Type::cd| definition@>@;@/
@<|Scan_Parse_Parameter_Type::ls| definition@>@;@/
@<|Scan_Parse_Parameter_Type::pwd| definition@>@;@/
@<|Scan_Parse_Parameter_Type::mkdir| definition@>@;@/
@<|Scan_Parse_Parameter_Type::mv| definition@>@;@/

#if 0 
@<Garbage@>@;@/
#endif 

@q **** (4) This is what's written to the header file `scprpmtp.h'.  @>

@ This is what's written to the header file \filename{scprpmtp.h}.
\initials{LDF 2012.06.27.}

@(scprpmtp.h@>=
#ifndef SCPRPMTP_H
#define SCPRPMTP_H 1
using namespace std;
using namespace gwrdifpk;
class Pull_Response_Type;
class User_Info_Type;
class X509_Cert_Type;
@<|class Scan_Parse_Parameter_Type| declaration@>@;@/
#endif 

@q * (1) Emacs-Lisp code for use in indirect buffers  @>

@q (progn (cweb-mode) (outline-minor-mode))                          @>

@q * (1) Local variables for Emacs @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q abbrev-mode:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>

 
