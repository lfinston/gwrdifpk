@q parser.web                    @>
@q [...]/gwrdifpk/src/parser.web @>

@q Created by Laurence D. Finston (LDF) Mon Jun 25 14:11:34 CEST 2012  @>

@q * (1) Copyright and License.@>

@q This file is part of gwrdifpk, a package for long-term archiving.  @>
@q Copyright (C) 2013, 2014 Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen @>

@q gwrdifpk is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q gwrdifpk is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License          @>
@q along with gwrdifpk; if not, write to the Free Software                    @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q gwrdifpk is available for downloading via Git from @>
@q https://github.com/gwdg/gwrdifpk.git    @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gwdg.de@>

@q Laurence D. Finston                                                   @>
@q Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen  @>
@q Am Fassberg 11         					         @>
@q 37077 Goettingen              					 @>
@q Germany                           					 @>                                

@q Laurence.Finston@@gwdg.de (@@ stands for a single "at" sign.)@>


@q * (1) Parser for server program gwirdsif.  @>
@* Parser for server program gwirdsif.
\initials{LDF 2012.07.10.}

@q ** (2) Include files.@>
@ Include files.

@<Include files@>=

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <limits.h>
#include <ctype.h>
#include <signal.h>

#include <algorithm>
#include <bitset>
#include <fstream>
#include <iomanip>
#include <ios>
#include <iostream>
#include <iterator>
#include <time.h>
#include <math.h>
#include <sstream>   
#include <map>
#include <vector>
#include <deque>
#include <stack>
#include <set>

#include <pthread.h>


#if HAVE_CONFIG_H
#include "config.h"
#endif

#include <gcrypt.h> /* for |gcry_control| */
#include <gnutls/gnutls.h>
#include<gnutls/x509.h>


#include <mysql.h>

#include <expat.h>

#undef NAME_LEN
#undef LOCAL_HOST

#include "rspercds.h++"
#include "glblcnst.h++"
#include "glblvrbl.h++"
#include "utilfncs.h++"
#include "grouptp.h++"
#include "hndlvltp.h++"
#include "irdsavtp.h++"
#include "pidfncs.h++" 
#include "tanfncs.h++" 
#include "parser.h++"  
#include "scanner.h++"
#include "rspnstp.h++"
#include "irdsobtp.h++"
#include "hndltype.h++"
#include "dcmdsbtp.h++"
#include "dcmtdttp.h++"
#include "x509cert.h++"
#include "dstngnmt.h++"
#include "usrinftp.h++"
#include "pullrqtp.h++"
#include "scprpmtp.h++"
#include "prsrfncs.h++"

@q ** (2) Declarations of additional functions.@>
@ Declarations of additional functions.

@<Declarations of additional functions@>=

int 
yylex(YYSTYPE* lvalp, yyscan_t parameter);

int
yywrap(void);

int
yyerror(void* v, char const* s);

@q ** (2) Options.@>
@ Options.

@<Options@>=
@=%verbose@>@;@/
@=%pure-parser@>@;@/
@=%parse-param {yyscan_t parameter}@>@;@/
@=%lex-param {yyscan_t parameter}@>@;@/
@=%debug@>

@q ** (2) |union| declaration.@>
@ {\bf union} declaration.

\LOG
\initials{LDF 2012.09.28.}
Added |unsigned int uint_value|.

\initials{LDF 2012.10.16.}
Added |unsigned int ulint_value|.

\initials{LDF 2013.04.28.}
Added |void *pointer_value|.
\ENDLOG 

@<|union| declaration@>=

@=%union {@>

  int int_value;
  unsigned int uint_value;
  unsigned long int ulint_value;
  float float_value;
  char string_value[1024];
  void *pointer_value;

@=}@>

@q ** (2) Token and type declarations.@>
@ Token and type declarations.

\LOG
\initials{LDF 2012.07.11.}
Added token declaration for |DISTINGUISHED_NAME_YY|.

\initials{LDF 2012.07.19.}
Added token declarations for |SEND_YY|, |TAN_YY|, |LIST_YY| and |PID_YY|.

\initials{LDF 2012.09.26.}
Added token declaration for |PUT_YY|.

\initials{LDF 2012.09.27.}
Added token declaration for |SENDING_YY|.

\initials{LDF 2012.09.28.}
Added the token declarations for |GENERATE_YY|, |INSTITUTE_YY| and |SUFFIX_YY|.

\initials{LDF 2012.10.08.}
Added the token declaration for |PREFIX_YY|.

\initials{LDF 2012.10.12.}
Added the token declarations for |HANDLE_YY|, |HANDLES_YY|, |HANDLE_VALUE_YY|
and |HANDLE_VALUES_YY|.

\initials{LDF 2012.10.16.}
Added token declarations for |UNSIGNED_INTEGER_YY| and |UNSIGNED_LONG_INTEGER_YY|.

\initials{LDF 2012.11.19.}
Added the token declaration for |LOCAL_FILENAME_YY|.

\initials{LDF 2012.11.21.}
Added the token declaration for |REMOTE_FILENAME_YY|.

\initials{LDF 2012.11.22.}
Added token declaration for |REFERENCE_YY|.

\initials{LDF 2012.12.14.}
Added token declaration for |ADD_YY|.

\initials{LDF 2012.12.31.}
Added token declarations for |OUTPUT_YY| and |FORCE_YY|.

\initials{LDF 2013.02.28.}
Added token declaration for |STORE_YY|.

\initials{LDF 2013.03.06.}
Added token declarations for |FORCE_ADD_YY|, |FORCE_PUT_YY|, 
|FORCE_STORE_YY| and |FORCE_ALL_YY|.

\initials{LDF 2013.04.03.}
Added token declarations for |END_SERVER_YY|.

\initials{LDF 2013.04.05.}
Added token declaration for |DUMMY_STATEMENT_YY|.

\initials{LDF 2013.04.19.}
Added token declarations for |SLEEP_YY|, |SERVER_YY| and |RESPONSE_YY|.

\initials{LDF 2013.05.02.}
Added token declaration for |SIGNAL_YY|.

\initials{LDF 2013.05.03.}
Added token declarations for |CERTIFICATE_YY|, |CERTIFICATES_YY|, |FOR_YY| 
and |ALL_YY|.

\initials{LDF 2013.05.17.}
Added token declaration for |WHOAMI_YY|.

\initials{LDF 2013.05.19.}
Added token declaration for |GET_USER_INFO_YY|.

\initials{LDF 2013.05.23.}
Added token declarations for |PROCESS_YY|, |PENDING_YY| and |OPERATIONS_YY|.

\initials{LDF 2013.05.24.}
Added token declarations for |DELAY_YY| and |NO_DELAY_YY|.

\initials{LDF 2013.06.04.}
Added token declarations for |GROUP_YY| and |GROUPS_YY|.

\initials{LDF 2013.06.16.}
Added token declarations for |IDX_YY|, |TYPE_YY| and |DATA_YY|.

\initials{LDF 2013.07.04.}
Added token declarations for |UNDELETE_YY|, |DELETION_YY|, |MARK_YY| and |UNMARK_YY|.

\initials{LDF 2013.07.04.}
Added token declaration for |IMMEDIATE_YY|.

\initials{LDF 2013.08.07.}
Added token declarations for |EQUALS_YY| and |TIME_SPECIFICATION_YY|.

\initials{LDF 2013.08.09.}
Added token declarations for |DATABASE_YY| and |DATABASE_ONLY_YY|.

\initials{LDF 2013.08.30.}
Added token declaration for |HANDLE_VALUE_SPECIFICATION_YY|.

\initials{LDF 2013.10.31.}
Added token declaration for |FILE_ONLY_YY|.

\initials{LDF 2013.11.27.}
Added token declaration for |SAVE_DB_ENTRY_YY|.

\initials{LDF 2013.12.09.}
Added token declaration for |FULL_YY|.

\initials{LDF 2013.12.19.}
Added token declaration for |NO_STORE_YY|.

\initials{LDF 2013.12.19.}
Added token declaration for |MV_YY|.

\initials{LDF 2013.12.24.}
Added token declarations for 
|CHECKSUM_YY|, 
|VERIFY_YY|,
|MD5_YY|,
|SHA1_YY|,
|SHA224_YY|,
|SHA256_YY|,
|SHA384_YY|
and
|SHA512_YY|.

\initials{LDF 2013.12.25.}
Added token declaration for |NO_HANDLE_YY|.

\initials{LDF 2014.01.02.}
Added token declarations for |CHECK_YY| and |NO_CHECK_YY|.

\initials{LDF 2014.01.07.}
Added the following token declarations:
|ENCRYPT_YY|,
|DECRYPT_YY|,
|SIGN_YY|,
|CLEARSIGN_YY|,
|DETACHED_YY|,
|SIGNATURE_YY|
and
|VERIFY_SIGNATURE_YY|.

\initials{LDF 2014.01.09.}
Added the token declaration for |PUBLIC_KEY_ID_YY|.

\initials{LDF 2014.01.10.}
Changed the name of the token |PUBLIC_KEY_ID_YY| to |GPG_KEY_ID_YY|.

\initials{LDF 2014.01.13.}
Changed the name of the token |GPG_KEY_ID_YY| to |GPG_KEY_FINGERPRINT_YY|.

\initials{LDF 2014.01.21.}
Added token declarations for |STORE_SIGNATURE_YY| and |PUBLIC_KEY_YY|.

\initials{LDF 2014.01.23.}
Added token declarations for |COMPRESS_YY|, |COMPRESSED_TAR_FILE_YY|,
|GZIP_YY| and |BZIP2_YY|.

\initials{LDF 2014.01.24.}
Added token declaration for |EXPAND_YY|.

\initials{LDF 2014.01.31.}
Added token declarations for |PULL_YY| and |REGISTER_YY|.

\initials{LDF 2014.02.01.}
Added token declarations for |HOSTNAME_YY| and |IP_ADDRESS_YY|.

\initials{LDF 2014.02.03.}
Added token declaration for |USERNAME_YY|.

\initials{LDF 2014.02.12.}
Added token declaration for |INTERVAL_YY|.

\initials{LDF 2014.02.14.}
Added token declarations for |PORT_YY| and |REQUEST_YY|.
\ENDLOG 

@q *** (3) Code @>

@<Token and type declarations@>=

%token<int_value>    EQUALS_YY@;@/

%token<int_value>    INTEGER_YY@;@/
%token<uint_value>   UNSIGNED_INTEGER_YY@;@/
%token<ulint_value>  UNSIGNED_LONG_INTEGER_YY@;@/

%token<ulint_value>  TIME_SPECIFICATION_YY@;@/

%token<string_value> HANDLE_VALUE_SPECIFICATION_YY

%token<int_value>    ADD_YY@;@/
%token<int_value>    ALL_YY@;@/
%token<int_value>    FULL_YY@;@/
%token<int_value>    CLIENT_YY@;@/
%token<int_value>    END_YY@;@/
%token<int_value>    FILE_YY@;@/
%token<int_value>    FILE_ONLY_YY@;@/
%token<int_value>    SAVE_DB_ENTRY_YY@;@/
%token<int_value>    FINISHED_YY@;@/
%token<int_value>    FOR_YY@;@/
%token<int_value>    INFO_YY@;@/
%token<int_value>    LOCAL_YY@;@/
%token<int_value>    READ_YY@;@/
%token<int_value>    REMOTE_YY@;@/
%token<int_value>    RESPONSE_YY@;@/
%token<int_value>    SENDING_YY@;@/
%token<int_value>    SEND_YY@;@/
%token<int_value>    SERVER_YY@;@/
%token<int_value>    SIGNAL_YY@;@/
%token<int_value>    SLEEP_YY@;@/
%token<int_value>    TO_YY@;@/
%token<int_value>    USER_YY@;@/
%token<int_value>    USERNAME_YY@;@/
%token<int_value>    WRITE_YY@;@/
%token<int_value>    END_SERVER_YY@;@/
%token<int_value>    DUMMY_STATEMENT_YY@;@/
%token<int_value>    DELAY_YY@;@/
%token<int_value>    NO_DELAY_YY@;@/

%token<int_value>    DATABASE_YY@;@/
%token<int_value>    DATABASE_ONLY_YY@;@/

%token<int_value>    FORCE_YY@;@/
%token<int_value>    FORCE_ADD_YY@;@/
%token<int_value>    FORCE_PUT_YY@;@/
%token<int_value>    FORCE_STORE_YY@;@/
%token<int_value>    FORCE_ALL_YY@;@/
%token<int_value>    STORE_YY@;@/
%token<int_value>    NO_STORE_YY@;@/

%token<string_value> LOCAL_FILENAME_YY@;@/
%token<string_value> REMOTE_FILENAME_YY@;@/
%token<int_value>    DIRECTORY_YY@;@/

%token<int_value>    MKDIR_YY@;@/
%token<int_value>    RM_YY@;@/
%token<int_value>    CREATE_YY@;@/
%token<int_value>    DELETE_YY@;@/
%token<int_value>    UNDELETE_YY@;@/
%token<int_value>    DELETION_YY@;@/

%token<int_value>    IMMEDIATE_YY@;@/

%token<int_value>    MARK_YY@;@/
%token<int_value>    UNMARK_YY@;@/

%token<int_value>    COPY_YY@;@/
%token<int_value>    MOVE_YY@;@/
%token<int_value>    RENAME_YY@;@/
%token<int_value>    CHMOD_YY@;@/
%token<int_value>    CHOWN_YY@;@/
%token<int_value>    SHOW_YY@;@/

%token<int_value>    PWD_YY@;@/
%token<int_value>    CD_YY@;@/
%token<int_value>    METADATA_YY@;@/
%token<int_value>    OUTPUT_YY@;@/
%token<int_value>    URI_YY@;@/
%token<int_value>    PASSWORD_YY@;@/
%token<int_value>    SU_YY@;@/
%token<int_value>    SET_YY@;@/
%token<int_value>    GET_YY@;@/
%token<int_value>    PUT_YY@;@/
%token<string_value> FLAG_YY@;@/
%token<int_value>    SESSION_YY@;@/
%token<int_value>    LS_YY@;@/
%token<int_value>    MV_YY@;@/
%token<int_value>    REPOSITORY_YY@;@/
%token<int_value>    CONNECT_YY@;@/
%token<int_value>    DISCONNECT_YY@;@/
%token<int_value>    CONNECTION_YY@;@/
%token<int_value>    RESET_YY@;@/
%token<int_value>    DISTINGUISHED_NAME_YY@;@/
%token<string_value> STRING_YY@;@/

%token<int_value> REFERENCE_YY@;@/
%token<int_value> TAN_YY@;@/
%token<int_value> LIST_YY@;@/

%token<int_value> HANDLE_YY@;@/
%token<int_value> HANDLES_YY@;@/

%token<int_value> HANDLE_VALUE_YY@;@/
%token<int_value> HANDLE_VALUES_YY@;@/

%token<uint_value> NO_HANDLE_YY@;@/

%token<int_value> PID_YY@;@/
%token<int_value> PIDS_YY@;@/
%token<int_value> IDX_YY@;@/
%token<int_value> TYPE_YY@;@/
%token<int_value> DATA_YY@;@/

%token<int_value> GENERATE_YY@;@/
%token<int_value> INSTITUTE_YY@;@/
%token<int_value> PREFIX_YY@;@/
%token<int_value> SUFFIX_YY@;@/

%token<int_value> CERTIFICATE_YY@;@/
%token<int_value> CERTIFICATES_YY@;@/

%token<int_value> WHOAMI_YY@;@/

%token<int_value> PROCESS_YY@;@/
%token<int_value> PENDING_YY@;@/
%token<int_value> OPERATIONS_YY@;@/

%token<int_value> GET_USER_INFO_YY@;@/

%token<int_value> GROUP_YY@;@/
%token<int_value> GROUPS_YY@;@/

%token<int_value> CHECK_YY;@/
%token<int_value> NO_CHECK_YY;@/

%token<int_value> CHECKSUM_YY;@/
%token<int_value> VERIFY_YY;@/
%token<int_value> MD5_YY;@/
%token<int_value> SHA1_YY;@/
%token<int_value> SHA224_YY;@/
%token<int_value> SHA256_YY;@/
%token<int_value> SHA384_YY;@/
%token<int_value> SHA512_YY;@/

%token<int_value> ENCRYPT_YY;@/
%token<int_value> DECRYPT_YY;@/
%token<int_value> SIGN_YY;@/
%token<int_value> CLEARSIGN_YY;@/
%token<int_value> DETACHED_YY;@/
%token<int_value> SIGNATURE_YY;@/
%token<int_value> VERIFY_SIGNATURE_YY;@/
%token<int_value> GPG_KEY_FINGERPRINT_YY;@/
%token<int_value> STORE_SIGNATURE_YY;@/

%token<int_value> PUBLIC_KEY_YY@;@/

%token<int_value> COMPRESS_YY@;@/
%token<int_value> COMPRESSED_TAR_FILE_YY@;@/
%token<int_value> GZIP_YY@;@/
%token<int_value> BZIP2_YY@;@/
%token<int_value> EXPAND_YY@;@/

%token<int_value> PULL_YY@;@/
%token<int_value> REGISTER_YY@;@/
%token<int_value> INTERVAL_YY
%token<int_value> REQUEST_YY

%token<int_value> HOSTNAME_YY@;@/
%token<int_value> IP_ADDRESS_YY@;@/
%token<int_value> PORT_YY@;@/

@q *** (3) Punctuation characters.  @>

@ Punctuation characters.  
\initials{LDF 2013.04.25.}

\LOG
\initials{LDF 2013.04.25.}
Added this section with the token declarations for \.{ASTERISK\_YY}, \.{TILDE\_YY} 
and \.{DOLLAR\_YY}.
\ENDLOG

@<Token and type declarations@>=

@q *** (3) @>

%token<int_value> ASTERISK_YY@;@/
%token<int_value> TILDE_YY@;@/
%token<int_value> DOLLAR_YY@;@/

@q ** (2) Rules.  @>
@ Rules.

@<Rules@>=

@q *** (3) Program.  @>
@ Program.

@<Rules@>=


@=program: statement_list END_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "]  In `yyparse', rule "
             << "`program: statement_list END_YY'." 
             << endl
             << "Exiting `yyparse' with return value 0."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

  
    return 0;

};

@q *** (3) statement_list.  @>
@ \<statement list>.
\initials{LDF 2012.06.25.}

@q **** (4) statement_list --> EMPTY.  @>

@ \<statement list> $\longrightarrow$ \.{EMPTY}.  
This rule ensures that an empty file won't cause an error.
\initials{LDF 2012.06.25.}

@<Rules@>=

@=statement_list: /* Empty  */  @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "]  In `yyparse', rule "
             << "`statement_list: /* Empty */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

};

@q **** (4) statement_list --> statement_list statement.  @>

@ \<statement list> $\longrightarrow$ \<statement>.
\initials{LDF 2012.06.25.}

@<Rules@>=

@=statement_list: statement_list statement @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] statement_list: statement_list statement" 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

};

@q *** (3) Statement.  @>
@ Statement.
\initials{LDF 2012.06.25.}

@q **** (4) statement --> END_SERVER_YY  @>

@ \<statement> $\longrightarrow$ \.{END\_SERVER\_YY}.
\initials{LDF 2013.04.03.}

@^profiling@> 
This rule is needed for profiling the server program \.{gwirdsif}.  The latter is a 
d{\ae}mon process and in normal operation is not intended to exit.  However, it must 
exit in order for profiling information to be generated.  
\par
This command is disabled by default and enabled by using the \.{--end-server-enable} 
option.
\initials{LDF 2013.04.03.}

\LOG
\initials{LDF 2013.04.03.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: END_SERVER_YY@>
{
@q ***** (5) @>

     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] statement: END_SERVER_YY" 
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif  /* |DEBUG_COMPILE|  */ 

     Response_Type response;

     if (end_server_enabled)
     {
          response.type = Response_Type::END_SERVER_TYPE;

     }  /*  |if (end_server_enabled)|  */
     else
     {
          response.type = Response_Type::COMMAND_ONLY_TYPE;
          response.command = "END_SERVER RESPONSE 1";
     }

     param->response_deque.push_back(response);

@q ***** (5) @>

};

@q **** (4) statement --> DISTINGUISHED_NAME_YY STRING_YY  @>

@ \<statement> $\longrightarrow$ \.{DISTINGUISHED\_NAME\_YY} \.{STRING\_YY}.
\initials{LDF 2012.07.11.}

\LOG
\initials{LDF 2012.07.11.}
Added this rule.

\initials{LDF 2013.05.16.}
Added code for testing whether the current user has the ``show distinguished names''
privilege.  If it does, the distinguished name data are sent to the client.  Otherwise,
an error message is sent.

\initials{LDF 2013.05.22.}
Removed code from this rule to |distinguished_name_rule_func|, which is defined in 
\filename{prsrfncs.web}.
\ENDLOG

@<Rules@>=

@=statement: DISTINGUISHED_NAME_YY STRING_YY@>
{
@q ***** (5) @>

     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

     bool save_PARSER_DEBUG = param->PARSER_DEBUG;
     param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`statement: DISTINGUISHED_NAME_YY STRING_YY'." 
              << endl
              << "`STRING_YY' == " << @=$2@> << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

     status = distinguished_name_rule_func(param, @=$2@>);

     if (status == 2)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] ERROR!  In `yyparse', rule "
              << "`statement: DISTINGUISHED_NAME_YY STRING_YY':" 
              << endl
              << "`distinguished_name_rule_func' failed, returning 2 (authentication error)."
              << endl
              << "Exiting `yyparse' unsuccessfully with return value 2."
              << endl;
         unlock_cerr_mutex(); 

         ++param->errors_occurred;

         return 2;

     }

     else if (status != 0)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] ERROR!  In `yyparse', rule "
              << "`statement: DISTINGUISHED_NAME_YY STRING_YY':" 
              << endl
              << "`distinguished_name_rule_func' failed, returning " << status << "."
              << endl
              << "Continuing."
              << endl;
         unlock_cerr_mutex(); 

         ++param->errors_occurred;

     }  /* |else if (status != 0)|  */

#if DEBUG_COMPILE 
     else if (param->PARSER_DEBUG)
     {

         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`statement: DISTINGUISHED_NAME_YY STRING_YY':" 
              << endl
              << "`distinguished_name_rule_func' succeeded, returning 0."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */


@q ***** (5) @>

};

@q **** (4) statement --> WHOAMI_YY  @>

@ \<statement> $\longrightarrow$ \.{WHOAMI\_YY}.
\initials{LDF 2013.05.17.}

\LOG
\initials{LDF 2013.05.17.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: WHOAMI_YY@>
{
@q ***** (5) @>

     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

     bool save_PARSER_DEBUG = param->PARSER_DEBUG;
     param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] "
              << "In `yyparse', rule `statement: WHOAMI_YY'." 
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

     Response_Type response;

     response.type = Response_Type::COMMAND_ONLY_TYPE;

     temp_strm.str("");

     temp_strm << "WHOAMI RESPONSE 0 USER_ID " << param->user_id << "U "
               << "USER_NAME \"" << param->username << "\"";

     if (param->user_cert.serialNumber > 0)
     {
          temp_strm << " COMMON_NAME \"" << param->user_cert.commonName << "\"";
     }

     response.command = temp_strm.str();

     temp_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] "
              << "In `yyparse', rule `statement: WHOAMI_YY':" 
              << endl
              << "`response.command' == "
              << endl
              << response.command
              << endl;

         param->show("*param:");

         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif  /* |DEBUG_COMPILE|  */ 

     param->response_deque.push_back(response);

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q **** (4) statement --> GET_USER_INFO_YY delay_option  @>

@ \<statement> $\longrightarrow$ \.{GET\_USER\_INFO\_YY} \<delay option>.
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this rule.

\initials{LDF 2013.05.24.}
Added \<delay option>.
\ENDLOG

@<Rules@>=

@=statement: GET_USER_INFO_YY delay_option @>
{
@q ***** (5) @>

     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

     bool save_PARSER_DEBUG = param->PARSER_DEBUG;
     param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] "
              << "In `yyparse', rule `statement: GET_USER_INFO_YY delay_option'." 
              << endl
              << "`delay_option' == " << @=$2@>
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

     if (@=$2@> == 0)  /* No delay  */
     {
         status = get_user_info_func(param);

         if (status != 0)
         {
             lock_cerr_mutex(); 
             cerr << "[Thread " << param->thread_ctr << "] "
                  << "ERROR!  In `yyparse', rule `statement: GET_USER_INFO_YY delay_option':" 
                  << endl
                  << "`get_user_info_func' failed, returning " << status << "."
                  << endl;
             unlock_cerr_mutex(); 

             ++param->errors_occurred;

         }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
         else if (param->PARSER_DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "[Thread " << param->thread_ctr << "] "
                  << "In `yyparse', rule `statement: GET_USER_INFO_YY delay_option':" 
                  << endl
                  << "`get_user_info_func' succeeded, returning 0."
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

     }  /* |if (@=$2@> == 0)| (No delay)  */

@q ***** (5) @>

     else  /* Delay  */
     {
         Response_Type response;
         response.type = Response_Type::GET_USER_INFO_TYPE;

         param->delayed_response_deque.push_back(response);

     }  /* |else| (Delay)  */

@q ***** (5) @>

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q **** (4) statement --> GET_USER_INFO_YY STRING_YY delay_option @>

@ \<statement> $\longrightarrow$ \.{GET\_USER\_INFO\_YY} \.{STRING\_YY}
\<delay option>.
\initials{LDF 2013.05.19.}

\LOG
\initials{LDF 2013.05.19.}
Added this rule.

\initials{LDF 2013.05.22.}
Removed code from this rule to |get_user_info_func|, which is defined 
in \filename{prsrfncs.web}.

\initials{LDF 2013.05.24.}
Added \<delay option>.
\ENDLOG

@<Rules@>=

@=statement: GET_USER_INFO_YY STRING_YY delay_option @>
{
@q ***** (5) @>

     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

     bool save_PARSER_DEBUG = param->PARSER_DEBUG;
     param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] "
              << "In `yyparse', rule `statement: GET_USER_INFO_YY STRING_YY delay_option'." 
              << endl
              << "`delay_option' == " << @=$3@>
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

     if (@=$3@> == 0)  /* No delay  */
     {

         status = get_user_info_func(param, @=$2@>);

         if (status != 0)
         {
             lock_cerr_mutex(); 
             cerr << "[Thread " << param->thread_ctr << "] "
                  << "ERROR!  In `yyparse', rule `statement: "
                  << "GET_USER_INFO_YY STRING_YY delay_option':" 
                  << endl
                  << "`get_user_info_func' failed, returning " << status << "."
                  << endl;
             unlock_cerr_mutex(); 

             ++param->errors_occurred;

         }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
         else if (param->PARSER_DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "[Thread " << param->thread_ctr << "] "
                  << "In `yyparse', rule `statement: GET_USER_INFO_YY STRING_YY delay_option':" 
                  << endl
                  << "`get_user_info_func' succeeded, returning 0."
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
 
     }  /* |if (@=$3@> == 0)| (No delay)  */

@q ***** (5) @>

     else  /* Delay  */
     {
         Response_Type response;
         response.type = Response_Type::GET_USER_INFO_TYPE;
         response.string_val = @=$2@>;

         param->delayed_response_deque.push_back(response);

     }  /* |else| (Delay)  */


@q ***** (5) @>

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q **** (4) delay_option and sub_delay_option.  @>

@ \<delay option> and \<sub-delay option>.
\initials{LDF Undated.}

\LOG
\initials{LDF 2013.08.07.}
Changed the type of \<delay option> from |int_value| to |ulint_value|.

\initials{LDF 2013.08.26.}
Added type declaration for \<sub-delay option>.
\ENDLOG

@<Token and type declarations@>=

@=%type <ulint_value> delay_option @>
@=%type <ulint_value> sub_delay_option @>

@q ***** (5) delay_option: /* Empty  */ @>
@ \<delay option> $\longrightarrow$  \.{Empty}.
\initials{LDF 2013.05.24.}

\LOG
\initials{LDF 2013.05.24.}
Added this rule.
\ENDLOG

@<Rules@>=
@=delay_option: /* Empty  */ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`delay_option: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->delay_value = @=$$@> = 0UL;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) delay_option: sub_delay_option @>
@ \<delay option> $\longrightarrow$  \<sub-delay option>
\initials{LDF 2013.08.26.}

\LOG
\initials{LDF 2013.08.26.}
Added this rule.
\ENDLOG

@<Rules@>=
@=delay_option: sub_delay_option @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`delay_option: sub_delay_option'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) sub_delay_option: DELAY_YY @>
@ \<sub-delay option> $\longrightarrow$  \.{DELAY\_YY}.
\initials{LDF 2013.05.24.}

\LOG
\initials{LDF 2013.05.24.}
Added this rule.
\ENDLOG

@<Rules@>=
@=sub_delay_option: DELAY_YY @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`sub_delay_option: DELAY_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->delay_value = @=$$@> = 1UL;
    
#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`sub_delay_option: DELAY_YY':" 
             << endl
             << "$$ == " << @=$$@>
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) sub_delay_option: DELAY_YY INTEGER_YY @>
@ \<sub-delay option> $\longrightarrow$  \.{DELAY\_YY} \.{INTEGER\_YY}.
\initials{LDF 2013.08.07.}

\LOG
\initials{LDF 2013.08.07.}
Added this rule.
\ENDLOG

@<Rules@>=
@=sub_delay_option: DELAY_YY INTEGER_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`sub_delay_option: DELAY_YY INTEGER_YY'." 
             << endl
             << "`INTEGER_YY' ($2) == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

    if (@=$2@> == 1)
    {

         temp_strm.str("");
         temp_strm << "DELAY OPTION RESPONSE 2 \"WARNING!  Argument 1 used.\\n"
                   << "This value is used to indicate that the default delay "
                   << "amount should be used.\\n"
                   << "It is not currently possible to specify "
                   << "a delay of one second.\"";

         response.command = temp_strm.str();

         param->response_deque.push_back(response);

         param->delay_value = @=$$@> = 1UL;

    }
    else if (@=$2@> > 1)
       param->delay_value = @=$$@> = static_cast<unsigned long int>(@=$2@>); 
    else 
    {
         temp_strm.str("");
         temp_strm << "DELAY OPTION RESPONSE 2 \"WARNING!  Invalid argument " 
                   << @=$2@> << " used.  "
                   << "Will use default delay amount.\"";

         response.command = temp_strm.str();

         param->response_deque.push_back(response);


       param->delay_value = @=$$@> = 1UL;
    }

    
    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) sub_delay_option: DELAY_YY EQUALS_YY INTEGER_YY @>
@ \<sub-delay option> $\longrightarrow$  \.{DELAY\_YY} \.{EQUALS\_YY} 
\.{INTEGER\_YY}.
\initials{LDF 2013.08.07.}

\LOG
\initials{LDF 2013.08.07.}
Added this rule.
\ENDLOG

@<Rules@>=
@=sub_delay_option: DELAY_YY EQUALS_YY INTEGER_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`sub_delay_option: DELAY_YY EQUALS_YY INTEGER_YY'." 
             << endl
             << "`INTEGER_YY' ($3) == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

    if (@=$3@> == 1)
    {

         temp_strm.str("");
         temp_strm << "DELAY OPTION RESPONSE 2 \"WARNING!  Argument 1 used.\\n"
                   << "This value is used to indicate that the default delay "
                   << "amount should be used.\\nIt is not currently possible to specify "
                   << "a delay of one second.\"";

         response.command = temp_strm.str();

         param->response_deque.push_back(response);

         param->delay_value = @=$$@> = 1UL;

    }
    else if (@=$3@> > 1)
       param->delay_value = @=$$@> = static_cast<unsigned long int>(@=$3@>); 
    else 
    {
         temp_strm.str("");
         temp_strm << "DELAY OPTION RESPONSE 2 \"WARNING!  Invalid argument " 
                   << @=$3@> << " used.  "
                   << "Will use default delay amount.\"";

         response.command = temp_strm.str();

         param->response_deque.push_back(response);


       param->delay_value = @=$$@> = 1UL;
    }
    
    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) sub_delay_option: DELAY_YY TIME_SPECIFICATION_YY @>
@ \<sub-delay option> $\longrightarrow$  \.{DELAY\_YY} \.{TIME\_SPECIFICATION\_YY}.
\initials{LDF 2013.08.07.}

\LOG
\initials{LDF 2013.08.07.}
Added this rule.
\ENDLOG

@<Rules@>=
@=sub_delay_option: DELAY_YY TIME_SPECIFICATION_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`sub_delay_option: DELAY_YY TIME_SPECIFICATION_YY'." 
             << endl
             << "`TIME_SPECIFICATION_YY' ($2) == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    if (@=$2@> > 0 && @=$2@> < ULONG_MAX)
       param->delay_value = @=$$@> = @=$2@>;  
    else
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] WARNING!  In `yyparse', rule "
             << "`sub_delay_option: DELAY_YY TIME_SPECIFICATION_YY':" 
             << endl
             << "`TIME_SPECIFICATION_YY' == 0 or `ULONG_MAX'."
             << endl
             << "Invalid time specification."
             << endl 
             << "Setting value of rule (`sub_delay_option') to 1UL and will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        ++param->warnings_occurred; 

        param->delay_value = @=$$@> = 1UL;

    }  /* |else|  */
    
    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) sub_delay_option: DELAY_YY EQUALS_YY TIME_SPECIFICATION_YY @>
@ \<sub-delay option> $\longrightarrow$  \.{DELAY\_YY} \.{EQUALS\_YY} 
\.{TIME\_SPECIFICATION\_YY}.
\initials{LDF 2013.08.07.}

\LOG
\initials{LDF 2013.08.07.}
Added this rule.
\ENDLOG

@<Rules@>=
@=sub_delay_option: DELAY_YY EQUALS_YY TIME_SPECIFICATION_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`sub_delay_option: DELAY_YY EQUALS_YY TIME_SPECIFICATION_YY'." 
             << endl
             << "`TIME_SPECIFICATION_YY' ($3) == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    if (@=$3@> > 0 && @=$3@> < ULONG_MAX)
       param->delay_value = @=$$@> = @=$3@>;  
    else
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] WARNING!  In `yyparse', rule "
             << "`sub_delay_option: DELAY_YY TIME_SPECIFICATION_YY':" 
             << endl
             << "`TIME_SPECIFICATION_YY' == 0 or `ULONG_MAX'."
             << endl
             << "Invalid time specification."
             << endl 
             << "Setting value of rule (`sub_delay_option') to 1UL and will try to continue."
             << endl;
        unlock_cerr_mutex(); 

        ++param->warnings_occurred; 

        param->delay_value = @=$$@> = 1UL;

    }  /* |else|  */

    
    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) sub_delay_option: NO_DELAY_YY @>
@ \<sub-delay option> $\longrightarrow$  \.{NO\_DELAY\_YY}.
\initials{LDF 2013.05.24.}

\LOG
\initials{LDF 2013.05.24.}
Added this rule.
\ENDLOG

@<Rules@>=
@=sub_delay_option: NO_DELAY_YY @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`sub_delay_option: NO_DELAY_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->delay_value = @=$$@> = 0UL;
    
    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};



@q **** (4) statement: PWD_YY  @>
@ \<statement> $\longrightarrow$ \.{PWD\_YY}.
\initials{LDF 2012.07.04.}

\LOG
\initials{LDF 2012.07.04.}
Added this rule.

\initials{LDF 2013.02.05.}
Removed code for the cases |jargon_trunk == true| and |jargon_core == true|.  
Not currently using either of the Jargon APIs.

\initials{LDF 2013.04.03.}
Removed code from this rule.  Now pushing a |Response_Type| object with 
|type == Response_Type::PWD_TYPE| onto |param->response_deque|.  This makes it
possible to have pending operations performed before processing the response created
by this rule.  Previously, the \.{ipwd} command was executed immediately.
\ENDLOG

@<Rules@>=

@=statement: PWD_YY @>
{
@q ***** (5) @>

     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));


#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] statement: PWD_YY" << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif  /* |DEBUG_COMPILE|  */ 

     Response_Type response;
     response.type = Response_Type::PWD_TYPE;

     param->response_deque.push_back(response);

@q ***** (5) @>

};

@q **** (4) statement --> LS_YY flags_optional string_list_optional delay_option @>

@ \<statement> $\longrightarrow$ \.{LS\_YY} \<string list optional> \<delay option>.
\initials{LDF 2012.07.04.}

\LOG
\initials{LDF 2012.07.04.}
Added this rule.

\initials{LDF 2012.09.11.}
Added code for calling |lsUtil|.

\initials{LDF 2012.11.27.}
Removed code.  Now creating a |Response_Type| object of type |Response_Type::LS_TYPE| and
pushing it onto |param->response_deque|.  This is necessary to ensure that commands like 
\.{mkdir}, \.{put}, etc., that change the directory structure are executed first.

\initials{LDF 2013.04.25.}
Added \<flags optional > and \<string list optional>.

\initials{LDF 2013.05.24.}
Added \<delay option>.
\ENDLOG

@<Rules@>=

@=statement: LS_YY flags_optional string_list_optional delay_option @>
{

    Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse':  "
             << "Rule `statement: LS_YY flags_optional string_list_optional delay_option'." 
             << endl
             << "flags_optional == " << @=$2@> << endl
             << "delay_option ==   " << @=$4@> << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */       
#endif  /* |DEBUG_COMPILE|  */ 
   
    Response_Type response;
    response.type = Response_Type::LS_TYPE;

    response.string_vector = param->string_vector;

    response.flags = @=$2@>;

    if (@=$4@> == -1)
       response.no_delay = 1;

    param->string_vector.clear();

    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q **** (4) string_list_optional  @>
@ \<string list optional>.
\initials{LDF 2013.04.25.}

\LOG
\initials{LDF 2013.04.25.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> string_list_optional@>

@q ***** (5) string_list_optional: /* Empty  */@>

@ \<string list optional> $\longrightarrow$ \.{Empty}.
\initials{LDF 2013.04.25.}

\LOG
\initials{LDF 2013.04.25.}
Added this rule.
\ENDLOG

@<Rules@>=

@=string_list_optional: /* Empty  */ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`string_list_optional: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


    param->string_vector.clear();

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) string_list_optional: string_list_optional STRING_YY  @>

@ \<string list optional> $\longrightarrow$ \<string list optional> \.{STRING\_YY}.
\initials{LDF 2013.04.25.}

\LOG
\initials{LDF 2013.04.25.}
Added this rule.
\ENDLOG

@<Rules@>=

@=string_list_optional: string_list_optional STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`string_list_optional: string_list_optional STRING_YY'." 
             << endl
             << "`STRING_YY' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->string_vector.push_back(string(@=$2@>));

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> MV_YY flags_optional STRING_YY STRING_YY mv_option_list @>

@ \<statement> $\longrightarrow$ \.{MV\_YY} \<flags optional> 
\.{STRING\_YY} \.{STRING\_YY} \<mv option list>.
\initials{LDF 2013.12.19.}

\LOG
\initials{LDF 2013.12.19.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: MV_YY flags_optional STRING_YY STRING_YY mv_option_list @>
{
    Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse':  "
             << "Rule `statement: MV_YY flags_optional STRING_YY STRING_YY mv_option_list':" 
             << endl
             << "`STRING_YY'      (3) (Old filename) == " << @=$3@>
             << endl
             << "`STRING_YY'      (4) (New filename) == " << @=$4@>
             << endl
             << "`flags_optional' (2) (flags)        == " << @=$2@>
             << endl
             << "`mv_option_list' (5) (Options)      == " << @=$5@> << " == " 
             << oct << @=$5@> << " (octal)" << dec
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */       
#endif  /* |DEBUG_COMPILE|  */ 
   
    Response_Type response;
    response.type = Response_Type::PROCESS_PENDING_TYPE;
    param->response_deque.push_back(response);

    response.type = Response_Type::MV_TYPE;
    response.flags = @=$2@>;
    response.string_vector.push_back(@=$3@>);
    response.string_vector.push_back(@=$4@>);
    response.options = @=$5@>; 

    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};


@q **** (4) mv_option_list.  @>
@ \<mv option list>.
\initials{LDF 2013.12.19.}

\LOG
\initials{LDF 2013.12.19.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> mv_option_list@>


@q ***** (5) mv_option_list: /* Empty */ @>

@ \<mv option list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2013.12.19.}

\LOG
\initials{LDF 2013.12.19.}
Added this rule.
\ENDLOG

@<Rules@>=
@=mv_option_list: /* Empty */@>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`mv_option_list: /* Empty */'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 
 
    @=$$@> = 0U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};



@q **** (4) statement --> MKDIR_YY flags_optional filename_list @>

@ \<statement> $\longrightarrow$ \.{MKDIR\_YY} \<flags optional> \<filename list>.
\initials{LDF 2012.06.25.}

\LOG
\initials{LDF 2012.06.25.}
Added this rule.

\initials{LDF 2012.11.29.}
Added \<flags optional>.  Replaced \.{STRING\_YY} with \<filename list>.
\ENDLOG

@<Rules@>=

@=statement: MKDIR_YY flags_optional filename_list @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`statement: MKDIR_YY flags_optional filename_list':" 
             << endl
             << "`flags_optional' == " << @=$2@>
             << endl
             << "`param->filename_vector':"
             << endl;

        for (vector<string>::const_iterator iter = param->filename_vector.begin();
             iter != param->filename_vector.end();
             ++iter)
        {
             cerr << *iter << endl;
            
        }  /* |for|  */

        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 
    
    Response_Type response;
    response.type = Response_Type::MKDIR_TYPE;
    response.flags = @=$2@>;
    response.string_vector = param->filename_vector;

    param->filename_vector.clear();

    param->response_deque.push_back(response);


};

@q **** (4) statement --> RM_YY flags_optional rm_option_list filename_list @>

@ \<statement> $\longrightarrow$ \.{RM\_YY} \<flags optional> 
\<rm option list> \<filename list>.
\initials{LDF 2012.06.26.}

\LOG
\initials{LDF 2012.11.30.}
Changed \.{STRING\_YY} to \<filename list>.  Added \<flags optional>.
\ENDLOG 

@<Rules@>=

@=statement: RM_YY flags_optional rm_option_list filename_list @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`statement: RM_YY flags_optional rm_option_list filename_list':"
             << endl
             << "`flags_optional' ($2) == " << @=$2@>
             << endl 
             << "`rm_option_list' ($3) == " << oct << "0" << @=$3@> << " (octal) " << dec
             << endl 
             << "`param->delay_value' == " << param->delay_value
             << endl 
             << "`filename_vector' == " 
             << endl;

        for (vector<string>::const_iterator iter = param->filename_vector.begin();
             iter != param->filename_vector.end();
             ++iter)
        {
            cerr << *iter << endl;    
        }

        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;
    Response_Type process_pending_response;

    process_pending_response.type = Response_Type::PROCESS_PENDING_TYPE;

    response.flags = @=$2@>;

    response.string_vector = param->filename_vector;

@q ***** (5) Handle `database' and `database-only' options.   @>
@ Handle \.{`database'} and \.{`database-only'} options.  
\initials{LDF 2013.08.12.}

This conditional is needed because |response.options| uses different bits 
for \.{database} and \.{database-only} than \<rm option> does.
\initials{LDF 2013.08.12.}

\LOG
\initials{LDF 2013.08.12.}
Added this section.
\ENDLOG

@<Rules@>=

    if (@=$3@> & 1U)   /* Delete from database  */
    {
        response.options |= 2U;
    }
    else if (@=$3@> & 2U) /* Delete from database only */
    {
        response.options |= 4U;
    }

    param->response_deque.push_back(process_pending_response);

    response.delay_value = param->delay_value;

    if (response.delay_value > 0)
    {
       response.no_delay  = false;
       response.options |= 1U;  
    }

    response.type = Response_Type::MARK_IRODS_OBJECTS_FOR_DELETION_TYPE;

    /* !! TODO: LDF 2013.08.15.  Look into this.  See `00TODO'.   */

    if (param->response_deque.size() > 0)
       param->delayed_response_deque.push_back(response);
    else 
       param->response_deque.push_back(response);

    param->filename_vector.clear();

    param->delay_value = 0UL;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) rm_option_list.  @>
@ \<rm option list>.
\initials{LDF 2013.08.09.}

\LOG
\initials{LDF 2013.08.09.}
Added this section.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> rm_option_list@>
@=%type <uint_value> rm_option@>

@q ***** (5) rm_option_list: /* Empty */ @>

@ \<rm option list> $\longrightarrow$ \.{Empty}  @>
\initials{LDF 2013.08.09.}

\LOG
\initials{LDF 2013.08.09.}
Added this rule.
\ENDLOG

@<Rules@>=
@=rm_option_list: /* Empty */ @>
{

    Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`rm_option_list:  /* Empty  */ "
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     param->delay_value = 0UL;

     @=$$@> = 0U;

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) rm_option_list: rm_option_list rm_option @>

@ \<rm option list> $\longrightarrow$ \<rm option list> \<rm option>  @>
\initials{LDF 2013.08.09.}

\LOG
\initials{LDF 2013.08.09.}
Added this rule.
\ENDLOG

@<Rules@>=
@=rm_option_list: rm_option_list rm_option @>
{

    Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`rm_option_list:  rm_option_list rm_option'"
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     if (@=$2@> == 1U && @=$1@> && 2U)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] WARNING!"
              << endl
              << "In `yyparse':  Option `database' used and option `database-only' "
              << "already set."
              << endl
              << "The last option used takes precedence:  Setting `database' option"
              << endl
              << "and unsetting `database-only'."
              << endl;
         unlock_cerr_mutex(); 

         temp_strm.str();
         temp_strm << "DATABASE OPTION RESPONSE 2 \"WARNING!  Multiple database options used." 
                   << endl 
                   << "The last one takes precedence."
                   << endl 
                   << "Setting `database' and unsetting `database-only'.\"";
                  

         response.command = temp_strm.str();
         temp_strm.str();
 
         param->response_deque.push_back(response);

         ++param->warnings_occurred;;

         @=$$@> &= ~2U;
         @=$$@> |=  1U;
     }
     else if (@=$2@> == 2U && @=$1@> && 1U)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] WARNING!"
              << endl
              << "In `yyparse':  Option `database-only' used and option `database' "
              << "already set."
              << endl
              << "The last option used takes precedence:  Setting `database-only' option"
              << endl
              << "and unsetting `database'."
              << endl;
         unlock_cerr_mutex(); 

         temp_strm.str();
         temp_strm << "DATABASE OPTION RESPONSE 2 \"WARNING!  Multiple database options used." 
                   << endl 
                   << "The last one takes precedence."
                   << endl 
                   << "Setting `database-only' and unsetting `database'.\"";

         response.command = temp_strm.str();
         temp_strm.str();
 
         ++param->warnings_occurred;;

         param->response_deque.push_back(response);

         @=$$@> &= ~1U;
         @=$$@> |=  2U;
     }
     else
        @=$$@> = @=$1@> | @=$2@>;
    

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) rm_option_list: rm_option_list delay_option @>

@ \<rm option list> $\longrightarrow$ \<rm option list> \<delay option>  @>
\initials{LDF 2013.08.09.}

\LOG
\initials{LDF 2013.08.09.}
Added this rule.
\ENDLOG

@<Rules@>=
@=rm_option_list: rm_option_list delay_option @>
{

    Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`rm_option_list:  rm_option_list delay_option'"
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     @=$$@> = @=$1@>;    

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) rm_option: database_option @>

@ \<rm option> $\longrightarrow$ \<database option>.  @>
\initials{LDF 2013.08.09.}

\LOG
\initials{LDF 2013.08.09.}
Added this rule.

\initials{LDF 2013.08.15.}
Replaced \.{DATABASE\_YY} with \<database option>.
\ENDLOG

@<Rules@>=
@=rm_option: database_option @>
{

    Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`rm_option: database_option'"
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     @=$$@> |= @=$1@>;

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> PUT_YY flags_optional put_options STRING_YY @>
@q **** (4) server_side_filename_optional                             @>

@ \<statement> $\longrightarrow$ \.{PUT\_YY} \<flags optional>
\<put options> \.{STRING\_YY} \<server-side filename optional>.
\initials{LDF 2012.09.26.}

@q ***** (5) Log @>

\LOG
\initials{LDF 2012.09.26.}
Added this rule.

\initials{LDF 2012.09.27.}
Removed code to |Scan_Parse_Parameter_Type::put| in \filename{scprpmtp.web}.

\initials{LDF 2012.11.22.}
Rewrote this rule.  Now creating a |Response_Type| object and putting it
onto |param->response_map|.  This object stores the information
passed in the symbols of this rule so that it can be retrieved when the 
client's response for sending the file is processed.

\initials{LDF 2013.08.29.}
Moved \.{STRING\_YY} from the second to the fourth position.  
It now follows the flags and PID options.  This makes it more consistent with 
the icommand \.{iput}.
\ENDLOG

@q ***** (5) Code @>

@<Rules@>=

@=statement: PUT_YY flags_optional put_options STRING_YY server_side_filename_optional@>
{
@q ****** (6) @>
 
    Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

    unsigned int options = 0U;

    bool is_directory = false;

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`statement: PUT_YY flags_optional pid_options "
              << "STRING_YY server_side_filename_optional':" 
              << endl
              << "`flags_optional' == " << @=$2@>
              << endl
              << "`put_options' == " << oct << @=$3@> << dec
              << endl
              << "`STRING_YY' == " << @=$4@>
              << endl 
              << "`server_side_filename_optional' == " << @=$5@>
              << endl 
              << "`param->temp_gpg_key_fingerprint' == " << param->temp_gpg_key_fingerprint
              << endl 
              << "`param->string_vector.size()' == " << param->string_vector.size()
              << endl;

         if (param->string_vector.size() > 0)
            cerr << "`param->string_vector.front()' == " << param->string_vector.front()
                 << endl;

         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<Rules@>=

   if (param->int_vector.size() > 0)
   {
       lock_cout_mutex(); 
       lock_cerr_mutex(); 
       cout << "put -->"
            << endl
            << "Received `put' command in response to pull request " 
            << param->int_vector.back()
            << endl;
       unlock_cerr_mutex(); 
       unlock_cout_mutex(); 
 
       param->int_vector.clear();
   }

@q ****** (6) @>
@
@<Rules@>=


   Response_Type response;
   Response_Type new_response;

@q ****** (6) Error handling:  Client-side filename is a directory.  @>
@ Error handling:  Client-side filename is a directory.  
This isn't permitted at the present time.  However, in the future
I may make it possible to send the contents of an entire directory.
@:TODO@> !! TODO:  Think about this.
\initials{LDF 2012.11.23.}

\LOG
\initials{LDF 2012.11.23.}
@:BUG FIX@> BUG FIX:  Added this section with code for testing whether 
the client-side filename stored in the \.{STRING\_YY} token is a directory.
\ENDLOG

@<Rules@>=

    string client_side_filename = @=$4@>;

    if (   client_side_filename[client_side_filename.size() - 1] == '/' 
        && !(@=$3@> & 4096U || @=$3@> & 8192U))
    {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] ERROR!  In `yyparse', rule "
              << "`statement: PUT_YY flags_optional put_options "
              << "STRING_YY server_side_filename_optional':" 
              << endl
              << "Client-side filename `" << client_side_filename << "'"
              << endl 
              << "is a directory, but no compression option was specified."
              << endl 
              << "This isn't permitted."
              << endl 
              << "Will try to continue."
              << endl;
         unlock_cerr_mutex(); 

         response.type = Response_Type::COMMAND_ONLY_TYPE;

         temp_strm.str("");

         temp_strm <<  "PUT RESPONSE \"" << client_side_filename
                   << "\" 1 \"Input error:  "
                   << "Client-side filename `" 
                   << client_side_filename << "' is a directory, "
                   << "but compression not specified.\"";

         response.command = temp_strm.str();
         param->response_deque.push_back(response);

         temp_strm.str("");

         ++param->errors_occurred;

         goto END_PUT_RULE;

    }  /* |if| */


@q ****** (6) @>
@
@<Rules@>=

    else if (client_side_filename[client_side_filename.size() - 1] == '/') 
    {
         is_directory = true;

#if DEBUG_COMPILE 
         if (param->PARSER_DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
                  << "`statement: PUT_YY flags_optional put_options "
                  << "STRING_YY server_side_filename_optional':" 
                  << endl
                  << "Client-side filename `" << client_side_filename << "' "
                  << "is a directory and compression was specified:"
                  << endl 
                  << "Options:  " << @=$3@> << " " << oct << @=$3@> << " (octal)"
                  << dec
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    }  /* |if (client_side_filename[client_side_filename.size() - 1] == '/')|  */

@q ****** (6) @>
@
@<Rules@>=

   response.type = Response_Type::RECEIVE_PUT_FILE_TYPE;

   response.command     = "PUT";
   response.flags       = @=$2@>;
   response.pid_options = @=$3@> & 31U; /* $31 = (16 + 8 + 4 + 2 + 1)$, i.e., 
                                           the 5 lowest-order bits in the
                                           |unsigned int| representing the options.
                                           \initials{LDF 2014.01.07.}  */

   response.options = @=$3@> & ~31U;  /* The bits higher than bit 5 are used
                                         for the other options, e.g., for
                                         encryption and signing.
                                         \initials{LDF 2014.01.07.}  */


@q ****** (6) @>

@ Signing but not encrypting:  Use clearsign instead and send 
warning message to client.
\initials{LDF 2014.01.14.}

@<Rules@>=

   if (response.options & 64U && (response.options & 32U == 0))
   {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] WARNING!  In `yyparse', rule "
             << "`statement: PUT_YY flags_optional put_options "
             << "STRING_YY server_side_filename_optional':" 
             << endl
             << "`sign' option specified without `encrypt' option:"
             << endl 
             << "`response.options' == " << response.options << " " 
             << oct << response.options << " (octal)" << dec
             << endl 
             << "`response.options & 32U' == " << (response.options & 32U)
             << endl 
             << "`response.options & 64U' == " << (response.options & 64U)
             << endl 
             << "Will clearsign instead."
             << endl 
             << "Sending warning message to client and continuing."
             << endl;
        unlock_cerr_mutex(); 

        response.options &= ~64U;  
        response.options |= 128U;  

        new_response.type = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm.str("");

        temp_strm <<  "PUT RESPONSE \"" << client_side_filename << "\" 4 "
                  << "\"\002sign\003 option specified "
                  << "without \002encrypt\003 option:  Clearsigning instead.\"";

        new_response.command = temp_strm.str();
        param->response_deque.push_back(new_response);

        temp_strm.str("");

        ++param->warnings_occurred;

   }  /* |if (response.options & 64U && !(response.options & 32U))|  */

@q ****** (6) @>
@
\LOG
\initials{LDF 2014.01.24.}
\ENDLOG 

@<Rules@>=

   response.pid_str             = param->pid_str;
   response.pid_prefix_str      = param->pid_prefix_str;
   response.pid_suffix_str      = param->pid_suffix_str;
   response.pid_institute_str   = param->pid_institute_str;
   response.gpg_key_fingerprint = param->temp_gpg_key_fingerprint;

   response.remote_filename = @=$4@>;  /* Client-side filename  */

   if (is_directory)
       response.options |= 16384;  /* $16384 = 2^{14}$  */

   if (strlen(@=$5@>) > 0)
   {

       /* Server-side filename.  Leave unset if not specified!
          \initials{LDF 2014.01.24.}                            */

       response.local_filename = @=$5@>;
   }             

   if (param->string_vector.size() > 0)
   {
      response.string_val = param->string_vector.front();
      param->string_vector.clear();
   }


#if DEBUG_COMPILE 
   if (param->PARSER_DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
            << "`statement: PUT_YY flags_optional put_options "
            << "STRING_YY server_side_filename_optional':" 
            << endl
            << "response.pid_str             == " << response.pid_str 
            << endl
            << "response.pid_prefix_str      == " << response.pid_prefix_str 
            << endl
            << "response.pid_suffix_str      == " << response.pid_suffix_str 
            << endl
            << "response.pid_institute_str   == " << response.pid_institute_str 
            << endl 
            << "response.pid_options         == " << setw(2) << response.pid_options << " == " 
            << oct << setw(2) << response.pid_options << " (octal)" << dec
            << endl
            << "response.options             == " << setw(2) << response.options << " == " 
            << oct << setw(2) << response.options << " (octal)" << dec
            << endl 
            << "response.string_val          == " << response.string_val
            << endl 
            << "response.gpg_key_fingerprint == " << response.gpg_key_fingerprint
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

   options = response.options;

   unsigned int ref_ctr;

   pthread_mutex_lock(&param->response_map_mutex);

   if (param->response_map.size() == 0)
   {
        ref_ctr = 0;
        param->response_map[0] = response;

   }
   else
   {
      map<unsigned int, Response_Type>::const_reverse_iterator iter 
         = param->response_map.rbegin();

#if DEBUG_COMPILE 
      if (param->PARSER_DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << "iter->first == " << iter->first << endl;
          iter->second.show("iter->second:");
          unlock_cerr_mutex(); 

      }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 
    
      ref_ctr = iter->first + 1;

      param->response_map[ref_ctr] = response;

   }  /* |else|  */

   pthread_mutex_unlock(&param->response_map_mutex);


#if DEBUG_COMPILE 
   if (param->PARSER_DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "param->response_map[" << ref_ctr << "]:"
            << endl;

       param->response_map[ref_ctr].show();

       unlock_cerr_mutex(); 

      }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

   response.clear();
   response.type = Response_Type::PROCESS_PENDING_TYPE; 
   param->response_deque.push_back(response);

   response.clear();
   response.type = Response_Type::COMMAND_ONLY_TYPE;

   temp_strm.str("");

   temp_strm << "SEND FILE \"" << @=$4@> << "\" REFERENCE " << ref_ctr << " "
             << options << "U";

   response.command = temp_strm.str();

#if DEBUG_COMPILE
   if (param->PARSER_DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
            << "`statement: PUT_YY flags_optional put_options "
            << "STRING_YY server_side_filename_optional':" 
            << endl
            << "`temp_strm.str()' == "
            << endl
            << temp_strm.str()
            << endl;
        unlock_cerr_mutex(); 

   }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   temp_strm.str("");

   param->response_deque.push_back(response);

END_PUT_RULE:
   ;

    param->temp_gpg_key_fingerprint = "";

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ****** (6) @>

};

@q ***** (5) @>

@q **** (4) put_options and pid_options.  @>
@ \<put options> and \<pid options>.  
\initials{LDF 2012.09.28.}
\initials{LDF 2014.01.07.}

\LOG
\initials{LDF 2012.09.28.}
Added the type declaration for \<pid options>.

\initials{LDF 2014.01.07.}
Added the type declaration for \<put options>.  
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> pid_options@>
@=%type <uint_value> put_options@>


@q ***** (5) put_options:  /* Empty  */@>
@ \<put options> $\longrightarrow$ \.{Empty}.

\LOG
\initials{LDF 2014.01.07.}
Added this rule.
\ENDLOG

@<Rules@>=
@=put_options: /* Empty  */@>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));


    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `put_options: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@>                   = 0U;

    param->pid_str           = "";
    param->pid_suffix_str    = "";
    param->pid_prefix_str    = "";
    param->pid_institute_str = "";
    param->temp_gpg_key_fingerprint   = "";

    param->string_vector.clear();
    param->int_vector.clear();

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) put_options: put_options pid_options @>
@ \<put options> $\longrightarrow$ \<put options> \<pid options>.
\initials{LDF 2014.01.07.}

\LOG
\initials{LDF 2014.01.07.}
Added this rule.
\ENDLOG

@<Rules@>=
@=put_options: put_options pid_options @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `put_options: put_options pid_options'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | @=$2@>;

   param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) pid_options:  /* Empty  */@>
@ \<pid options> $\longrightarrow$ \.{Empty}.

\LOG
\initials{LDF 2012.09.28.}
Added this rule.
\ENDLOG

@<Rules@>=
@=pid_options: /* Empty  */@>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `pid_options: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@>                   = 0U;

    param->pid_str           = "";
    param->pid_suffix_str    = "";
    param->pid_prefix_str    = "";
    param->pid_institute_str = "";

   param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) pid_options: pid_options PID_YY@>
@ \<pid options> $\longrightarrow$ \<pid options> \.{PID\_YY}.

\LOG
\initials{LDF 2012.09.28.}
Added this rule.
\ENDLOG

@<Rules@>=
@=pid_options: pid_options PID_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `pid_options: pid_options PID_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 1U;

   param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) pid_options: pid_options PID_YY STRING_YY@>
@ \<pid options> $\longrightarrow$ \<pid options> \.{PID\_YY}
\.{STRING\_YY}.

\LOG
\initials{LDF 2012.09.28.}
Added this rule.
\ENDLOG

@<Rules@>=
@=pid_options: pid_options PID_YY STRING_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `pid_options: pid_options PID_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 1U;

    param->pid_str = @=$3@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) pid_options: pid_options GENERATE_YY@>
@ \<pid options> $\longrightarrow$ \<pid options> \.{GENERATE\_YY}.
\initials{LDF 2012.09.28.}

@:NOTE@> !! PLEASE NOTE:  This option doesn't seem to have any effect
at present.
\initials{LDF 2012.11.22.}

\LOG
\initials{LDF 2012.09.28.}
Added this rule.
\ENDLOG

@<Rules@>=
@=pid_options: pid_options GENERATE_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `pid_options: pid_options GENERATE_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 2U;

   param->PARSER_DEBUG = save_PARSER_DEBUG; 


};

@q ***** (5) pid_options: pid_options INSTITUTE_YY STRING_YY@>
@ \<pid options> $\longrightarrow$ \<pid options> \.{INSTITUTE\_YY}
\.{STRING\_YY}.

\LOG
\initials{LDF 2012.09.28.}
Added this rule.
\ENDLOG

@<Rules@>=
@=pid_options: pid_options INSTITUTE_YY STRING_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `pid_options: pid_options INSTITUTE_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 4U;

    param->pid_institute_str = @=$3@>;
 
    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) pid_options: pid_options SUFFIX_YY STRING_YY@>
@ \<pid options> $\longrightarrow$ \<pid options> \.{SUFFIX\_YY}
\.{STRING\_YY}.

\LOG
\initials{LDF 2012.09.28.}
Added this rule.
\ENDLOG

@<Rules@>=
@=pid_options: pid_options SUFFIX_YY STRING_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `pid_options: pid_options SUFFIX_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 8U;

    param->pid_suffix_str = @=$3@>;

   param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) pid_options: pid_options PREFIX_YY STRING_YY@>
@ \<pid options> $\longrightarrow$ \<pid options> \.{PREFIX\_YY}
\.{STRING\_YY}.

\LOG
\initials{LDF 2012.09.28.}
Added this rule.
\ENDLOG

@<Rules@>=
@=pid_options: pid_options PREFIX_YY STRING_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `pid_options: pid_options PREFIX_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 16U;

    param->pid_prefix_str = @=$3@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) put_options: put_options ENCRYPT_YY @>
@ \<put options> $\longrightarrow$ \<put options> \.{ENCRYPT\_YY}.
\initials{LDF 2014.01.07.}

\LOG
\initials{LDF 2014.01.07.}
Added this rule.
\ENDLOG

@<Rules@>=
@=put_options: put_options ENCRYPT_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `put_options: put_options ENCRYPT_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$1@> &= ~128U;  /* Unset ``clearsign'' bit, if set.  \initials{LDF 2014.01.07.}  */

    @=$$@> = @=$1@> | 32U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) put_options: put_options SIGN_YY @>
@ \<put options> $\longrightarrow$ \<put options> \.{SIGN\_YY}.
\initials{LDF 2014.01.07.}

\LOG
\initials{LDF 2014.01.07.}
Added this rule.
\ENDLOG

@<Rules@>=
@=put_options: put_options SIGN_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `put_options: put_options SIGN_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$1@> &= ~128U;  /* Unset ``clearsign'' bit, if set.  \initials{LDF 2014.01.07.}  */

    @=$$@> = @=$1@> | 64U;

   param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) put_options: put_options CLEARSIGN_YY @>
@ \<put options> $\longrightarrow$ \<put options> \.{CLEARSIGN\_YY}.
\initials{LDF 2014.01.07.}

As of 2014.01.09., this option unsets the ``encrypt'' bit in \<put options>.
It would be possible to clearsign the file and then encrypt it, however, 
I don't see any advantage to doing this as opposed to simply signing the 
encrypted text, i.e., with GPG's \.{--sign} option.
\par
If it ever turns out that clearsigning and then encrypting a file may be useful for
some purpose, this code could be changed to allow it.  However, it would cause a 
certain amount of additional complication in the function 
|Scan_Parse_Parameter_Type::client_action_send_file|, which I don't consider
to be justified at the present time.
\initials{LDF 2014.01.09.}

\LOG
\initials{LDF 2014.01.07.}
Added this rule.
\ENDLOG

@<Rules@>=
@=put_options: put_options CLEARSIGN_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `put_options: put_options CLEARSIGN_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    /* Unset ``encrypt'' and  ``sign'' bits, if set.  \initials{LDF 2014.01.07.}  */

    @=$1@> &= ~32U;  
    @=$1@> &= ~64U; 

    @=$$@> = @=$1@> | 128U;

   param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) put_options: put_options DETACHED_YY@>
@ \<put options> $\longrightarrow$ \<put options> \.{DETACHED\_YY}. 
\initials{LDF 2014.01.07.}

\LOG
\initials{LDF 2014.01.07.}
Added this rule.
\ENDLOG

@<Rules@>=
@=put_options: put_options DETACHED_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `put_options: put_options DETACHED_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$1@> &= ~64U;  /* Unset ``sign'' bit, if set. \initials{LDF 2014.01.13.}  */

    @=$$@> = @=$1@> | 256U;

   param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) put_options: put_options SIGNATURE_YY STRING_YY @>
@ \<put options> $\longrightarrow$ \<put options> \.{SIGNATURE\_YY}
\.{STRING\_YY}.
\initials{LDF 2014.01.09.}

\LOG
\initials{LDF 2014.01.09.}
Added this rule.
\ENDLOG

@<Rules@>=
@=put_options: put_options SIGNATURE_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `put_options: put_options SIGNATURE_YY STRING_YY'." 
             << endl
             << "`STRING_YY' (3) (Base file) == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$1@> &= ~(32U | 64U | 128U | 256U);  /* Unset encryption options.
                                              \initials{LDF 2014.01.09.}  */
    @=$$@> = @=$1@> | 512U;

    param->string_vector.push_back(@=$3@>);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) put_options: put_options GPG_KEY_FINGERPRINT_YY STRING_YY @>
@ \<put options> $\longrightarrow$ \<put options> \.{GPG\_KEY\_FINGERPRINT\_YY}
\.{STRING\_YY}.
\initials{LDF 2014.01.10.}

\LOG
\initials{LDF 2014.01.10.}
Added this rule.
\ENDLOG

@<Rules@>=
@=put_options: put_options GPG_KEY_FINGERPRINT_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `put_options: put_options GPG_KEY_FINGERPRINT_YY STRING_YY'." 
             << endl
             << "`STRING_YY' (3) (GPG key ID) == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 1024U;

    param->temp_gpg_key_fingerprint = @=$3@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) put_options: put_options VERIFY_YY @>
@ \<put options> $\longrightarrow$ \<put options> \.{VERIFY\_YY}.
\initials{LDF 2014.01.13.}

\LOG
\initials{LDF 2014.01.13.}
Added this rule.
\ENDLOG

@<Rules@>=
@=put_options: put_options VERIFY_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `put_options: put_options VERIFY_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 2048U;  /* $2048 = 2^{11}$  */

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) put_options: put_options COMPRESS_YY @>
@ \<put options> $\longrightarrow$ \<put options> \.{COMPRESS\_YY}.
\initials{LDF 2014.01.23.}

\LOG
\initials{LDF 2014.01.23.}
Added this rule.
\ENDLOG

@<Rules@>=
@=put_options: put_options COMPRESS_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `put_options: put_options COMPRESS_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 4096U;  /* $4096 = 2^{12}$  */

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) put_options: put_options COMPRESS_YY GZIP_YY @>
@ \<put options> $\longrightarrow$ \<put options> \.{COMPRESS\_YY} \.{GZIP\_YY}.
\initials{LDF 2014.01.23.}

\LOG
\initials{LDF 2014.01.23.}
Added this rule.
\ENDLOG

@<Rules@>=
@=put_options: put_options COMPRESS_YY GZIP_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `put_options: put_options COMPRESS_YY GZIP_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 4096U;  /* $4096 = 2^{12}$  */


    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) put_options: put_options COMPRESS_YY BZIP2_YY @>
@ \<put options> $\longrightarrow$ \<put options> \.{COMPRESS\_YY} \.{BZIP2\_YY}.
\initials{LDF 2014.01.23.}

\LOG
\initials{LDF 2014.01.23.}
Added this rule.
\ENDLOG

@<Rules@>=
@=put_options: put_options COMPRESS_YY BZIP2_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `put_options: put_options COMPRESS_YY BZIP2_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 8192U;  /* $8192 = 2^{13}$  */

    /* DO NOT USE $16384 = 2^{14}$ for an option!  It's set if the file 
       is a directory.  In this case, a `tar' file will be sent.  
       \initials{LDF 2014.01.23.}  */

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) put_options: put_options PULL_YY REQUEST_YY INTEGER_YY @>
@ \<put options> $\longrightarrow$ \<put options> \.{PULL\_YY} \.{REQUEST\_YY} 
\.{INTEGER\_YY}.
\initials{LDF 2014.02.14.}

\LOG
\initials{LDF 2014.02.14.}
Added this rule.
\ENDLOG

@<Rules@>=
@=put_options: put_options PULL_YY REQUEST_YY INTEGER_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `put_options: put_options "
             << "PULL_YY REQUEST_YY INTEGER_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    /* |Scan_Parse_Parameter_Type::int_vector| is currently not used 
       for any other ``put options''.  If this changes, the |pull_request_id|
       may have to be stored somewhere else.
       \initials{LDF 2014.02.14.}  */

    param->int_vector.push_back(@=$4@>);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) statement --> GET_YY flags_optional get_options STRING_YY @>
@q **** (4)               client_side_filename_optional               @>

@ \<statement> $\longrightarrow$ \.{GET\_YY} \<flags optional> \<get options>
\.{STRING\_YY} \<client-side filename optional>.
\initials{LDF 2012.10.02.}

This rule assumes that the file named by \.{STRING\_YY} is available
on the machine where \.{gwirdsif} is running.
\initials{LDF 2012.10.02.}

\LOG
\initials{LDF 2012.10.02.}
Added this rule.

\initials{LDF 2012.11.19.}
Added \<client-side filename optional>.

\initials{LDF 2013.04.04.}
Removed code from this rule.  Now pushing a |Response_Type| object of 
|type == Response_Type::GET_TYPE| onto |Scan_Parse_Parameter_Type::response_deque|.

\initials{LDF 2013.08.29.}
Moved \.{STRING\_YY} from the second to the third position.  
It now follows the optional flags.  This makes it more consistent with 
the icommand \.{iget}.

\initials{LDF 2014.01.16.}
Added \<get options>.
\ENDLOG

@<Rules@>=

@=statement: GET_YY flags_optional get_options STRING_YY client_side_filename_optional@>
{
     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

     bool save_PARSER_DEBUG = param->PARSER_DEBUG;
     param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`statement: GET_YY flags_optional get_options "
              << "STRING_YY client_side_filename_optional':" 
              << endl
              << "`flags_optional' (2)            == " << @=$2@>
              << endl 
              << "`get_options'    (3)            == " << @=$3@> << " " 
              << oct << @=$3@> << " (octal)" << dec
              << endl 
              << "`STRING_YY'      (4) (Filename) == " << @=$4@>
              << endl 
              << "`client_side_filename_optional' == " << @=$5@>
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     Response_Type response;

     response.type = Response_Type::PROCESS_PENDING_TYPE;
     param->response_deque.push_back(response);

     response.type = Response_Type::GET_TYPE;

     response.flags           = @=$2@>;
     response.options         = @=$3@>;
     response.local_filename  = @=$4@>;
     response.remote_filename = @=$5@>;

     param->response_deque.push_back(response);

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) flags_optional.  @>

@ \<flags optional>.  

\LOG
\initials{LDF 2012.09.27.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <string_value> flags_optional@>

@q ***** (5) flags_optional:  /* Empty  */@>
@ \<flags optional> $\longrightarrow$ \.{Empty}.

\LOG
\initials{LDF 2012.09.27.}
Added this rule.
\ENDLOG

@<Rules@>=
@=flags_optional: /* Empty  */@>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `flags_optional: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    strcpy(@=$$@>, "");

};

@q ***** (5) flags_optional: flags_optional FLAG_YY@>
@ \<flags optional> $\longrightarrow$ \<flags optional> \.{FLAG\_YY}.

\LOG
\initials{LDF 2012.09.27.}
Added this rule.

\initials{LDF 2012.11.29.}
Added error-handling code for the case that |param->icommands_flag_str| gets too 
long.  The limit is 64 characters, including a trailing space.  This is a fairly strict 
limit, so it may be necessary to increase it.

\initials{LDF 2013.04.25.}
Removed code referring to |param->icommands_flag_str|.
\ENDLOG

@<Rules@>=
@=flags_optional: flags_optional FLAG_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `flags_optional: flags_optional FLAG_YY'." 
             << endl
             << "`flags_optional' (on right-hand-side) == " << @=$1@>
             << endl 
             << "`FLAG_YY'                             == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    if (strlen(@=$1@>) + strlen(@=$2@>) + 1 > 63)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "WARNING!  In `yyparse', rule `flags_optional: flags_optional FLAG_YY':" 
             << endl
             << "Cannot append flag `" << @=$2@> << "' (plus trailing space)"
             << endl 
             << "to the value of `flags_optional':  " << @=$1@>
             << endl 
             << "The resulting string would be too long (> 63 characters)."
             << endl
             << "Leaving value `flags_optional' unchanged.  Continuing."
             << endl;
        unlock_cerr_mutex(); 

    }
    else
    {
       strcpy(@=$$@>, @=$1@>);
       strcat(@=$$@>, " ");
       strcat(@=$$@>, @=$2@>);

    }

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `flags_optional: flags_optional FLAG_YY'." 
             << endl
             << "`flags_optional' (value of result) == " << @=$$@>
             << endl; 
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

};

@q **** (4) get_options.  @>
@ \<get options>.
\initials{LDF 2014.01.16.}

\LOG
\initials{LDF 2014.01.16.}
Added the type declarations for \<get options>.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> get_options@>

@q ***** (5) get_options:  /* Empty  */@>
@ \<get options> $\longrightarrow$ \.{Empty}.

\LOG
\initials{LDF 2014.01.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=get_options: /* Empty  */@>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));


    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `get_options: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@>                          = 0U;    

    param->pid_str                  = "";
    param->pid_suffix_str           = "";
    param->pid_prefix_str           = "";
    param->pid_institute_str        = "";
    param->temp_gpg_key_fingerprint = "";

    param->string_vector.clear();

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) get_options: get_options VERIFY_YY @>
@ \<get options> $\longrightarrow$ \<get options> \.{VERIFY\_YY}.
\initials{LDF 2014.01.16.}

\LOG
\initials{LDF 2014.01.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=get_options: get_options VERIFY_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `get_options: get_options VERIFY_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 2U;  /* |1U| is used for ``overwrite'', which is set
                              by using the \.{-f} flag.
                              \initials{LDF 2014.01.16.}*/

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) get_options: get_options DECRYPT_YY @>
@ \<get options> $\longrightarrow$ \<get options> \.{DECRYPT\_YY}.
\initials{LDF 2014.01.19.}

\LOG
\initials{LDF 2014.01.19.}
Added this rule.
\ENDLOG

@<Rules@>=
@=get_options: get_options DECRYPT_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `get_options: get_options DECRYPT_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 4U;  

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) get_options: get_options STORE_SIGNATURE_YY @>
@ \<get options> $\longrightarrow$ \<get options> \.{STORE\_SIGNATURE\_YY}.
\initials{LDF 2014.01.21.}

\LOG
\initials{LDF 2014.01.21.}
Added this rule.
\ENDLOG

@<Rules@>=
@=get_options: get_options STORE_SIGNATURE_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `get_options: get_options STORE_SIGNATURE_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 8U;  

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) get_options: get_options EXPAND_YY @>
@ \<get options> $\longrightarrow$ \<get options> \.{EXPAND\_YY}.
\initials{LDF 2014.01.24.}

\LOG
\initials{LDF 2014.01.24.}
Added this rule.
\ENDLOG

@<Rules@>=
@=get_options: get_options EXPAND_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `get_options: get_options EXPAND_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 16U;  

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) server_side_filename_optional.  @>

@ \<server-side filename optional>.  
\initials{LDF 2012.11.21.}

\LOG
\initials{LDF 2012.11.21.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <string_value> server_side_filename_optional@>

@q ***** (5) server_side_filename_optional:  /* Empty  */@>
@ \<server-side filename optional> $\longrightarrow$ \.{Empty}.

\LOG
\initials{LDF 2012.11.21.}
Added this rule.
\ENDLOG

@<Rules@>=
@=server_side_filename_optional: /* Empty  */@>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `server_side_filename_optional: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    strcpy(@=$$@>, "");

};

@q ***** (5) server_side_filename_optional: REMOTE_FILENAME_YY STRING_YY@>
@ \<server-side filename optional> $\longrightarrow$ \.{REMOTE\_FILENAME\_YY} 
\.{STRING\_YY}.
\initials{LDF 2012.11.21.}

@:NOTE@> !! PLEASE NOTE:  "Remote" here refers to the server-side.  Since this is 
potentially confusing, the left-hand-side of the rule makes this explicit.
\initials{LDF 2012.11.21.}

\LOG
\initials{LDF 2012.11.21.}
Added this rule.
\ENDLOG

@<Rules@>=
@=server_side_filename_optional: REMOTE_FILENAME_YY STRING_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `server_side_filename_optional: "
             << "REMOTE_FILENAME_YY STRING_YY'." 
             << endl
             << "`STRING_YY' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    strcpy(@=$$@>, @=$2@>);

};


@q **** (4) client_side_filename_optional.  @>

@ \<client-side filename optional>.  
\initials{LDF 2012.11.19.}

\LOG
\initials{LDF 2012.11.19.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <string_value> client_side_filename_optional@>

@q ***** (5) client_side_filename_optional:  /* Empty  */@>
@ \<client-side filename optional> $\longrightarrow$ \.{Empty}.

\LOG
\initials{LDF 2012.11.19.}
Added this rule.
\ENDLOG

@<Rules@>=
@=client_side_filename_optional: /* Empty  */@>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `client_side_filename_optional: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    strcpy(@=$$@>, "");

};

@q ***** (5) client_side_filename_optional: LOCAL_FILENAME_YY STRING_YY@>
@ \<client-side filename optional> $\longrightarrow$ \.{LOCAL\_FILENAME\_YY} 
\.{STRING\_YY}.
\initials{LDF 2012.11.19.}

@:NOTE@> !! PLEASE NOTE:  "Local" here refers to the client-side.  Since this is 
potentially confusing, the left-hand-side of the rule makes this explicit.
\initials{LDF 2012.11.19.}

\LOG
\initials{LDF 2012.11.19.}
Added this rule.
\ENDLOG

@<Rules@>=
@=client_side_filename_optional: LOCAL_FILENAME_YY STRING_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `client_side_filename_optional: "
             << "LOCAL_FILENAME_YY STRING_YY'." 
             << endl
             << "`STRING_YY' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    strcpy(@=$$@>, @=$2@>);

};

@q **** (4) statement --> GET_YY METADATA_YY STRING_YY get metadata options  @>

@ \<statement> $\longrightarrow$ \.{GET\_YY} \.{METADATA\_YY} \.{STRING\_YY}.
\<get metadata options>.
\initials{LDF 2012.10.09.}

\LOG
\initials{LDF 2012.10.09.}
Added this rule.

\initials{LDF 2012.12.31.}
Added \<get metadata options>.
\ENDLOG

@<Rules@>=

@=statement: GET_YY METADATA_YY STRING_YY get_metadata_options@>
{

     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`statement: GET_YY METADATA_YY STRING_YY get_metadata_options':" 
              << endl
              << "`STRING_YY' == " << @=$3@>
              << endl 
              << "`get_metadata_options' == " << @=$4@>
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     /* !! TODO: LDF 2012.12.13.  Add flags and/or options for choosing 
        what kind of metadata, iRODS user metadata (AVUs) and/or XML from 
        the ``Dublin Core'' tables in the \.{gwirdsif} database.
     */

     Response_Type response;

     response.type = Response_Type::PROCESS_PENDING_TYPE;
     param->response_deque.push_back(response);

     response.type = Response_Type::GET_METADATA_TYPE;

     response.int_val = 0;
     response.options = @=$4@>;

     response.local_filename = @=$3@>;

     param->response_deque.push_back(response);

};

@q **** (4) statement --> GET_YY METADATA_YY integer_list get metadata options  @>

@ \<statement> $\longrightarrow$ \.{GET\_YY} \.{METADATA\_YY} \<integer list> 
\<get metadata options>.
\initials{LDF 2013.12.18.}

\LOG
\initials{LDF 2013.12.18.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: GET_YY METADATA_YY integer_list get_metadata_options@>
{

     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`statement: GET_YY METADATA_YY integer_list get_metadata_options':" 
              << endl
              << "`get_metadata_options' == " << oct << @=$4@> << " (octal)" << dec
              << endl
              << "`param->int_vector.size()' == " << param->int_vector.size()
              << endl;

         if (param->int_vector.size() > 0)
            cerr << "`param->int_vector':"
                 << endl;

         string comma_str;

         for (vector<int>::iterator iter = param->int_vector.begin();
              iter != param->int_vector.end();
              ++iter)
         {
             cerr << comma_str << *iter;
            
             comma_str = ", ";
         }

         if (param->int_vector.size() > 0)
            cerr << endl;

         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     Response_Type response;
     response.type = Response_Type::FETCH_DC_METADATA_TYPE;

     response.int_vector = param->int_vector;
     param->int_vector.clear();

     response.options |= 8U;  /* Full  */

     if (@=$4@> & 2U)  /* Show  */
        response.options |= 16U;

     if (@=$4@> & 4U)  /* Store  */
        response.options |= 32U;

     param->response_deque.push_back(response);

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> GET_YY METADATA_YY PID_YY STRING_YY get metadata options  @>

@ \<statement> $\longrightarrow$ \.{GET\_YY} \.{PID\_YY} \.{METADATA\_YY} \.{STRING\_YY}.
\<get metadata options>.
\initials{LDF 2013.03.21.}

\LOG
\initials{LDF 2013.03.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: GET_YY METADATA_YY PID_YY STRING_YY get_metadata_options@>
{

     /* !! TODO: LDF 2012.12.13.  Add flags and/or options for choosing 
        what kind of metadata, iRODS user metadata (AVUs) and/or XML from 
        the ``Dublin Core'' tables in the \.{gwirdsif} database.

        This doesn't work yet!  LDF 2013.05.23.  Currently, 
        |Scan_Parse_Parameter_Type::get_metadata| only 
        takes a path argument (for the iRODS object).
    */

     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

     lock_cerr_mutex(); 
     cerr << "[Thread " << param->thread_ctr << "] WARNING!  In `yyparse', rule "
          << "`statement: GET_YY METADATA_YY PID_YY STRING_YY get_metadata_options':" 
          << endl
          << "`STRING_YY' == " << @=$4@>
          << endl 
          << "`get_metadata_options' == " << @=$5@>
          << endl
          << "PLEASE NOTE:  This rule is currently non-functional, since "
          << "`Scan_Parse_Parameter_Type::get_metadata' has not yet been"
          << endl 
          << "adapted to take a PID argument."
          << endl
          << "Sending a message to client and continuing."
          << endl; 
     unlock_cerr_mutex(); 

     ++param->warnings_occurred;

     Response_Type response;

#if 0 
     /* This will be needed when I make this rule functional.
        \initials{LDF 2013.05.24.}
     */

     response.type = Response_Type::PROCESS_PENDING_TYPE;
     param->response_deque.push_back(response);

#endif 

     response.type = Response_Type::COMMAND_ONLY_TYPE;

     temp_strm.str("");

     temp_strm << "GET METADATA RESPONSE \"" << @=$4@> << "\" 1 0 " << @=$5@> << "U "
               << "\"\002GET METADATA PID\003 command not yet implemented\"";

     response.command = temp_strm.str();
     temp_strm.str("");

     param->response_deque.push_back(response);


};


@q **** (4) get_metadata_options.  @>

@ \<get metadata options>.  

\LOG
\initials{LDF 2012.12.31.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> get_metadata_options@>

@q ***** (5) get_metadata_options:  /* Empty  */@>
@ \<get metadata options> $\longrightarrow$ \.{Empty}.

\LOG
\initials{LDF 2012.12.31.}
Added this rule.
\ENDLOG

@<Rules@>=
@=get_metadata_options: /* Empty  */@>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `get_metadata_options: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@>  = 0U;

};

@q ***** (5) get_metadata_options: get_metadata_options OUTPUT_YY@>
@ \<get metadata options> $\longrightarrow$ \<get metadata options> \.{OUTPUT\_YY}.
\initials{LDF 2012.12.31.}

\LOG
\initials{LDF 2012.12.31.}
Added this rule.
\ENDLOG

@<Rules@>=
@=get_metadata_options: get_metadata_options OUTPUT_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `get_metadata_options: get_metadata_options OUTPUT_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 1U;

};

@q ***** (5) get_metadata_options: get_metadata_options SHOW_YY@>
@ \<get metadata options> $\longrightarrow$ \<get metadata options> \.{SHOW\_YY}.
\initials{LDF 2013.12.18.}

\LOG
\initials{LDF 2013.12.18.}
Added this rule.
\ENDLOG

@<Rules@>=
@=get_metadata_options: get_metadata_options SHOW_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `get_metadata_options: get_metadata_options SHOW_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 2U;

};

@q ***** (5) get_metadata_options: get_metadata_options STORE_YY@>
@ \<get metadata options> $\longrightarrow$ \<get metadata options> \.{STORE\_YY}.
\initials{LDF 2013.12.18.}

\LOG
\initials{LDF 2013.12.18.}
Added this rule.
\ENDLOG

@<Rules@>=
@=get_metadata_options: get_metadata_options STORE_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `get_metadata_options: get_metadata_options STORE_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 4U;

};

@q **** (4) statement --> GET_YY HANDLE_YY PID_YY STRING_YY get_handle_option_list@>

@ \<statement> $\longrightarrow$ \.{GET\_YY} \.{HANDLE\_YY} \.{PID\_YY} 
\.{STRING\_YY} \<get handle option list>.
\initials{LDF 2012.10.15.}

\LOG
\initials{LDF 2012.10.15.}
Added this rule.

\initials{LDF 2013.12.19.}
Added \<get handle option list>.
\ENDLOG

@<Rules@>=

@=statement: GET_YY HANDLE_YY PID_YY STRING_YY get_handle_option_list@>
{

     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

     bool save_PARSER_DEBUG = param->PARSER_DEBUG;
     param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`statement: GET_YY HANDLE_YY PID_YY STRING_YY get_handle_option_list':" 
              << endl
              << "`STRING_YY'              (4) == " << @=$4@>
              << endl 
              << "`get_handle_option_list' (5) == " << @=$5@> << " == " 
              << oct << @=$5@> << " (octal) "
              << dec
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     Response_Type response;

     response.type = Response_Type::PROCESS_PENDING_TYPE;
     param->response_deque.push_back(response);

     response.type = Response_Type::GET_HANDLE_TYPE;

     response.int_val = 0;

     response.pid_str = @=$4@>;
     response.options = @=$5@>;

     param->response_deque.push_back(response);

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> GET_YY HANDLE_YY FILE_YY STRING_YY get_handle_option_list@>

@ \<statement> $\longrightarrow$ \.{GET\_YY} \.{HANDLE\_YY} \.{FILE\_YY} 
\.{STRING\_YY} \<get handle option list>.
\initials{LDF 2012.10.15.}

\LOG
\initials{LDF 2012.10.15.}
Added this rule.

\initials{LDF 2013.12.19.}
Added \<get handle option list>.
\ENDLOG

@<Rules@>=

@=statement: GET_YY HANDLE_YY FILE_YY STRING_YY get_handle_option_list@>
{

     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`statement: GET_YY HANDLE_YY FILE_YY STRING_YY get_handle_option_list':" 
              << endl
              << "`STRING_YY' == " << @=$4@>
              << endl 
              << "`get_handle_option_list' (5) == " << @=$5@> << " == " 
              << oct << @=$5@> << " (octal) "
              << dec
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     Response_Type response;

     response.type = Response_Type::PROCESS_PENDING_TYPE;
     param->response_deque.push_back(response);

     response.type = Response_Type::GET_HANDLE_TYPE;

     response.int_val = 1;
     
     response.local_filename = @=$4@>;
     response.options = @=$5@>;

     param->response_deque.push_back(response);

};


@q **** (4) get_handle_option_list.  @>

@ \<get handle option list>.  
\initials{LDF 2013.12.19.}

\LOG
\initials{LDF 2013.12.19.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> get_handle_option_list@>

@q ***** (5) get_handle_option_list:  /* Empty  */@>
@ \<get handle option list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2013.12.19.}

\LOG
\initials{LDF 2013.12.19.}
Added this rule.
\ENDLOG

@<Rules@>=
@=get_handle_option_list: /* Empty */ @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `get_handle_option_list: /* Empty */" 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 0U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) get_handle_option_list:  get_handle_option_list NO_STORE_YY @>
@ \<get handle option list> $\longrightarrow$ \<get handle option list> \.{NO\_STORE\_YY}.
\initials{LDF 2013.12.19.}

\LOG
\initials{LDF 2013.12.19.}
Added this rule.
\ENDLOG

@<Rules@>=
@=get_handle_option_list: get_handle_option_list NO_STORE_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `get_handle_option_list: get_handle_option_list NO_STORE_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 1U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> SEND_YY TAN_YY LIST_YY@>

@ \<statement> $\longrightarrow$ \.{SEND\_YY} \.{TAN\_YY} \.{LIST\_YY}.
\initials{LDF 2012.07.19.}

@:TODO@> !! TODO:  Implement this rule, if needed.  There are functions for it, but
they currently don't work.  I don't know whether TANs will be needed.
\initials{LDF 2013.05.23.}

\LOG
\initials{LDF 2012.07.19.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SEND_YY TAN_YY LIST_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `statement: SEND_YY TAN_YY LIST_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cerr_mutex(); 
    cerr << "[Thread " << param->thread_ctr << "] "
         << "WARNING!  In `yyparse', rule `statement: SEND_YY TAN_YY LIST_YY':" 
         << endl
         << "This command is currently non-functional.  It may not be needed."
         << endl
         << "Sending a message to the client and continuing."
         << endl;
    unlock_cerr_mutex(); 

    ++param->warnings_occurred;

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

    temp_strm.str("");

    temp_strm << "SEND TAN LIST RESPONSE 3 \"The\002SEND TAN LIST\003 command "
              << "is currently non-functional.\"";

    response.command = temp_strm.str();

    temp_strm.str("");

    param->response_deque.push_back(response);

#if 0 
    response.type = Response_Type::SEND_TAN_LIST_TYPE;
#endif 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> SENDING_YY FILE_YY filename_list@>

@ \<statement> $\longrightarrow$ \.{SENDING\_YY} \.{FILE\_YY} \<filename list>.
\initials{LDF 2012.09.27.}

\LOG
\initials{LDF 2012.09.27.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SENDING_YY FILE_YY filename_list@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `statement: SENDING_YY FILE_YY filename_list'." 
             << endl;

         for (vector<string>::const_iterator iter = param->filename_vector.begin();
              iter != param->filename_vector.end();
              ++iter)
         {
             cerr << "*iter == " << *iter << endl;

         }

        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    status = param->receive_file();

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "ERROR!  In `yyparse', rule `statement: SENDING_YY FILE_YY filename_list':" 
             << endl
             << "`Scan_Parse_Parameter_Type::receive_file' failed, returning " << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE 
    else if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `statement: SENDING_YY FILE_YY filename_list':" 
             << endl
             << "`Scan_Parse_Parameter_Type::receive_file' succeeded, returning 0."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

     param->filename_vector.clear();

@q ***** (5) @>

};


@q **** (4) filename_list.  @>

@ \<filename list>.  

\LOG
\initials{LDF 2012.09.27.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> filename_list@>

@q ***** (5) filename_list:  STRING_YY@>
@ \<filename list> $\longrightarrow$ \.{STRING\_YY}.

\LOG
\initials{LDF 2012.09.27.}
Added this rule.
\ENDLOG

@<Rules@>=
@=filename_list: STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `filename_list: STRING_YY." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 0;

    param->filename_vector.clear();
    param->filename_vector.push_back(@=$1@>);

};


@q ***** (5) filename_list: filename_list STRING_YY@>
@ \<filename list> $\longrightarrow$ \<filename list> \.{STRING\_YY}.

\LOG
\initials{LDF 2012.09.27.}
Added this rule.
\ENDLOG

@<Rules@>=
@=filename_list: filename_list STRING_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `filename_list: filename_list STRING_YY'." 
             << endl
             << "`STRING_YY' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->filename_vector.push_back(@=$2@>);

};


@q **** (4) statement --> CLIENT_YY SENDING_YY FILE_YY STRING_YY REFERENCE_YY INTEGER_YY @>
@q **** (4)               client_sending_file_options                                    @>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{SENDING\_YY} \.{FILE\_YY} 
\.{STRING\_YY} \.{REFERENCE\_YY} \.{INTEGER\_YY} \<client sending file options>.
\initials{LDF 2012.11.22.}

\LOG
\initials{LDF 2012.11.22.}
Added this rule.

\initials{LDF 2012.12.14.}
Added code for testing the type of the |response| retrieved from |param->response_map|.
Previously, this rule was only used for files sent to be used in a ``\.{put}'' command.  
I have now adapted it for use use with an ``\.{add metadata}'' command as well.

\initials{LDF 2014.01.09.}
Added \<client sending file options>.
\ENDLOG

@<Rules@>=

@=statement: CLIENT_YY SENDING_YY FILE_YY STRING_YY REFERENCE_YY INTEGER_YY @>
@=client_sending_file_options                                               @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `statement: CLIENT_YY SENDING_YY FILE_YY "
             << "STRING_YY REFERENCE_YY INTEGER_YY client_sending_file_options':"
             << endl
             << "`STRING_YY'                   (4) (filename)  == " << @=$4@>
             << endl 
             << "`INTEGER_YY'                  (6) (reference) == " << @=$6@>
             << endl
             << "`client_sending_file_options' (7)             == " << @=$7@> 
             << " == " 
             << oct << @=$7@> << " (octal)" << dec
             << endl 
             << "`param->temp_gpg_key_fingerprint'             == " 
             << param->temp_gpg_key_fingerprint
             << endl 
             << "`param->string_vector.size()'                 == " 
             << param->string_vector.size()
             << endl;

        if (param->string_vector.size() > 0)
           cerr << "`param->string_vector':"
                << endl;

        for (vector<string>::iterator iter = param->string_vector.begin();
             iter != param->string_vector.end();
             ++iter)
        {
            cerr << *iter << endl;
        }

        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    int status = client_sending_file_rule_func(param, @=$4@>, @=$6@>, @=$7@>);

    if (status != 0)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "ERROR!  In `yyparse', rule `statement: CLIENT_YY SENDING_YY FILE_YY "
             << "STRING_YY REFERENCE_YY INTEGER_YY client_sending_file_options':"
             << endl
             << "`client_sending_file_rule_func' failed, returning " << status << "."
             << endl
             << "Will try to continue."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (param->PARSER_DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << param->thread_ctr << "] "
            << "In `yyparse', rule `statement: CLIENT_YY SENDING_YY FILE_YY "
            << "STRING_YY REFERENCE_YY INTEGER_YY client_sending_file_options':"
            << endl
            << "`client_sending_file_rule_func' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   param->temp_gpg_key_fingerprint   = "";
   param->string_vector.clear();

   param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q **** (4) client_sending_file_options @>
@ \<client sending file options>.
\initials{LDF 2014.01.09.}

\LOG
\initials{LDF 2014.01.09.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> client_sending_file_options @>

@q **** (4) client_sending_file_options: /* Empty  */ @>

@ \<client sending file options> $\longrightarrow$  \.{Empty}.
\initials{LDF 2014.01.09.}

\LOG
\initials{LDF 2013.05.24.}
Added this rule.
\ENDLOG

@<Rules@>=
@=client_sending_file_options: /* Empty  */ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `client_sending_file_options: /* Empty  */':"
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 0U;

    param->string_vector.clear();
    param->temp_gpg_key_fingerprint = "";

    param->PARSER_DEBUG = save_PARSER_DEBUG; 


};

@q **** (4) client_sending_file_options: client_sending_file_options @>
@q **** (4) GPG_KEY_FINGERPRINT_YY STRING_YY                         @>

@ \<client sending file options> $\longrightarrow$ \<client sending file options> 
\.{GPG\_KEY\_FINGERPRINT\_YY} \.{STRING\_YY}.
\initials{LDF 2014.01.09.}

\LOG
\initials{LDF 2013.05.24.}
Added this rule.
\ENDLOG

@<Rules@>=
@=client_sending_file_options: client_sending_file_options GPG_KEY_FINGERPRINT_YY STRING_YY @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `client_sending_file_options: "
             << "client_sending_file_options GPG_KEY_FINGERPRINT_YY STRING_YY':"
             << endl
             << "`STRING_YY' (3) (GPG key ID) == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 1U;

    param->temp_gpg_key_fingerprint = @=$3@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) client_sending_file_options: client_sending_file_options @>
@q **** (4) COMPRESSED_TAR_FILE_YY                                   @>

@ \<client sending file options> $\longrightarrow$ \<client sending file options> 
\.{COMPRESSED\_TAR\_FILE\_YY}.
\initials{LDF 2014.01.23.}

\LOG
\initials{LDF 2014.01.23.}
Added this rule.
\ENDLOG

@<Rules@>=
@=client_sending_file_options: client_sending_file_options COMPRESSED_TAR_FILE_YY @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `client_sending_file_options: "
             << "client_sending_file_options COMPRESSED_TAR_FILE_YY':"
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 2U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) client_sending_file_options: client_sending_file_options @>
@q **** (4) GZIP_YY                                                  @>

@ \<client sending file options> $\longrightarrow$ \<client sending file options> 
\.{GZIP\_YY}.
\initials{LDF 2014.01.23.}

\LOG
\initials{LDF 2014.01.23.}
Added this rule.
\ENDLOG

@<Rules@>=
@=client_sending_file_options: client_sending_file_options GZIP_YY @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `client_sending_file_options: "
             << "client_sending_file_options GZIP_YY':"
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 4U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) client_sending_file_options: client_sending_file_options @>
@q **** (4) BZIP2_YY                                                  @>

@ \<client sending file options> $\longrightarrow$ \<client sending file options> 
\.{BZIP2\_YY}.
\initials{LDF 2014.01.23.}

\LOG
\initials{LDF 2014.01.23.}
Added this rule.
\ENDLOG

@<Rules@>=
@=client_sending_file_options: client_sending_file_options BZIP2_YY @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `client_sending_file_options: "
             << "client_sending_file_options BZIP2_YY':"
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | 8U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> CD_YY@>

@ \<statement> $\longrightarrow$ \.{CD\_YY}.
\initials{LDF 2012.11.27.}

\LOG
\initials{LDF 2012.11.27.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: CD_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `statement: CD_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;
    response.type = Response_Type::CD_TYPE;
    response.dirname = "";

    param->response_deque.push_back(response);

};


@q **** (4) statement --> CD_YY STRING_YY@>

@ \<statement> $\longrightarrow$ \.{CD\_YY} \.{STRING\_YY}.
\initials{LDF 2012.07.30.}

\LOG
\initials{LDF 2012.07.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: CD_YY STRING_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `statement: CD_YY STRING_YY'." 
             << endl
             << "`STRING_YY' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;
    response.type = Response_Type::CD_TYPE;
    response.dirname = @=$2@>;
     
    param->response_deque.push_back(response);

};


@q **** (4) statement --> ADD_YY METADATA_YY STRING_YY STRING_YY add_metadata_options@>

@ \<statement> $\longrightarrow$ \.{ADD\_YY} \.{METADATA\_YY} \.{STRING\_YY} 
\.{STRING\_YY} \<add metadata options>.
\initials{LDF 2012.12.14.}

\LOG
\initials{LDF 2012.12.14.}
Added this rule.

\initials{LDF 2012.12.31.}
Added \<add metadata options>.
\ENDLOG

@<Rules@>=

@=statement: ADD_YY METADATA_YY STRING_YY STRING_YY add_metadata_options@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));


    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `statement: ADD_YY METADATA_YY STRING_YY STRING_YY "
             << "add_metadata_options':" 
             << endl
             << "`STRING_YY' 1 == " << @=$3@>
             << endl 
             << "`STRING_YY' 2 == " << @=$4@>
             << endl
             << "`add_metadata_options' == " << @=$5@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   Response_Type response;

   response.type = Response_Type::RECEIVE_METADATA_FILE_TYPE;

   response.metadata_options = @=$5@>;

   response.remote_filename = @=$3@>;  /* Metadata filename  */

   response.local_filename  = @=$4@>;  /* iRODS object       */

   response.command = "ADD METADATA";

#if DEBUG_COMPILE 
   if (param->PARSER_DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
            << "`statement: ADD_YY METADATA_YY STRING_YY STRING_YY add_metadata_options'."
            << endl;

       response.show("response:");

       unlock_cerr_mutex(); 

   }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

   unsigned int ref_ctr;

   pthread_mutex_lock(&param->response_map_mutex);

   if (param->response_map.size() == 0)
   {
        ref_ctr = 0;
        param->response_map[0] = response;

   }
   else
   {
      map<unsigned int, Response_Type>::const_reverse_iterator iter 
         = param->response_map.rbegin();

#if DEBUG_COMPILE 
   if (param->PARSER_DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "iter->first == " << iter->first << endl;
       iter->second.show("iter->second:");
       unlock_cerr_mutex(); 

   }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 
    
      ref_ctr = iter->first + 1;

      param->response_map[ref_ctr] = response;

   }  /* |else|  */

   pthread_mutex_unlock(&param->response_map_mutex);


#if 0 /* 1 */  
   cerr << "param->response_map[" << ref_ctr << "]:"
        << endl;
   param->response_map[ref_ctr].show();
#endif    

   response.clear();

   response.type = Response_Type::PROCESS_PENDING_TYPE;
   param->delayed_response_deque.push_back(response);

   response.type = Response_Type::COMMAND_ONLY_TYPE;

   temp_strm.str("");

   temp_strm << "SEND FILE \"" << @=$3@> << "\" REFERENCE " << ref_ctr << " 0U";

   response.command = temp_strm.str();

#if DEBUG_COMPILE
   if (param->PARSER_DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
            << "`statement: ADD_YY METADATA_YY STRING_YY STRING_YY add_metadata_options':"
            << endl
            << "`temp_strm.str()' == "
            << endl
            << temp_strm.str()
            << endl;
        unlock_cerr_mutex(); 

   }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   temp_strm.str("");

   param->delayed_response_deque.push_back(response);

   param->PARSER_DEBUG = save_PARSER_DEBUG; 


};




@q **** (4) add_metadata_options.  @>

@ \<add metadata options>.  

\LOG
\initials{LDF 2012.12.31.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> add_metadata_options@>

@q ***** (5) add_metadata_options:  /* Empty  */@>
@ \<add metadata options> $\longrightarrow$ \.{Empty}.

\LOG
\initials{LDF 2012.12.31.}
Added this rule.
\ENDLOG

@<Rules@>=
@=add_metadata_options: /* Empty  */@>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `add_metadata_options: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@>  = 0U;

};

@q ***** (5) add_metadata_options: add_metadata_options FORCE_YY@>
@ \<add metadata options> $\longrightarrow$ \<add metadata options> \.{FORCE\_YY}.

\.{FORCE\_YY} is equivalent to \.{FORCE\_ALL\_YY}, i.e., ``force'' applies to adding 
and storing the metadata file.
\initials{LDF 2013.03.06.}

\LOG
\initials{LDF 2012.12.31.}
Added this rule.
\ENDLOG

@<Rules@>=
@=add_metadata_options: add_metadata_options FORCE_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `add_metadata_options: add_metadata_options FORCE_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> += 3U;

};

@q ***** (5) add_metadata_options: add_metadata_options FORCE_ADD_YY@>
@ \<add metadata options> $\longrightarrow$ \<add metadata options> \.{FORCE\_ADD\_YY}.

\LOG
\initials{LDF 2013.03.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=add_metadata_options: add_metadata_options FORCE_ADD_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `add_metadata_options: add_metadata_options FORCE_ADD_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> += 1U;

};

@q ***** (5) add_metadata_options: add_metadata_options FORCE_STORE_YY@>
@ \<add metadata options> $\longrightarrow$ \<add metadata options> \.{FORCE\_STORE\_YY}.

\LOG
\initials{LDF 2013.03.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=add_metadata_options: add_metadata_options FORCE_STORE_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `add_metadata_options: add_metadata_options FORCE_STORE_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> += 6U;  /* \.{--force-store} implies \.{--store}  */

};

@q ***** (5) add_metadata_options: add_metadata_options FORCE_ALL_YY@>
@ \<add metadata options> $\longrightarrow$ \<add metadata options> \.{FORCE\_ALL\_YY}.

\LOG
\initials{LDF 2013.03.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=add_metadata_options: add_metadata_options FORCE_ALL_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `add_metadata_options: add_metadata_options FORCE_ALL_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> += 3U;

};

@q ***** (5) add_metadata_options: add_metadata_options STORE_YY@>
@ \<add metadata options> $\longrightarrow$ \<add metadata options> \.{STORE\_YY}.

\LOG
\initials{LDF 2013.02.28.}
Added this rule.
\ENDLOG

@<Rules@>=
@=add_metadata_options: add_metadata_options STORE_YY@>
{

    Scan_Parse_Parameter_Type* param 
       = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `add_metadata_options: add_metadata_options STORE_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> += 4U;

};

@q **** (4) statement --> CLIENT_YY FINISHED_YY@>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{FINISHED\_YY}.
\initials{LDF 2012.07.30.}

\LOG
\initials{LDF 2012.07.30.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: CLIENT_YY FINISHED_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `statement: CLIENT_YY FINISHED_YY'." 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->client_finished = true;

};

@q **** (4) statement --> SLEEP_YY INTEGER_YY @>

@ \<statement> $\longrightarrow$ \.{SLEEP\_YY} \.{INTEGER\_YY}.
\initials{LDF 2013.04.19.}

\LOG
\initials{LDF 2013.04.19.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SLEEP_YY INTEGER_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', Rule:  "
             << "`statement: SLEEP_YY INTEGER_YY'."
             << endl
             << "`INTEGER_YY' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    Response_Type response;


    if (sleep_server_enabled)
    {
#if DEBUG_COMPILE
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] In `yyparse':  Rule "
                 << "`statement: SLEEP_YY INTEGER_YY':"
                 << endl
                 << "`sleep_server_enabled' == `true'.  Setting up \"sleep\" response."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        response.type = Response_Type::SLEEP_TYPE;

        response.int_val = @=$2@>;

        temp_strm.str("");
        temp_strm << "SLEEP RESPONSE 0 " << @=$2@>;

        response.command = temp_strm.str();

        temp_strm.str("");


    }  /* |if (sleep_server_enabled)|  */

@q ***** (5) @>

    else
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] WARNING!  In `yyparse':  Rule "
             << "`statement: SLEEP_YY INTEGER_YY':"
             << endl
             << "`sleep_server_enabled' == `false'.  "
             << "Not putting server program `gwirdsif' to sleep."
             << endl
             << "Will send failure notice to client."
             << endl;
        unlock_cerr_mutex(); 

        ++param->warnings_occurred;

        response.type = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm.str("");
        temp_strm << "SLEEP RESPONSE 1 " << @=$2@>;

        response.command = temp_strm.str();

        temp_strm.str("");

    }  /* |else|  */

@q ***** (5) @>

    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> SLEEP_YY CLIENT_YY INTEGER_YY @>

@ \<statement> $\longrightarrow$ \.{SLEEP\_YY} \.{CLIENT\_YY} \.{INTEGER\_YY}.
\initials{LDF 2013.05.02.}

\LOG
\initials{LDF 2013.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SLEEP_YY CLIENT_YY INTEGER_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', Rule:  "
             << "`statement: SLEEP_YY CLIENT_YY INTEGER_YY'."
             << endl
             << "`INTEGER_YY' == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

    if (sleep_client_enabled)
    {
#if DEBUG_COMPILE
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] In `yyparse':  Rule "
                 << "`statement: SLEEP_YY CLIENT_YY INTEGER_YY':"
                 << endl
                 << "`sleep_client_enabled' == `true'.  Setting up \"sleep\" response."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        temp_strm.str("");
        temp_strm << "SLEEP " << @=$3@>;

        response.command = temp_strm.str();

        temp_strm.str("");


    }  /* |if (sleep_client_enabled)|  */

@q ***** (5) @>

    else
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] WARNING!  In `yyparse':  Rule "
             << "`statement: SLEEP_YY CLIENT_YY INTEGER_YY':"
             << endl
             << "`sleep_client_enabled' == `false'.  "
             << "Not sending `SLEEP " << @=$3@> << "' command to client program `gwirdcli'."
             << endl
             << "Will send failure notice to client."
             << endl;
        unlock_cerr_mutex(); 

        ++param->warnings_occurred;

        response.type = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm.str("");
        temp_strm << "SLEEP RESPONSE 3 " << @=$3@>;

        response.command = temp_strm.str();

        temp_strm.str("");

    }  /* |else|  */

@q ***** (5) @>

    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};



@q **** (4) statement --> SIGNAL_YY SERVER_YY INTEGER_YY @>

@ \<statement> $\longrightarrow$ \.{SIGNAL\_YY} \.{SERVER\_YY} \.{INTEGER\_YY}.
\initials{LDF 2013.05.02.}

\LOG
\initials{LDF 2013.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SIGNAL_YY SERVER_YY INTEGER_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`statement: SIGNAL_YY SERVER_YY INTEGER_YY'."
             << endl
             << "`INTEGER_YY' == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    map<int, string>::iterator iter = signal_name_map.find(@=$3@>);

    if (iter == signal_name_map.end())
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] ERROR!  In `yyparse', rule "
             << "`statement: SIGNAL_YY SERVER_YY INTEGER_YY':"
             << endl
             << "Signal number " << @=$3@> << " not found in `signal_name_map'.  "
             << "Server not raising signal " << @=$3@> << "."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex(); 

        ++param->errors_occurred;

    }  /* |if|  */

@q ***** (5) @>

    else if (signal_server_enabled)
    {
#if DEBUG_COMPILE 
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
                 << "`statement: SIGNAL_YY SERVER_YY INTEGER_YY':"
                 << endl
                 << "Sending signal " << iter->second << " (" << iter->first << ") "
                 << "to main thread."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

        lock_cout_mutex();
        lock_cerr_mutex();
        cout << "Sending signal " << iter->second << " (" << iter->first << ") "
             << "to main thread."
             << endl;
        unlock_cerr_mutex();
        unlock_cout_mutex();  

        pthread_kill(thread_ctr_id_map[0], iter->first);

    }  /* |else if (signal_server_enabled)|  */

@q ***** (5) @>

    else /* |!signal_server_enabled|  */
    {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] WARNING!  In `yyparse', rule "
                 << "`statement: SIGNAL_YY SERVER_YY INTEGER_YY':"
                 << endl
                 << "`signal_server_enabled' == `false'.  "
                 << "Server not raising signal " << iter->second << " (" << iter->first << ")."
                 << endl
                 << "Continuing."
                 << endl;
            unlock_cerr_mutex(); 

            ++param->warnings_occurred;

    } /* |else| (|!signal_server_enabled|)  */

@q ***** (5) @>

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> SIGNAL_YY SERVER_YY STRING_YY @>

@ \<statement> $\longrightarrow$ \.{SIGNAL\_YY} \.{SERVER\_YY} \.{STRING\_YY}.
\initials{LDF 2013.05.02.}

\LOG
\initials{LDF 2013.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SIGNAL_YY SERVER_YY STRING_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`statement: SIGNAL_YY SERVER_YY STRING_YY'."
             << endl
             << "`STRING_YY' == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    multimap<string, int>::iterator iter = signal_number_map.find(string(@=$3@>));

    if (iter == signal_number_map.end())
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] ERROR!  In `yyparse', rule "
             << "`statement: SIGNAL_YY SERVER_YY STRING_YY':"
             << endl
             << "Signal " << @=$3@> << " not found in `signal_number_map'.  "
             << "Server not raising signal."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex(); 

        ++param->errors_occurred;

    }  /* |if|  */

@q ***** (5) @>

    else if (signal_server_enabled)
    {
#if DEBUG_COMPILE 
         if (param->PARSER_DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "[Thread " << param->thread_ctr << "] "
                  << "`statement: SIGNAL_YY SERVER_YY STRING_YY':"
                  << endl
                  << "Signal number == " << iter->second
                  << endl
                  << "Sending signal " << signal_name_map[iter->second] 
                  << " (" << iter->second << ") to main thread."
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

         lock_cout_mutex();
         lock_cerr_mutex();
         cout << "Sending signal " << signal_name_map[iter->second] 
              << " (" << iter->second << ") to main thread."
              << endl;
         unlock_cerr_mutex();
         unlock_cout_mutex();  

         pthread_kill(thread_ctr_id_map[0], iter->second);

    }  /* |else if (signal_server_enabled)|  */

@q ***** (5) @>

    else /* |!signal_server_enabled|  */
    {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] WARNING!  In `yyparse', rule "
                 << "`statement: SIGNAL_YY SERVER_YY STRING_YY':"
                 << endl
                 << "`signal_server_enabled' == `false'.  "
                 << "Server not raising signal " << signal_name_map[iter->second] << " "
                 << "(" << iter->second << ")."
                 << endl
                 << "Continuing."
                 << endl;
            unlock_cerr_mutex(); 

            ++param->warnings_occurred;

    } /* |else| (|!signal_server_enabled|)  */

@q ***** (5) @>

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> SIGNAL_YY CLIENT_YY INTEGER_YY @>

@ \<statement> $\longrightarrow$ \.{SIGNAL\_YY} \.{CLIENT\_YY} \.{INTEGER\_YY}.
\initials{LDF 2013.05.02.}

\LOG
\initials{LDF 2013.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SIGNAL_YY CLIENT_YY INTEGER_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`statement: SIGNAL_YY CLIENT_YY INTEGER_YY'."
             << endl
             << "`INTEGER_YY' == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    map<int, string>::iterator iter = signal_name_map.find(@=$3@>);

    if (iter == signal_name_map.end())
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] ERROR!  In `yyparse', rule "
             << "`statement: SIGNAL_YY CLIENT_YY INTEGER_YY':"
             << endl
             << "Signal number " << @=$3@> << " not found in `signal_name_map'.  "
             << "Server not sending `SIGNAL' command to client."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex(); 

        ++param->errors_occurred;

    }  /* |if|  */

@q ***** (5) @>

    else if (signal_client_enabled)
    {
#if DEBUG_COMPILE 
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "]  In `yyparse', rule "
                 << "`statement: SIGNAL_YY CLIENT_YY INTEGER_YY':"
                 << endl
                 << "Sending `SIGNAL " << @=$3@>  << "' command to  client."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

        Response_Type response;
        response.type = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm.str("");

        temp_strm << "SIGNAL " << @=$3@>;

        response.command = temp_strm.str();

        temp_strm.str("");

        param->response_deque.push_back(response);

    }  /* |else if (signal_client_enabled)|  */


@q ***** (5) @>

    else /* |!signal_client_enabled|  */
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "]  WARNING!  In `yyparse', rule "
             << "`statement: SIGNAL_YY CLIENT_YY INTEGER_YY':"
             << endl
             << "`signal_client_enabled' == `false'.  Not sending "
             << "`SIGNAL " << @=$3@>  << "' command to  client"
             << endl 
             << "(signal " << iter->second << " == " << iter->first << ")."
             << endl;
        unlock_cerr_mutex(); 

        ++param->warnings_occurred;

    }  /* |else| (|!signal_client_enabled|)  */

@q ***** (5) @>

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> SIGNAL_YY CLIENT_YY STRING_YY @>

@ \<statement> $\longrightarrow$ \.{SIGNAL\_YY} \.{CLIENT\_YY} \.{STRING\_YY}.
\initials{LDF 2013.05.02.}

\LOG
\initials{LDF 2013.05.02.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: SIGNAL_YY CLIENT_YY STRING_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "]  In `yyparse', rule "
             << "`statement: SIGNAL_YY CLIENT_YY STRING_YY'."
             << endl
             << "`STRING_YY' == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>

    multimap<string, int>::iterator iter = signal_number_map.find(string(@=$3@>));

    if (iter == signal_number_map.end())
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] ERROR!  In `yyparse', rule "
             << "`statement: SIGNAL_YY CLIENT_YY STRING_YY':"
             << endl
             << "Signal " << @=$3@> << " not found in `signal_number_map'.  "
             << endl 
             << "Not sending `SIGNAL' command to client."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex(); 

        ++param->errors_occurred;

    }  /* |if|  */

@q ***** (5) @>

    else if (signal_client_enabled)
    {
#if DEBUG_COMPILE 
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "]  In `yyparse', rule "
                 << "`statement: SIGNAL_YY CLIENT_YY STRING_YY':"
                 << endl
                 << "Signal name == " << iter->first
                 << endl
                 << "Signal number == " << iter->second
                 << endl
                 << "Sending `SIGNAL " << iter->second << "' command to client."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

        Response_Type response;
        response.type = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm.str("");

        temp_strm << "SIGNAL " << iter->second;

        response.command = temp_strm.str();

        temp_strm.str("");

        param->response_deque.push_back(response);


    }  /* |else if (signal_client_enabled)|  */

@q ***** (5) @>

    else /* |!signal_client_enabled|  */
    {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "]  WARNING!  In `yyparse', rule "
              << "`statement: SIGNAL_YY CLIENT_YY STRING_YY':"
              << endl
              << "`signal_client_enabled' == `false'.  Not sending "
              << "`SIGNAL " << iter->second  << "' command to  client"
              << endl 
              << "(signal " << iter->first << " == " << iter->second << ")."
              << endl;
         unlock_cerr_mutex(); 

         ++param->warnings_occurred;

    }  /* |else| (|!signal_client_enabled|)  */

@q ***** (5) @>

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> SHOW_YY CERTIFICATE_YY [USER_YY]. @>

@ \<statement> $\longrightarrow$ \.{SHOW\_YY} \.{CERTIFICATE\_YY}\hfil\break 
and\hfil\break 
\<statement> $\longrightarrow$ \.{SHOW\_YY} \.{CERTIFICATE\_YY} \.{USER\_YY}.
\initials{LDF 2013.05.03.}

\LOG
\initials{LDF 2013.05.03.}
Added these rules.  They share an action.  
@:??@> ?? I wasn't able to get this to work using a vertical-bar
character ($\vert$), as described in the GNU Bison manual.  The file 
\filename{parser.y++} generated by \.{ctangle} looks correct, however.
Both rules were reduced correctly, but the action was only performed for 
the second rule.
\par
Instead, I've used a named CWEB section and include it under each rule.
\ENDLOG

@<Rules@>=
@=statement:   SHOW_YY CERTIFICATE_YY @>
@<show certificate user action@>@;@/

@=statement:   SHOW_YY CERTIFICATE_YY USER_YY @>
@<show certificate user action@>@;@/

@q ***** (5) @>
@
@<show certificate user action@>=
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: SHOW_YY CERTIFICATE_YY [USER_YY]'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;

    response.type = Response_Type::SHOW_CERTIFICATE_TYPE;

    response.int_val = 1;  /* Show single certificate, i.e., the user's. 
                              \initials{LDF 2013.05.15.}  */

    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) statement --> SHOW_YY CERTIFICATES_YY [ALL_YY]. @>

@ \<statement> $\longrightarrow$ \.{SHOW\_YY} \.{CERTIFICATES\_YY}\hfil\break 
and\hfil\break 
\<statement> $\longrightarrow$ \.{SHOW\_YY} \.{CERTIFICATES\_YY} \.{ALL\_YY}.
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added these rules.  They share an action.  
I've used a named CWEB section and include it under each rule, as for the 
corresponding rule for showing only the user's certificate.
\ENDLOG

@<Rules@>=
@=statement:   SHOW_YY CERTIFICATES_YY @>
@<show certificates all action@>@;@/

@=statement:   SHOW_YY CERTIFICATES_YY ALL_YY @>
@<show certificates all action@>@;@/

@q ***** (5) @>
@
@<show certificates all action@>=
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`statement: SHOW_YY CERTIFICATES_YY [ALL_YY]'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;

    if (param->privileges & Scan_Parse_Parameter_Type::SHOW_CERTIFICATES_PRIVILEGE)
    {
        response.type = Response_Type::SHOW_CERTIFICATE_TYPE;

        response.int_val = 0;  /* Show all certificates.  
                                  \initials{LDF 2013.05.15.}  */

#if DEBUG_COMPILE
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
                 << "`statement: SHOW_YY CERTIFICATES_YY [ALL_YY]':"
                 << endl
                 << "User " << param->username << " (User ID " << param->user_id << ") "
                 << "has the \"show certificates\" privilege."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    }  /* |if|  */

    else
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] WARNING!  In `yyparse', rule "
             << "`statement: SHOW_YY CERTIFICATES_YY [ALL_YY]':"
             << endl
             << "User " << param->username << " (User ID " << param->user_id << ") "
             << "doesn't have the \"show certificates\" privilege."
             << endl
             << "Sending warning to client and continuing."
             << endl;
        unlock_cerr_mutex(); 

        ++param->warnings_occurred; 

        response.type = Response_Type::COMMAND_ONLY_TYPE;

        response.command = "SHOW CERTIFICATE RESPONSE 3";

    }  /* |else|  */

    

    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> SHOW_YY GROUPS_YY ALL_YY. @>

@ \<statement> $\longrightarrow$ \.{SHOW\_YY} \.{GROUPS\_YY} \.{ALL\_YY}.
\initials{LDF 2013.06.05.}

\LOG
\initials{LDF 2013.06.05.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement:   SHOW_YY GROUPS_YY ALL_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`statement: SHOW_YY GROUPS_YY ALL_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

    temp_strm.str("");

    if (param->privileges & Scan_Parse_Parameter_Type::SHOW_GROUPS_PRIVILEGE)
    {
@q ****** (6) @>

#if DEBUG_COMPILE
        if (param->PARSER_DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
                 << "`statement: SHOW_YY GROUPS_YY ALL_YY':"
                 << endl
                 << "User " << param->username << " (User ID " << param->user_id << ") "
                 << "has the \"show groups\" privilege."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>


        status = Group_Type::get_all_groups(param->mysql_ptr, 
                                            param->group_vector, 
                                            param->thread_ctr);

@q ****** (6) @>

        if (status != 0)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << param->thread_ctr << "] ERROR!  In `yyparse', rule "
                 << "`statement: SHOW_YY GROUPS_YY ALL_YY':"
                 << endl
                 << "`Group_Type::get_all_groups' failed, returning " << status << "."
                 << endl
                 << "Sending error message to client and continuing."
                 << endl;
            unlock_cerr_mutex(); 

            ++param->errors_occurred; 

            temp_strm << "SHOW GROUPS RESPONSE 1 \"Server-side error:  "
                      << "`Group_Type::get_all_groups' failed.\"";


        }  /* |if (status != 0)|  */

@q ****** (6) @>

        else 
        {
@q ******* (7) @>

#if DEBUG_COMPILE
            if (param->PARSER_DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
                     << "`statement: SHOW_YY GROUPS_YY ALL_YY':"
                     << endl
                     << "`Group_Type::get_all_groups' succeeded, returning 0."
                     << endl
                     << "`param->group_vector.size()':  " << param->group_vector.size()
                     << endl;

                 if (param->group_vector.size() > 0)
                 {
                     cerr << "`param->group_vector':"
                          << endl;

                     for (vector<Group_Type>::iterator iter = param->group_vector.begin();
                          iter != param->group_vector.end();
                          ++iter)
                     { 
                          iter->show();
                     }
                     cerr << endl;

                 }  /* |if|  */

                unlock_cerr_mutex(); 

            }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

            temp_strm << "SHOW GROUPS RESPONSE 0 \"Success\" ";
  
            for (vector<Group_Type>::iterator iter = param->group_vector.begin();
                          iter != param->group_vector.end();
                          ++iter)
            { 
@q ******** (8) @>

                temp_strm << "GROUP_ID " << iter->group_id << " "
                          << "GROUP_NAME " << iter->group_name << " "
                          << "CREATOR_ID " << iter->creator_id << " "
                          << "CREATOR_USERNAME " << iter->creator_username << " "
                          << "CREATED " << iter->created << "U ";




@q ******** (8) @>

                for (map<int, pair<string, unsigned int> >::iterator iter_1 
                        = iter->member_id_map.begin();
                     iter_1 != iter->member_id_map.end();
                     ++iter_1)
                {
@q ********* (9) @>

                    temp_strm << "USER_ID " << iter_1->first << " "
                              << "USER_NAME \"" <<  iter_1->second.first << "\" "
                              << "PRIVILEGES " << iter_1->second.second << "U ";

@q ********* (9) @>

                }  /* inner |for|  */



@q ******** (8) @>

            }  /* outer |for|  */

@q ******* (7) @>
 

#if DEBUG_COMPILE
            if (param->PARSER_DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
                     << "`statement: SHOW_YY GROUPS_YY ALL_YY':"
                     << endl
                     << "`temp_strm.str() == " << temp_strm.str()
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

        }  /* |else|  */

@q ****** (6) @>

    }  /* |if|  */

@q ***** (5) @>

    else
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] WARNING!  In `yyparse', rule "
             << "`statement: SHOW_YY GROUPS_YY ALL_YY':"
             << endl
             << "User " << param->username << " (User ID " << param->user_id << ") "
             << "doesn't have the \"show groups\" privilege."
             << endl
             << "Sending warning to client and continuing."
             << endl;
        unlock_cerr_mutex(); 

        ++param->warnings_occurred; 

        temp_strm << "SHOW GROUPS RESPONSE 3 \"Server-side error:\"";

    }  /* |else|  */

    response.command = temp_strm.str();

    temp_strm.str("");

    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};


@q **** (4) statement: PROCESS_YY PENDING_YY               @>
@q **** (4) and                                            @>
@q **** (4) statement: PROCESS_YY PENDING_YY OPERATIONS_YY @>

@ \<statement> $\longrightarrow$ \.{PROCESS\_YY} \.{PENDING\_YY}
and 
@ \<statement> $\longrightarrow$ \.{PROCESS\_YY} \.{PENDING\_YY}
\.{OPERATIONS\_YY}.
\initials{LDF 2013.05.23.}

\LOG
\initials{LDF 2013.05.23.}
Added these rules.  They share an action.
\ENDLOG

@q ***** (5) @>

@<Rules@>=
@=statement: PROCESS_YY PENDING_YY @>
@<process pending operations action@>@;@/

@q ***** (5) @>
@
@<Rules@>=
@=statement: PROCESS_YY PENDING_YY OPERATIONS_YY @>
@<process pending operations action@>@;@/

@q ***** (5) process pending operations action @>

@ process pending operations action.
\initials{LDF 2013.05.23.}

\LOG
\initials{LDF 2013.05.23.}
Added this section.
\ENDLOG

@<process pending operations action@>=
{
@q ***** (5) @>

     Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

     bool save_PARSER_DEBUG = param->PARSER_DEBUG;
     param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] "
              << "In `yyparse', rule `statement: PROCESS_YY PENDING_YY [OPERATIONS]'." 
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

     Response_Type response;

     response.type = Response_Type::PROCESS_PENDING_TYPE;

     param->response_deque.push_back(response);

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q **** (4) statement --> CREATE_YY HANDLE_YY handle_option_list @>

@ \<statement> $\longrightarrow$ \.{CREATE\_YY} \.{HANDLE\_YY}
\<handle option list>.
\initials{LDF 2013.05.24.}

\LOG
\initials{LDF 2013.05.24.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: CREATE_YY HANDLE_YY handle_option_list @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

@q ***** (5) @>

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: CREATE_YY HANDLE_YY handle_option_list'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    Response_Type response;
    response.type = Response_Type::PROCESS_PENDING_TYPE;

    param->response_deque.push_back(response);

    response.type = Response_Type::CREATE_HANDLE_TYPE;

    response.string_vector = param->string_vector;

    response.pid_str           = param->pid_str;
    response.pid_prefix_str    = param->pid_prefix_str;
    response.pid_suffix_str    = param->pid_suffix_str;
    response.pid_institute_str = param->pid_institute_str;

    if (response.pid_prefix_str.empty())
       response.pid_prefix_str = param->default_handle_prefix;

#if 0
    /* Not putting the institute name into the handle  
       \initials{LDF 2013.05.24.}
    */
 
    if (response.pid_institute_str.empty())
       response.pid_institute_str = param->default_institute_name;
#endif 

    lock_cerr_mutex();   
    cerr << "param->default_handle_prefix == " << param->default_handle_prefix
         << endl 
         << "response.pid_str == " << response.pid_str << endl
         << "response.pid_prefix_str == " << response.pid_prefix_str << endl
         << "response.pid_suffix_str == " << response.pid_suffix_str << endl
         << "response.pid_institute_str == " << response.pid_institute_str << endl;
    unlock_cerr_mutex(); 

    param->response_deque.push_back(response);

    param->pid_str =  param->pid_prefix_str 
       = param->pid_suffix_str = param->pid_institute_str = "";

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> ADD_YY HANDLE_VALUE_YY handle_option_list @>

@ \<statement> $\longrightarrow$ \.{ADD\_YY} \.{HANDLE\_VALUE\_YY}
\<handle option list>.
\initials{LDF 2013.06.15.}

\LOG
\initials{LDF 2013.06.15.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: ADD_YY HANDLE_VALUE_YY handle_option_list @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

@q ***** (5) @>

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: ADD_YY HANDLE_VALUE_YY handle_option_list'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

    Response_Type response;
    response.pid_str = param->pid_str;

    response.hvt = param->hvt;

    response.hvt.show("response.hvt:");

    param->hvt.clear();

    param->pid_str = "";
    
    response.type = Response_Type::ADD_HANDLE_VALUE_TYPE;
    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) handle_option_list.  @>

@ \<handle option list>.  

\LOG
\initials{LDF 2013.05.24.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> handle_option_list@>
@=%type <int_value> handle_option@>

@q ***** (5) handle_option_list:  /* Empty  */@>
@ \<handle option list> $\longrightarrow$ \.{Empty}.

\LOG
\initials{LDF 2013.05.24.}
Added this rule.
\ENDLOG

@<Rules@>=
@=handle_option_list: /* Empty  */@>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `handle_option_list: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->pid_str =  param->pid_prefix_str 
       = param->pid_suffix_str = param->pid_institute_str = "";

    param->hvt.clear();


    param->PARSER_DEBUG = save_PARSER_DEBUG; 
    

};

@q ***** (5) handle_option_list:  handle_option_list handle_option @>
@ \<handle option list> $\longrightarrow$ \<handle option list> \<handle option>.

\LOG
\initials{LDF 2013.05.24.}
Added this rule.
\ENDLOG

@<Rules@>=
@=handle_option_list: handle_option_list handle_option @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `handle_option_list: handle_option_list handle_option'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 
    param->PARSER_DEBUG = save_PARSER_DEBUG; 
    

};

@q ***** (5) handle_option: STRING_YY @>
@ \<handle option list> $\longrightarrow$ \.{STRING\_YY}.
\initials{LDF 2013.05.24.}

\LOG
\initials{LDF 2013.06.15.}
Added this rule.
\ENDLOG

@<Rules@>=
@=handle_option: STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `handle_option: STRING_YY' (PID string)." 
             << endl
             << "`STRING_YY' (1):  " << @=$1@>
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->pid_str = @=$1@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) handle_option: PID_YY STRING_YY @>
@ \<handle option list> $\longrightarrow$ \.{PID\_YY} \.{STRING\_YY}.
\initials{LDF 2013.05.24.}

\LOG
\initials{LDF 2013.05.24.}
Added this rule.
\ENDLOG

@<Rules@>=
@=handle_option: PID_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `handle_option: PID_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->pid_str = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) handle_option: IDX_YY INTEGER_YY @>
@ \<handle option list> $\longrightarrow$ \.{IDX\_YY} \.{INTEGER\_YY}.
\initials{LDF 2013.06.16.}

\LOG
\initials{LDF 2013.06.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=handle_option: IDX_YY INTEGER_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `handle_option: IDX_YY INTEGER_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->hvt.idx = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) handle_option: TYPE_YY STRING_YY @>
@ \<handle option list> $\longrightarrow$ \.{TYPE\_YY} \.{STRING\_YY}.
\initials{LDF 2013.06.16.}

\LOG
\initials{LDF 2013.06.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=handle_option: TYPE_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `handle_option: TYPE_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->hvt.type = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) handle_option: DATA_YY STRING_YY @>
@ \<handle option list> $\longrightarrow$ \.{DATA\_YY} \.{STRING\_YY}.
\initials{LDF 2013.06.16.}

\LOG
\initials{LDF 2013.06.16.}
Added this rule.
\ENDLOG

@<Rules@>=
@=handle_option: DATA_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `handle_option: DATA_YY STRING_YY'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->hvt.data_str = @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> DELETE_YY HANDLE_YY delete_handle_option_list STRING_YY  @>

@ \<statement> $\longrightarrow$ \.{DELETE\_YY} \.{HANDLE\_YY} \<delete handle option list> 
\.{STRING\_YY}
\initials{LDF 2013.07.04.}

\LOG
\initials{LDF 2013.07.04.}
Added this rule.

\initials{LDF 2013.09.16.}
Put \<delete handle option list> before \.{STRING\_YY}.
\ENDLOG

@<Rules@>=

@=statement: DELETE_YY HANDLE_YY delete_handle_option_list STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DELETE_YY HANDLE_YY delete_handle_option_list STRING_YY'."
             << endl
             << "`STRING_YY' (Handle)        == " << @=$3@>
             << endl 
             << "`delete_handle_option_list' == " << hex << @=$4@> << " (hex)"
             << dec 
             << "`param->delay_value' == " << param->delay_value
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;
    response.pid_options = @=$3@>;
    response.pid_str     = @=$4@>;
    response.delay_value = param->delay_value;

    param->delay_value = 0UL;

    response.type = Response_Type::DELETE_HANDLE_TYPE;
    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) delete_handle_option_list and delete_handle_option @>

@ \<delete handle option list> and \<delete handle option>.
\initials{LDF 2013.07.04.}

\LOG
\initials{LDF 2013.07.04.}
Added these type declarations.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> delete_handle_option_list @>
@=%type <uint_value> delete_handle_option      @>

@q ***** (5) delete_handle_option_list: /* Empty  */ @>

@ \<delete handle option list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2013.07.04.}

\LOG
\initials{LDF 2013.07.04.}
Added this rule.
\ENDLOG

@<Rules@>=

@=delete_handle_option_list: /* Empty  */ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`delete_handle_option_list: /* Empty  */'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   @=$$@> = 0U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) delete_handle_option_list: delete_handle_option_list delete_handle_option @>

@ \<delete handle option list> $\longrightarrow$ \<delete handle option list> 
\<delete handle option> 
\initials{LDF 2013.07.04.}

\LOG
\initials{LDF 2013.07.04.}
Added this rule.
\ENDLOG

@<Rules@>=

@=delete_handle_option_list: delete_handle_option_list delete_handle_option @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`delete_handle_option_list: delete_handle_option_list delete_handle_option'."
             << endl
             << "`delete_handle_option_list' ($1) == " << hex << @=$1@> << " (hex) "
             << endl
             << "`delete_handle_option' ($2)      == " << @=$2@> << " (hex) "
             << endl 
             << "Result (OR)                      == " << (@=$1@> | @=$2@>) << " (hex) "
             << dec
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 
};

@q ***** (5) delete_handle_option_list: delete_handle_option_list sub_delay_option @>

@ \<delete handle option list> $\longrightarrow$ \<delete handle option list> 
\<sub-delay  option> 
\initials{LDF 2013.08.26.}

\LOG
\initials{LDF 2013.08.26.}
Added this rule.
\ENDLOG

@<Rules@>=

@=delete_handle_option_list: delete_handle_option_list sub_delay_option @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`delete_handle_option_list: delete_handle_option_list sub_delay_option'."
             << endl
             << "`delete_handle_option_list' ($1) == " << hex << @=$1@> << " (hex) "
             << endl
             << dec
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@>;

    if (param->delay_value > 0UL)
    {
       @=$$@> &= ~1UL;  /* Unset ``immediate'' bit.  \initials{LDF 2013.08.26.}  */
    }

    param->PARSER_DEBUG = save_PARSER_DEBUG; 
};



@q ***** (5) delete_handle_option: IMMEDIATE_YY @>

@ \<delete handle option> $\longrightarrow$ \.{IMMEDIATE\_YY}.
\initials{LDF 2013.07.04.}

\LOG
\initials{LDF 2013.07.04.}
Added this rule.

\initials{LDF 2013.08.26.}
Now setting |param->delay_value = 0UL|.
\ENDLOG

@<Rules@>=

@=delete_handle_option: IMMEDIATE_YY @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`delete_handle_option: IMMEDIATE_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   @=$$@> = 1U;

   param->delay_value = 0UL;

   param->PARSER_DEBUG = save_PARSER_DEBUG; 
};




@q **** (4) statement --> UNDELETE_YY HANDLE_YY STRING_YY @>

@ \<statement> $\longrightarrow$ \.{UNDELETE\_YY} \.{HANDLE\_YY} \.{STRING\_YY}.
\initials{LDF 2013.08.21.}

\LOG
\initials{LDF 2013.08.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: UNDELETE_YY HANDLE_YY STRING_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`statement: UNDELETE_YY HANDLE_YY STRING_YY':"
             << endl
             << "`STRING_YY' ($3) (handle) == " << @=$3@> 
             << endl;
         unlock_cerr_mutex();
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;

    response.type = Response_Type::PROCESS_PENDING_TYPE;

    param->response_deque.push_back(response);

    response.type = Response_Type::UNDELETE_HANDLE_TYPE;

    response.pid_str = @=$3@>;

    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) statement --> DELETE_YY HANDLE_VALUE_YY delete_handle_option_list STRING_YY  @>
@q **** (4) statement --> DELETE_YY HANDLE_VALUES_YY delete_handle_option_list STRING_YY @>
@q **** (4) statement --> DELETE_YY HANDLE_VALUE_YY delete_handle_option_list            @>
@q **** (4)               HANDLE_VALUE_SPECIFICATION_YY                                  @>
@q **** (4) statement --> DELETE_YY HANDLE_VALUES_YY delete_handle_option_list           @>
@q **** (4)               HANDLE_VALUE_SPECIFICATION_YY                                  @>

@ \<statement> $\longrightarrow$ \.{DELETE\_YY} \.{HANDLE\_VALUE\_YY} 
\<delete handle option list> \.{STRING\_YY}\hfil\break 
%
\<statement> $\longrightarrow$ \.{DELETE\_YY} \.{HANDLE\_VALUES\_YY} 
\<delete handle option list> \.{STRING\_YY}\hfil\break
%
\<statement> $\longrightarrow$ \.{DELETE\_YY} \.{HANDLE\_VALUE\_YY} 
\<delete handle option list> \.{HANDLE\_VALUE\_SPECIFICATION\_YY}\hfil\break 
%
\<statement> $\longrightarrow$ \.{DELETE\_YY} \.{HANDLE\_VALUES\_YY} 
\<delete handle option list> \.{HANDLE\_VALUE\_SPECIFICATION\_YY}\hfil\break 
\initials{LDF 2013.07.17.}

\LOG
\initials{LDF 2013.07.17.}
Added this rule.

\initials{LDF 2013.09.11.}
Added the rules with \.{HANDLE\_VALUES\_YY}.  These four rules shaare an action.
Added \<delete handle option list> to all of these rules.

\initials{LDF 2013.09.16.}
Put \<delete handle option list> before \.{STRING\_YY} or 
\.{HANDLE\_VALUE\_SPECIFICATION\_YY} in all of these rules.
\ENDLOG

@<Rules@>=

@=statement: DELETE_YY HANDLE_VALUE_YY delete_handle_option_list STRING_YY@>
@<Delete handle value or values@>@;

@=statement: DELETE_YY HANDLE_VALUES_YY delete_handle_option_list STRING_YY @>
@<Delete handle value or values@>@;

@=statement: DELETE_YY HANDLE_VALUE_YY delete_handle_option_list HANDLE_VALUE_SPECIFICATION_YY @>
@<Delete handle value or values@>@;

@=statement: DELETE_YY HANDLE_VALUES_YY delete_handle_option_list HANDLE_VALUE_SPECIFICATION_YY @>
@<Delete handle value or values@>@;

@q ***** (5) @>
@
\LOG
\initials{LDF 2013.09.11.}
Added this section.

\initials{LDF 2013.09.16.}
Put \<delete handle option list> before \.{STRING\_YY} or \.{HANDLE\_VALUE\_SPECIFICATION\_YY} 
in all of these rules.
\ENDLOG

@<Delete handle value or values@>=
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DELETE_YY HANDLE_VALUE_YY STRING_YY'"
             << endl 
             << "or `statement: DELETE_YY HANDLE_VALUES_YY STRING_YY delete_handle_option_list'"
             << endl 
             << "or `statement: DELETE_YY HANDLE_VALUE_YY HANDLE_VALUE_SPECIFICATION_YY "
             << "delete_handle_option_list '"
             << endl
             << "or `statement: DELETE_YY HANDLE_VALUE_YY HANDLE_VALUES_SPECIFICATION_YY "
             << "delete_handle_option_list ':"
             << endl
             << "`delete_handle_option_list'                     == " 
             << oct << @=$3@> << " (octal)" << dec
             << endl
             << "`STRING_YY' or `HANDLE_VALUES_SPECIFICATION_YY' == " << @=$4@>
             << endl
             << "`param->delay_value'                            == " 
             << param->delay_value 
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;

    response.type = Response_Type::PROCESS_PENDING_TYPE;
    param->response_deque.push_back(response);

    response.delay_value = param->delay_value;

    response.options = @=$3@>;
    response.no_delay = (param->delay_value == 0 || @=$3@> & 1U) ? true : false;

    response.type = Response_Type::DELETE_HANDLE_VALUE_TYPE;
    response.string_val = @=$4@>;

    param->response_deque.push_back(response);

    param->delay_value = 0UL;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> UNDELETE_YY HANDLE_VALUE_YY STRING_YY                      @>
@q **** (4) statement --> UNDELETE_YY HANDLE_VALUES_YY STRING_YY                     @>
@q **** (4) statement --> UNDELETE_YY HANDLE_VALUE_YY HANDLE_VALUE_SPECIFICATION_YY  @>
@q **** (4) statement --> UNDELETE_YY HANDLE_VALUES_YY HANDLE_VALUE_SPECIFICATION_YY @>

@ \<statement> $\longrightarrow$ \.{UNDELETE\_YY} \.{HANDLE\_VALUE\_YY} 
\.{STRING\_YY}\hfil\break 
%
\<statement> $\longrightarrow$ \.{UNDELETE\_YY} \.{HANDLE\_VALUES\_YY} 
\.{STRING\_YY}\hfil\break
%
\<statement> $\longrightarrow$ \.{UNDELETE\_YY} \.{HANDLE\_VALUE\_YY} 
\.{HANDLE\_VALUE\_SPECIFICATION\_YY}\hfil\break 
%
\<statement> $\longrightarrow$ \.{UNDELETE\_YY} \.{HANDLE\_VALUES\_YY} 
\.{HANDLE\_VALUE\_SPECIFICATION\_YY}\hfil\break 
\initials{LDF 2013.07.17.}

\LOG
\initials{LDF 2013.07.17.}
Added these rules.
\ENDLOG

@<Rules@>=

@=statement: UNDELETE_YY HANDLE_VALUE_YY STRING_YY @>
@<Undelete handle value or values@>@;

@=statement: UNDELETE_YY HANDLE_VALUES_YY STRING_YY @>
@<Undelete handle value or values@>@;

@=statement: UNDELETE_YY HANDLE_VALUE_YY HANDLE_VALUE_SPECIFICATION_YY @>
@<Undelete handle value or values@>@;

@=statement: UNDELETE_YY HANDLE_VALUES_YY HANDLE_VALUE_SPECIFICATION_YY @>
@<Undelete handle value or values@>@;

@q ***** (5) Undelete handle value or values.  @>
@ Undelete handle value or values.
\initials{LDF 2013.09.11.}

\LOG
\initials{LDF 2013.09.11.}
Added this section.
\ENDLOG

@<Undelete handle value or values@>=
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: UNDELETE_YY HANDLE_VALUE_YY STRING_YY'"
             << endl 
             << "or `statement: UNDELETE_YY HANDLE_VALUES_YY STRING_YY'"
             << endl 
             << "or `statement: UNDELETE_YY HANDLE_VALUE_YY HANDLE_VALUE_SPECIFICATION_YY'"
             << endl
             << "or `statement: UNDELETE_YY HANDLE_VALUE_YY HANDLE_VALUES_SPECIFICATION_YY'"
             << endl
             << "`STRING_YY' or `HANDLE_VALUES_SPECIFICATION_YY' == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;

    response.type = Response_Type::PROCESS_PENDING_TYPE;
    param->response_deque.push_back(response);

    response.type = Response_Type::UNDELETE_HANDLE_VALUE_TYPE;
    response.string_val = @=$3@>;

    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> UNDELETE_YY undelete_option_list filename_list @>

@ \<statement> $\longrightarrow$ \.{UNDELETE\_YY} \<undelete option list> \<filename list>.
\initials{LDF 2013.08.15.}

\LOG
\initials{LDF 2013.08.15.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: UNDELETE_YY undelete_option_list filename_list @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`statement: UNDELETE_YY undelete_option_list filename_list':"
             << endl
             << "`undelete_option_list' ($2) == " << oct << "0" << @=$2@> << " (octal) " << dec
             << endl 
             << "`filename_vector' == " 
             << endl;

        for (vector<string>::const_iterator iter = param->filename_vector.begin();
             iter != param->filename_vector.end();
             ++iter)
        {
            cerr << *iter << endl;    
        }

        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;

    response.type = Response_Type::PROCESS_PENDING_TYPE;

    param->response_deque.push_back(response);

    response.type = Response_Type::UNDELETE_FILE_TYPE;

    response.string_vector = param->filename_vector;
    response.options = @=$2@>;

    param->response_deque.push_back(response);

    param->filename_vector.clear();

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) undelete_option_list.  @>
@ \<undelete option list>.
\initials{LDF 2013.08.15.}

\LOG
\initials{LDF 2013.08.15.}
Added this section.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> undelete_option_list@>
@=%type <uint_value> undelete_option@>

@q ***** (5) undelete_option_list: /* Empty */ @>

@ \<undelete option list> $\longrightarrow$ \.{Empty}  @>
\initials{LDF 2013.08.15.}

\LOG
\initials{LDF 2013.08.15.}
Added this rule.
\ENDLOG

@<Rules@>=
@=undelete_option_list: /* Empty */ @>
{

    Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`undelete_option_list:  /* Empty  */ "
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     @=$$@> = 0U;

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) undelete_option_list: undelete_option_list undelete_option @>

@ \<undelete option list> $\longrightarrow$ \<undelete option list> \<undelete option>  @>
\initials{LDF 2013.08.15.}

\LOG
\initials{LDF 2013.08.15.}
Added this rule.
\ENDLOG

@<Rules@>=
@=undelete_option_list: undelete_option_list undelete_option @>
{

    Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`undelete_option_list:  undelete_option_list undelete_option'"
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     if (@=$2@> == 1U && @=$1@> && 2U)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] WARNING!"
              << endl
              << "In `yyparse':  Option `database' used and option `database-only' "
              << "already set."
              << endl
              << "The last option used takes precedence:  Setting `database' option"
              << endl
              << "and unsetting `database-only'."
              << endl;
         unlock_cerr_mutex(); 

         temp_strm.str();
         temp_strm << "DATABASE OPTION RESPONSE 2 \"WARNING!  Multiple database options used." 
                   << endl 
                   << "The last one takes precedence."
                   << endl 
                   << "Setting `database' and unsetting `database-only'.\"";
                  

         response.command = temp_strm.str();
         temp_strm.str();
 
         param->response_deque.push_back(response);

         ++param->warnings_occurred;;

         @=$$@> &= ~2U;
         @=$$@> |=  1U;
     }
     else if (@=$2@> == 2U && @=$1@> && 1U)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] WARNING!"
              << endl
              << "In `yyparse':  Option `database-only' used and option `database' "
              << "already set."
              << endl
              << "The last option used takes precedence:  Setting `database-only' option"
              << endl
              << "and unsetting `database'."
              << endl;
         unlock_cerr_mutex(); 

         temp_strm.str();
         temp_strm << "DATABASE OPTION RESPONSE 2 \"WARNING!  Multiple database options used." 
                   << endl 
                   << "The last one takes precedence."
                   << endl 
                   << "Setting `database-only' and unsetting `database'.\"";

         response.command = temp_strm.str();
         temp_strm.str();
 
         ++param->warnings_occurred;;

         param->response_deque.push_back(response);

         @=$$@> &= ~1U;
         @=$$@> |=  2U;
     }
     else
        @=$$@> = @=$1@> | @=$2@>;



     param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) undelete_option: database_option @>

@ \<undelete option> $\longrightarrow$ \<database option>  @>
\initials{LDF 2013.08.15.}

\LOG
\initials{LDF 2013.08.15.}
Added this rule.
\ENDLOG

@<Rules@>=
@=undelete_option: database_option  @>
{

    Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`undelete_option: database_option'"
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     @=$$@> |= @=$1@>;

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) database_option.  @>
@ \<undelete option>.
\initials{LDF 2013.08.15.}

\LOG
\initials{LDF 2013.08.15.}
Added this section.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> database_option@>


@q ***** (5) database_option: DATABASE_YY @>

@ \<database option> $\longrightarrow$ \.{DATABASE\_YY}  @>
\initials{LDF 2013.08.15.}

\LOG
\initials{LDF 2013.08.15.}
Added this rule.
\ENDLOG

@<Rules@>=
@=database_option: DATABASE_YY @>
{

    Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`database_option: DATABASE_YY'"
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     @=$$@> = 1U;

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) database_option: DATABASE_ONLY_YY @>

@ \<database option> $\longrightarrow$ \.{DATABASE\_ONLY\_YY}  @>
\initials{LDF 2013.08.15.}

\LOG
\initials{LDF 2013.08.15.}
Added this rule.
\ENDLOG

@<Rules@>=
@=database_option: DATABASE_ONLY_YY @>
{

    Scan_Parse_Parameter_Type* param 
          = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
     if (param->PARSER_DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
              << "`database_option: DATABASE_ONLY_YY'"
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

     @=$$@> = 2U;

     param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) statement --> DELETE_YY METADATA_YY filename_list delete_metadata_option_list@>

@ \<statement> $\longrightarrow$ \.{DELETE\_YY} \.{METADATA\_YY} \<filename list> 
\<delete metadata options>.
\initials{LDF 2013.10.31.}

\LOG
\initials{LDF 2013.10.31.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DELETE_YY METADATA_YY filename_list delete_metadata_option_list@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `statement: DELETE_YY METADATA_YY filename_list "
             << "delete_metadata_option_list':" 
             << endl
             << "`delete_metadata_option_list' == " << @=$4@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   Response_Type response;

   response.type = Response_Type::PROCESS_PENDING_TYPE;
   param->response_deque.push_back(response);

   response.type = Response_Type::DELETE_METADATA_TYPE;

   response.string_vector = param->filename_vector;

   param->filename_vector.clear();

   response.metadata_options = @=$4@>;

   response.delay_value = param->delay_value;

   param->delay_value = 0UL;

   response.command = "DELETE METADATA";

#if DEBUG_COMPILE 
   if (param->PARSER_DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
            << "`statement: DELETE_YY METADATA_YY filename_list delete_metadata_option_list'."
            << endl;

       response.show("response:");

       unlock_cerr_mutex(); 

   }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

   param->response_deque.push_back(response);

   param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q **** (4) delete_metadata_option_list.  @>

@ \<delete metadata option list>.  
\initials{LDF 2013.10.31.}

\LOG
\initials{LDF 2013.10.31.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> delete_metadata_option_list@>
@=%type <uint_value> delete_metadata_option@>

@q ***** (5) delete_metadata_option_list:  /* Empty  */@>
@ \<delete metadata option list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2013.10.31.}

\LOG
\initials{LDF 2013.10.31.}
Added this rule.
\ENDLOG

@<Rules@>=
@=delete_metadata_option_list: /* Empty  */@>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `delete_metadata_option_list: /* Empty  */'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@>  = 0U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) delete_metadata_option_list:  delete_metadata_option_list delete_metadata_option @>
@ \<delete metadata option list> $\longrightarrow$ \<delete metadata option list> 
\<delete metadata option>.
\initials{LDF 2013.10.31.}

\LOG
\initials{LDF 2013.10.31.}
Added this rule.
\ENDLOG

@<Rules@>=
@=delete_metadata_option_list: delete_metadata_option_list delete_metadata_option @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `delete_metadata_option_list:  "
             << "delete_metadata_option_list delete_metadata_option'." 
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    if (@=$2@> == 4U && @=$1@> & 8U)
    {
        @=$1@> &= ~8U;
        param->delay_value = 0UL;
    }

    else if (@=$2@> == 8U && @=$1@> & 4U)
    {
        @=$1@> &= ~4U;
    }

    @=$$@> = @=$1@> | @=$2@>;

};

@q ***** (5) delete_metadata_option: FILE_YY. @>
@ \<delete metadata option> $\longrightarrow$ \.{FILE\_\_YY}.
\initials{LDF 2013.10.31.}

\LOG
\initials{LDF 2013.10.31.}
Added this rule.
\ENDLOG

@<Rules@>=
@=delete_metadata_option: FILE_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `delete_metadata_option:  FILE_YY'."
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    @=$$@> = 1U;

};

@q ***** (5) delete_metadata_option: FILE_ONLY_YY. @>
@ \<delete metadata option> $\longrightarrow$ \.{FILE\_ONLY\_YY}.
\initials{LDF 2013.10.31.}

\LOG
\initials{LDF 2013.10.31.}
Added this rule.
\ENDLOG

@<Rules@>=
@=delete_metadata_option: FILE_ONLY_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `delete_metadata_option:  FILE_ONLY_YY'."
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    @=$$@> = 2U;

};

@q ***** (5) delete_metadata_option: IMMEDIATE_YY. @>
@ \<delete metadata option> $\longrightarrow$ \.{IMMEDIATE\_YY}.
\initials{LDF 2013.11.21.}

\LOG
\initials{LDF 2013.11.21.}
Added this rule.
\ENDLOG

@<Rules@>=
@=delete_metadata_option: IMMEDIATE_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `delete_metadata_option:  IMMEDIATE_YY'."
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    @=$$@> = 4U;

    param->delay_value = 0UL;

};

@q ***** (5) delete_metadata_option: sub_delay_option. @>
@ \<delete metadata option> $\longrightarrow$ \<sub-delay option>.
\initials{LDF 2013.11.21.}

\LOG
\initials{LDF 2013.11.21.}
Added this rule.
\ENDLOG

@<Rules@>=
@=delete_metadata_option: sub_delay_option @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `delete_metadata_option:  sub_delay_option'."
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    @=$$@> = 8U;

};

@q ***** (5) delete_metadata_option: FORCE_YY. @>
@ \<delete metadata option> $\longrightarrow$ \.{FORCE\_YY}.
\initials{LDF 2013.11.21.}

\LOG
\initials{LDF 2013.11.21.}
Added this rule.
\ENDLOG

@<Rules@>=
@=delete_metadata_option: FORCE_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `delete_metadata_option:  FORCE_YY'."
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    @=$$@> = 16U;

};

@q ***** (5) delete_metadata_option: SAVE_DB_ENTRY_YY. @>
@ \<delete metadata option> $\longrightarrow$ \.{SAVE\_DB\_ENTRY\_YY}.
\initials{LDF 2013.11.27.}

\LOG
\initials{LDF 2013.11.27.}
Added this rule.
\ENDLOG

@<Rules@>=
@=delete_metadata_option: SAVE_DB_ENTRY_YY @>
{

    Scan_Parse_Parameter_Type* param 
        = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */


#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {

        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `delete_metadata_option:  SAVE_DB_ENTRY_YY'."
             << endl;
        unlock_cerr_mutex(); 
    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    @=$$@> = 32U;

};


@q **** (4) statement --> UNDELETE_YY METADATA_YY filename_list @>

@ \<statement> $\longrightarrow$ \.{UNDELETE\_YY} \.{METADATA\_YY} 
\<filename list> \<delete metadata options>.
\initials{LDF 2013.11.21.}

\LOG
\initials{LDF 2013.11.21.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: UNDELETE_YY METADATA_YY filename_list@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "In `yyparse', rule `statement: UNDELETE_YY METADATA_YY filename_list:"
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

   Response_Type response;

   response.type = Response_Type::PROCESS_PENDING_TYPE;
   param->response_deque.push_back(response);

   response.type = Response_Type::UNDELETE_METADATA_TYPE;

   response.string_vector = param->filename_vector;

   param->filename_vector.clear();

   response.command = "UNDELETE METADATA";

#if DEBUG_COMPILE 
   if (param->PARSER_DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
            << "`statement: UNDELETE_YY METADATA_YY filename_list'."
            << endl;

       response.show("response:");

       unlock_cerr_mutex(); 

   }  /* |if (param->PARSER_DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */ 

   param->response_deque.push_back(response);

   param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q **** (4) statement --> SHOW_YY METADATA_YY show_metadata_option_list. @>

@ \<statement> $\longrightarrow$ \.{SHOW\_YY} \.{METADATA\_YY} \<show metadata option list>.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=statement: SHOW_YY METADATA_YY show_metadata_option_list @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`statement: SHOW_YY METADATA_YY show_metadata_option_list'."
             << endl
             << "`show_metadata_option_list' ($3) == " << @=$3@> << " == " 
             << oct << @=$3@> << " (octal)" << dec
             << endl;

        if (@=$3@> == 0U)
            cerr << "No options." << endl;

        if (@=$3@> & 1U)
            cerr << "`user' option   (1)." << endl;
        if (@=$3@> & 2U)
            cerr << "`group' option  (2)." << endl;
        if (@=$3@> & 4U)
            cerr << "`all' option    (4)." << endl;
        if (@=$3@> & 8U)
            cerr << "`full' option   (8)." << endl;
        if (@=$3@> & 32U)
            cerr << "`store' option (32)." << endl;
       
        cerr << "`param->int_vector.size()' == " << param->int_vector.size()
             << endl;

        if (param->int_vector.size() > 0)
        {
             cerr << "`param->int_vector':"
                  << endl;

             for (vector<int>::iterator iter = param->int_vector.begin();
                  iter != param->int_vector.end();
                  ++iter)
             {
                 cerr << *iter << " ";
             }

             cerr << endl;

        }
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;
    response.type = Response_Type::FETCH_DC_METADATA_TYPE;

    response.int_vector = param->int_vector;
    param->int_vector.clear();

    response.options = @=$3@>;

    response.options |= 16U;  /* Show  */

    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};

@q **** (4) show_metadata_option_list and show_metadata_option.  @>
@ \<show metadata option list> and \<show metadata option>
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added these type declarations.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> show_metadata_option_list@>
@=%type <uint_value> show_metadata_option@>

@q ***** (5) show_metadata_option_list: /* Empty */ @>

@ \<show metadata option list> $\longrightarrow$ \.{Empty}.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=show_metadata_option_list: /* Empty */@>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`show_metadata_option_list: /* Empty */'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 
 
    @=$$@> = 0U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) show_metadata_option_list: show_metadata_option_list show_metadata_option @>

@ \<show metadata option list> $\longrightarrow$ \<show metadata option list> 
\<show metadata option>.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@= show_metadata_option_list: show_metadata_option_list show_metadata_option@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`show_metadata_option_list: show_metadata_option_list show_metadata_option'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) show_metadata_option: USER_YY @>

@ \<show metadata option> $\longrightarrow$ \<integer list>.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=show_metadata_option: USER_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`show_metadata_option: USER_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    /* !! TODO:  LDF 2013.12.06.  Implement this.  
       Document command in manual.
    */


    @=$$@> = 1U;

};

@q ***** (5) show_metadata_option: GROUP_YY @>

@ \<show metadata option> $\longrightarrow$ \<integer list>.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=show_metadata_option: GROUP_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`show_metadata_option: GROUP_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    @=$$@> = 2U;

};

@q ***** (5) show_metadata_option: ALL_YY @>

@ \<show metadata option> $\longrightarrow$ \<integer list>.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=show_metadata_option: ALL_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`show_metadata_option: ALL_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    @=$$@> = 4U;

};

@q ***** (5) show_metadata_option: FULL_YY @>

@ \<show metadata option> $\longrightarrow$ \<integer list>.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=show_metadata_option: FULL_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`show_metadata_option: FULL_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    @=$$@> = 8U;

};

@q ***** (5) show_metadata_option: STORE_YY @>

@ \<show metadata option> $\longrightarrow$ \<integer list>.
\initials{LDF 2013.12.18.}

\LOG
\initials{LDF 2013.12.18.}
Added this rule.
\ENDLOG

@<Rules@>=
@=show_metadata_option: STORE_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`show_metadata_option: STORE_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

    @=$$@> = 32U;

};



@q ***** (5) show_metadata_option: integer_list @>

@ \<show metadata option> $\longrightarrow$ \<integer list>.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=show_metadata_option: integer_list@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`show_metadata_option: integer_list'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 0U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) integer_list.  @>
@ \<integer list>.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <int_value> integer_list@>

@q ***** (5) integer_list: INTEGER_YY @>

@ \<integer list> $\longrightarrow$ \.{INTEGER\_YY}.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@=integer_list: INTEGER_YY@>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`integer_list: INTEGER_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->int_vector.clear();

    param->int_vector.push_back(@=$1@>);

    @=$$@> = 0U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) integer_list: integer_list INTEGER_YY @>

@ \<integer list> $\longrightarrow$ \<integer list> \.{INTEGER\_YY}.
\initials{LDF 2013.12.06.}

\LOG
\initials{LDF 2013.12.06.}
Added this rule.
\ENDLOG

@<Rules@>=
@= integer_list: integer_list INTEGER_YY@>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] In `yyparse', rule "
             << "`integer_list: integer_list INTEGER_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    param->int_vector.push_back(@=$2@>);

    @=$$@> = 0U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) statement --> CLIENT_YY SENDING_YY PUBLIC_KEY_YY STRING_YY STRING_YY @>
@q **** (4)               STRING_YY UNSIGNED_INTEGER_YY                          @>

@ \<statement> $\longrightarrow$ \.{CLIENT\_YY} \.{SENDING\_YY} \.{FILE\_YY} 
\.{STRING\_YY} \.{STRING\_YY} \.{STRING\_YY} \.{UNSIGNED\_INTEGER\_YY}. 
\initials{LDF 2014.01.22.}

\LOG
\initials{LDF 2014.01.22.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: CLIENT_YY SENDING_YY PUBLIC_KEY_YY STRING_YY STRING_YY STRING_YY @>
@=UNSIGNED_INTEGER_YY @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true|  */

    temp_strm << "[Thread " << param->thread_ctr << "] ";
 
    string thread_str = temp_strm.str();
 
    temp_strm.str("");

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << thread_str
             << "In `yyparse', rule `statement: CLIENT_YY SENDING_YY PUBLIC_KEY_YY "
             << "STRING_YY STRING_YY STRING_YY UNSIGNED_INTEGER_YY':"
             << endl
             << "`STRING_YY'                   (4) (UID)         == " << @=$4@>
             << endl 
             << "`STRING_YY'                   (5) (Fingerprint) == " << @=$5@>
             << endl 
             << "`STRING_YY'                   (6) (Public key)  == " << @=$6@>
             << endl 
             << "`UNSIGNED_INTEGER_YY'         (7) (Options)     == " << @=$7@>
             << " == " << oct << @=$7@> << " (octal)" << dec
             << endl;
        unlock_cerr_mutex(); 

    }  /* |else if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<Rules@>=

   status = param->store_public_key(@=$4@>, @=$5@>, @=$6@>, @=$7@>, thread_str);

   if (status == 2)
   {
        lock_cerr_mutex(); 
        cerr << thread_str
             << "WARNING!  In `yyparse', rule `statement: CLIENT_YY SENDING_YY PUBLIC_KEY_YY "
             << "STRING_YY STRING_YY UNSIGNED_INTEGER_YY':"
             << endl
             << "`Scan_Parse_Parameter_Type::store_public_key' returned 2:"
             << endl 
             << "Public key already present in `gwirdsif.GPG_Key_Pairs' database table."
             << endl
             << "Fingerprint == " << @=$5@>
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex(); 

        ++param->warnings_occurred; 

   }  /* |if (status == 2)|  */

@q ***** (5) @>
@
@<Rules@>=

   else if (status != 0)
   {
        lock_cerr_mutex(); 
        cerr << thread_str
             << "ERROR!  In `yyparse', rule `statement: CLIENT_YY SENDING_YY PUBLIC_KEY_YY "
             << "STRING_YY STRING_YY UNSIGNED_INTEGER_YY':"
             << endl
             << "`Scan_Parse_Parameter_Type::store_public_key' failed, returning "
             << status << "."
             << endl 
             << "Failed to store public key."
             << endl;
        unlock_cerr_mutex(); 

        ++param->errors_occurred; 

   }  /* |else if (status != 0)|  */


@q ***** (5) @>
@
@<Rules@>=

   else
   {
@q ****** (6) @>

#if DEBUG_COMPILE 
        if (param->PARSER_DEBUG)
        {
             lock_cerr_mutex(); 
             cerr << thread_str
                  << "In `yyparse', rule `statement: CLIENT_YY SENDING_YY PUBLIC_KEY_YY "
                  << "STRING_YY STRING_YY UNSIGNED_INTEGER_YY':"
                  << endl
                  << "`Scan_Parse_Parameter_Type::store_public_key' succeeded, returning 0."
                  << endl 
                  << "Stored public key successfully."
                  << endl;
             unlock_cerr_mutex(); 

        }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

   }  /* |else|  */

@q ***** (5) @>

   param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> REGISTER_YY PULL_YY register_pull_options @>

@ \<statement> $\longrightarrow$ \.{REGISTER\_YY} \.{PULL\_YY} 
\<register pull options>.
\initials{LDF 2014.01.31.}

\LOG
\initials{LDF 2014.01.31.}
Added this rule.

\initials{LDF 2014.02.01.}
Replaced \<string list optional> with \<register pull options>.
\ENDLOG

@<Rules@>=

@=statement: REGISTER_YY PULL_YY register_pull_options string_list_optional @>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: REGISTER_YY PULL_YY register_pull_options string_list_optional'."
             << endl
             << "`param->string_vector.size()' == " << param->string_vector.size()
             << endl;

         if (param->string_vector.size() > 0)
         {
             cerr << "`param->string_vector':"
                  << endl;

             for (vector<string>::iterator iter = param->string_vector.begin();
                  iter != param->string_vector.end();
                  ++iter) 
             {
                 cerr << *iter << endl;
             }

             cerr << endl;

         }

        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<Rules@>=

    Pull_Request_Type *pull_request = static_cast<Pull_Request_Type*>(@=$3@>); 

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        pull_request->show("*pull_request:");

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;

    if (param->string_vector.size() == 0)
    {
          
        response.type = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm.str("");

        temp_strm << "REGISTER PULL RESPONSE " << GW_ERROR 
                  << " \"No files or directories specified.\"";

        response.command = temp_strm.str();
        temp_strm.str("");

        delete pull_request;
        pull_request = 0;

        ++param->errors_occurred;  

    }

    else if (pull_request->user_id <= 0)
    {
          
        response.type = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm.str("");

        temp_strm << "REGISTER PULL RESPONSE " << GW_ERROR 
                  << " \"Failed to set user_id for pull request.\"";

        response.command = temp_strm.str();
        temp_strm.str("");

        delete pull_request;
        pull_request = 0;

        ++param->errors_occurred;  

    }
    else 
    {

        response.type = Response_Type::REGISTER_PULL_TYPE;
        response.string_vector = param->string_vector;

        response.pointer_val = static_cast<void*>(pull_request); 

        pull_request = 0;

        param->string_vector.clear();

    }

    param->response_deque.push_back(response);

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) register_pull_options.  @>
@ \<register pull options>.
\initials{LDF 2014.02.01.}

\LOG
\initials{LDF 2014.02.01.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <pointer_value> register_pull_options@>

@q ***** (5) register_pull_options: /* Empty  */@>

@ \<register pull options> $\longrightarrow$ \.{Empty}.
\initials{LDF 2014.02.01.}

\LOG
\initials{LDF 2014.02.01.}
Added this rule.
\ENDLOG

@<Rules@>=

@=register_pull_options: /* Empty  */ @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`register_pull_options: /* Empty  */'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Pull_Request_Type *pull_request = new Pull_Request_Type;

    pull_request->pull_interval = -1;  /* Flag to use default value.
                                          Can be changed by using the \.{interval}
                                          option.
                                          \initials{LDF 2014.02.07.}  */

    @=$$@> = static_cast<void*>(pull_request); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) register_pull_options: register_pull_options HOSTNAME_YY STRING_YY@>

@ \<register pull options> $\longrightarrow$ \<register pull options> 
\.{HOSTNAME\_YY} \.{STRING\_YY}.
\initials{LDF 2014.02.01.}

\LOG
\initials{LDF 2014.02.01.}
Added this rule.
\ENDLOG

@<Rules@>=

@=register_pull_options: register_pull_options HOSTNAME_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`register_pull_options: register_pull_options HOSTNAME_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Pull_Request_Type *pull_request = static_cast<Pull_Request_Type*>(@=$1@>); 

    pull_request->client_hostname = @=$3@>;

    @=$$@> = static_cast<void*>(pull_request); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) register_pull_options: register_pull_options IP_ADDRESS_YY STRING_YY@>

@ \<register pull options> $\longrightarrow$ \<register pull options> 
\.{IP\_ADDRESS\_YY} \.{STRING\_YY}.
\initials{LDF 2014.02.01.}

\LOG
\initials{LDF 2014.02.01.}
Added this rule.
\ENDLOG

@<Rules@>=

@=register_pull_options: register_pull_options IP_ADDRESS_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`register_pull_options: register_pull_options IP_ADDRESS_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Pull_Request_Type *pull_request = static_cast<Pull_Request_Type*>(@=$1@>); 

    pull_request->client_ip_address = @=$3@>;

    @=$$@> = static_cast<void*>(pull_request); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) register_pull_options: register_pull_options PORT_YY INTEGER_YY@>

@ \<register pull options> $\longrightarrow$ \<register pull options> 
\.{PORT\_YY} \.{INTEGER\_YY}.
\initials{LDF 2014.02.14.}

\LOG
\initials{LDF 2014.02.14.}
Added this rule.
\ENDLOG

@<Rules@>=

@=register_pull_options: register_pull_options PORT_YY INTEGER_YY @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`register_pull_options: register_pull_options PORT_YY INTEGER_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Pull_Request_Type *pull_request = static_cast<Pull_Request_Type*>(@=$1@>); 

    pull_request->client_port = @=$3@>;

    @=$$@> = static_cast<void*>(pull_request); 

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};




@q ***** (5) register_pull_options: register_pull_options DISTINGUISHED_NAME_YY STRING_YY@>

@ \<register pull options> $\longrightarrow$ \<register pull options> 
\.{DISTINGUISHED\_NAME\_YY} \.{STRING\_YY}.
\initials{LDF 2014.02.01.}

\LOG
\initials{LDF 2014.02.01.}
Added this rule.
\ENDLOG

@<Rules@>=

@=register_pull_options: register_pull_options DISTINGUISHED_NAME_YY STRING_YY @>
{
@q ****** (6) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`register_pull_options: register_pull_options DISTINGUISHED_NAME_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<Rules@>=

    Pull_Request_Type *pull_request = static_cast<Pull_Request_Type*>(@=$1@>);    

    if (param->distinguished_name.output() == @=$3@> 
        && pull_request->user_id == param->user_id)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "NOTICE!  In `yyparse', rule "
             << "`register_pull_options: register_pull_options DISTINGUISHED_NAME_YY STRING_YY':"
             << endl
             << "STRING_YY (2) (Distinguished Name) == `param->distinguished_name.output()' == "
             << @=$3@>
             << endl
             << "and `param->user_id' == `pull_request->user_id' == " 
             << pull_request->user_id << "."
             << endl 
             << "`pull_request->user_id' already correctly set.  Not doing anything."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if|  */

@q ****** (6) @>
@
@<Rules@>=

    else if (param->distinguished_name.output() == @=$3@> 
             && pull_request->user_id == 0)
    {
#if DEBUG_COMPILE
       if (param->PARSER_DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << param->thread_ctr << "] "
                << "In `yyparse', rule "
                << "`register_pull_options: "
                << "register_pull_options DISTINGUISHED_NAME_YY STRING_YY':"
                << endl
                << "STRING_YY (2) (Distinguished Name) == "
                << "`param->distinguished_name.output()' == "
                << @=$3@>
                << endl
                << "and `pull_request->user_id' == 0."
                << endl 
                << "Setting `pull_request->user_id' to `param->user_id' == " << param->user_id
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       pull_request->user_id = param->user_id;

    }  /* |else if|  */

@q ****** (6) @>
@
@<Rules@>=

    else if (param->distinguished_name.output() == @=$3@> 
             && pull_request->user_id != param->user_id)
    {
           lock_cerr_mutex(); 
           cerr << "[Thread " << param->thread_ctr << "] "
                << "ERROR!  In `yyparse', rule "
                << "`register_pull_options: register_pull_options "
                << "DISTINGUISHED_NAME_YY STRING_YY':"
                << endl
                << "STRING_YY (2) (Distinguished Name) == "
                << "`param->distinguished_name.output()' == "
                << @=$3@> << ","
                << endl
                << "but `pull_request->user_id' is non-zero and not equal to `param->user_id':"
                << endl 
                << "`pull_request->user_id' == " << pull_request->user_id
                << endl  
                << "`param->user_id'   == " << param->user_id
                << endl
                << "Setting `pull_request->user_id' to -1 and will handle error later."
                << endl;
           unlock_cerr_mutex(); 

           pull_request->user_id = -1;
        
    }  /* |else if|  */

@q ****** (6) @>
@
@<Rules@>=

    else if (param->distinguished_name.output() != @=$3@>)
    {
@q ******* (7) @>

#if DEBUG_COMPILE
       if (param->PARSER_DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << param->thread_ctr << "] "
                << "In `yyparse', rule "
                << "`register_pull_options: register_pull_options "
                << "DISTINGUISHED_NAME_YY STRING_YY':"
                << endl
                << "STRING_YY (2) (Distinguished Name) != `param->distinguished_name.output()':"
                << endl
                << "STRING_YY (2) (Distinguished Name)   == " << @=$3@>
                << endl
                << "`param->distinguished_name.output()' == " 
                << param->distinguished_name.output()
                << endl 
                << "Calling `User_Info_Type::get_user_info_from_database'."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

       User_Info_Type user_info;

       status = user_info.get_user_info_from_database(param->mysql_ptr, string(@=$3@>));

       if (status != 0)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << param->thread_ctr << "] "
                << "ERROR!  In `yyparse', rule "
                << "`register_pull_options: register_pull_options "
                << "DISTINGUISHED_NAME_YY STRING_YY':"
                << endl
                << "`User_Info_Type::get_user_info_from_database' failed, returning "
                << status << "."
                << endl
                << "Failed to retrieve user info for Distinguished Name "
                << "\"" << @=$3@> << "\"."
                << endl 
                << "Setting `pull_request->user_id' to -1 and will handle error later."
                << endl;
           unlock_cerr_mutex(); 

           pull_request->user_id = -1;
       }

@q ******* (7) @>
@
@<Rules@>=

       else if (   pull_request->user_id != 0 
                && pull_request->user_id != user_info.user_id)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << param->thread_ctr << "] "
                << "ERROR!  In `yyparse', rule "
                << "`register_pull_options: register_pull_options USERNAME_YY STRING_YY':"
                << endl
                << "`pull_request->user_id' != 0 and `user_info.user_id' "
                << "!= `pull_request->user_id':"
                << endl
                << "`pull_request->user_id' == " << pull_request->user_id
                << endl 
                << "`user_info.user_id'     == " << user_info.user_id
                << endl 
                << "This is not permitted."
                << endl 
                << "Setting `pull_request->user_id' to -1 and will handle error later."
                << endl;
           unlock_cerr_mutex(); 

           pull_request->user_id = -1;

       }  /* |else if|  */

@q ******* (7) @>
@
@<Rules@>=

       else
       {
           pull_request->user_id = user_info.user_id;
           pull_request->username = user_info.username;

#if DEBUG_COMPILE
           if (param->PARSER_DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << param->thread_ctr << "] "
                    << "In `yyparse', rule "
                    << "`register_pull_options: register_pull_options "
                    << "DISTINGUISHED_NAME_YY STRING_YY':"
                    << endl
                    << "`User_Info_Type::get_user_info_from_database' succeeded, returning 0."
                    << endl
                    << "`pull_request->user_id' == " << pull_request->user_id
                    << endl;

               user_info.show("user_info:");

               unlock_cerr_mutex(); 

           }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       }  /* |else|  */

 @q ******* (7) @>

    }  /* |else if|  */

@q ****** (6) @>
@
@<Rules@>=

    @=$$@> = @=$1@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) register_pull_options: register_pull_options USERNAME_YY STRING_YY@>

@ \<register pull options> $\longrightarrow$ \<register pull options> 
\.{USERNAME\_YY} \.{STRING\_YY}.
\initials{LDF 2014.02.03.}

\LOG
\initials{LDF 2014.02.03.}
Added this rule.
\ENDLOG

@<Rules@>=

@=register_pull_options: register_pull_options USERNAME_YY STRING_YY @>
{
@q ****** (6) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`register_pull_options: register_pull_options USERNAME_YY STRING_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<Rules@>=

    Pull_Request_Type *pull_request = static_cast<Pull_Request_Type*>(@=$1@>);    

    if (param->username == @=$3@> 
        && pull_request->user_id == param->user_id)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "NOTICE!  In `yyparse', rule "
             << "`register_pull_options: register_pull_options USERNAME_YY STRING_YY':"
             << endl
             << "STRING_YY (2) (Username) == `param->username' == "
             << @=$3@>
             << endl
             << "and `param->user_id' == `pull_request->user_id' == " 
             << pull_request->user_id << "."
             << endl 
             << "`pull_request->user_id' already correctly set.  Not doing anything."
             << endl
             << "Continuing."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if|  */

@q ****** (6) @>
@
@<Rules@>=

    else if (param->username == @=$3@> 
             && pull_request->user_id == 0)
    {
#if DEBUG_COMPILE
       if (param->PARSER_DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << param->thread_ctr << "] "
                << "In `yyparse', rule "
                << "`register_pull_options: register_pull_options USERNAME_YY STRING_YY':"
                << endl
                << "STRING_YY (2) (Username) == "
                << "`param->username' == "
                << @=$3@>
                << endl
                << "and `pull_request->user_id' == 0."
                << endl 
                << "Setting `pull_request->user_id' to `param->user_id' == " 
                << param->user_id
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       pull_request->user_id = param->user_id;

    }  /* |else if|  */

@q ****** (6) @>
@
@<Rules@>=

    else if (param->username == @=$3@> 
             && pull_request->user_id != param->user_id)
    {
           lock_cerr_mutex(); 
           cerr << "[Thread " << param->thread_ctr << "] "
                << "ERROR!  In `yyparse', rule "
                << "`register_pull_options: register_pull_options USERNAME_YY STRING_YY':"
                << endl
                << "STRING_YY (2) (Username) == "
                << "`param->username' == "
                << @=$3@> << ","
                << endl
                << "but `pull_request->user_id' is non-zero and not equal to `param->user_id':"
                << endl 
                << "`pull_request->user_id' == " << pull_request->user_id
                << endl  
                << "`param->user_id'   == " << param->user_id
                << endl
                << "Setting `pull_request->user_id' to -1 and will handle error later."
                << endl;
           unlock_cerr_mutex(); 

           pull_request->user_id = -1;
        
    }  /* |else if|  */

@q ****** (6) @>
@
@<Rules@>=

    else if (param->username != @=$3@>)
    {
@q ******* (7) @>

#if DEBUG_COMPILE
       if (param->PARSER_DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << param->thread_ctr << "] "
                << "In `yyparse', rule "
                << "`register_pull_options: register_pull_options USERNAME_YY STRING_YY':"
                << endl
                << "STRING_YY (2) (Username) != `param->username':"
                << endl
                << "STRING_YY (2) (Username)   == " << @=$3@>
                << endl
                << "`param->username' == " 
                << param->username
                << endl 
                << "Calling `User_Info_Type::get_user_info_from_database'."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

       User_Info_Type user_info;

       status = user_info.get_user_info_from_database(param->mysql_ptr, "", string(@=$3@>));

       if (status != 0)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << param->thread_ctr << "] "
                << "ERROR!  In `yyparse', rule "
                << "`register_pull_options: register_pull_options USERNAME_YY STRING_YY':"
                << endl
                << "`User_Info_Type::get_user_info_from_database' failed, returning "
                << status << "."
                << endl
                << "Failed to retrieve user info for username "
                << "\"" << @=$3@> << "\"."
                << endl 
                << "Setting `pull_request->user_id' to -1 and will handle error later."
                << endl;
           unlock_cerr_mutex(); 

           pull_request->user_id = -1;


       }

@q ******* (7) @>
@
@<Rules@>=

       else if (   pull_request->user_id != 0 
                && pull_request->user_id != user_info.user_id)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << param->thread_ctr << "] "
                << "ERROR!  In `yyparse', rule "
                << "`register_pull_options: register_pull_options USERNAME_YY STRING_YY':"
                << endl
                << "`pull_request->user_id' != 0 and `user_info.user_id' "
                << "!= `pull_request->user_id':"
                << endl
                << "`pull_request->user_id' == " << pull_request->user_id
                << endl 
                << "`user_info.user_id'     == " << user_info.user_id
                << endl 
                << "This is not permitted."
                << endl 
                << "Setting `pull_request->user_id' to -1 and will handle error later."
                << endl;
           unlock_cerr_mutex(); 

           pull_request->user_id = -1;

       }  /* |else if|  */


@q ******* (7) @>
@
@<Rules@>=

       else
       {
           pull_request->user_id  = user_info.user_id;
           pull_request->username = user_info.username;

#if DEBUG_COMPILE
           if (param->PARSER_DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << param->thread_ctr << "] "
                    << "In `yyparse', rule "
                    << "`register_pull_options: register_pull_options USERNAME_YY STRING_YY':"
                    << endl
                    << "`User_Info_Type::get_user_info_from_database' succeeded, returning 0."
                    << endl
                    << "`pull_request->user_id' == " << pull_request->user_id
                    << endl;

               user_info.show("user_info:");

               unlock_cerr_mutex(); 

           }  /* |if (param->PARSER_DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       }  /* |else|  */

 @q ******* (7) @>

    }  /* |else if|  */

@q ****** (6) @>
@
@<Rules@>=

    @=$$@> = @=$1@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) register_pull_options: register_pull_options FORCE_YY @>

@ \<register pull options> $\longrightarrow$ \<register pull options> 
\.{FORCE\_YY}.
\initials{LDF 2014.02.07.}

\LOG
\initials{LDF 2014.02.07.}
Added this rule.
\ENDLOG

@<Rules@>=

@=register_pull_options: register_pull_options FORCE_YY @>
{
@q ****** (6) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`register_pull_options: register_pull_options FORCE_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<Rules@>=

    Pull_Request_Type *pull_request = static_cast<Pull_Request_Type*>(@=$1@>);    

    pull_request->force_flag = true;

    @=$$@> = @=$1@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) register_pull_options: register_pull_options INTERVAL_YY TIME_SPECIFICATION_YY@>

@ \<register pull options> $\longrightarrow$ \<register pull options> 
\.{INTERVAL\_YY} \.{TIME\_SPECIFICATION\_YY}.
\initials{LDF 2014.02.12.}

\LOG
\initials{LDF 2014.02.12.}
Added this rule.
\ENDLOG

@<Rules@>=

@=register_pull_options: register_pull_options INTERVAL_YY TIME_SPECIFICATION_YY @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`register_pull_options: register_pull_options INTERVAL_YY TIME_SPECIFICATION_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    if (@=$3@> > INT_MAX)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "WARNING!  In `yyparse', rule"
             << endl 
             << "`register_pull_options: register_pull_options INTERVAL_YY TIME_SPECIFICATION_YY':"
             << endl
             << "`TIME_SPECIFICATION_YY' == " << @=$3@> << " (> INT_MAX)."
             << endl
             << "Value out of range.  Not setting pull request interval."
             << endl 
             << "Will use default value."
             << endl;
        unlock_cerr_mutex(); 

        @=$$@> = @=$1@>;

    }
    else 
    {
        Pull_Request_Type *pull_request = static_cast<Pull_Request_Type*>(@=$1@>); 
        pull_request->pull_interval = @=$3@>;
        @=$$@> = static_cast<void*>(pull_request); 
    }


    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) @>

@q **** (4) statement --> DUMMY_STATEMENT_YY INTEGER_YY @>

@ \<statement> $\longrightarrow$ \.{DUMMY\_STATEMENT\_YY} \.{INTEGER\_YY}.
\initials{LDF 2013.04.05.}

\LOG
\initials{LDF 2013.04.05.}
Added this rule.  It's used for testing.
\ENDLOG

@<Rules@>=

@=statement: DUMMY_STATEMENT_YY INTEGER_YY @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DUMMY_STATEMENT_YY INTEGER_YY'."
             << endl
             << "`INTEGER_YY' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex(); 
    lock_cerr_mutex(); 
    cout << "Dummy statement -->" 
         << endl
         << "Code number:  " << @=$2@>
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex(); 

    temp_strm.str("");

    temp_strm << "DUMMY_STATEMENT RESPONSE 0";

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

    response.command = temp_strm.str();

    param->response_deque.push_back(response);

    temp_strm.str("");

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> DUMMY_STATEMENT_YY TIME_SPECIFICATION_YY @>

@ \<statement> $\longrightarrow$ \.{DUMMY\_STATEMENT\_YY} \.{TIME\_SPECIFICATION\_YY}.
\initials{LDF 2013.08.19.}

\LOG
\initials{LDF 2013.08.19.}
Added this rule.  It's used for testing.
\ENDLOG

@<Rules@>=

@=statement: DUMMY_STATEMENT_YY TIME_SPECIFICATION_YY @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DUMMY_STATEMENT_YY TIME_SPECIFICATION_YY'."
             << endl
             << "`TIME_SPECIFICATION_YY' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex(); 
    lock_cerr_mutex(); 
    cout << "Dummy statement -->" 
         << endl
         << "Time specification:  " << @=$2@>
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex(); 

    temp_strm.str("");

    int days    = 0;
    int hours   = 0;
    int minutes = 0;
    int seconds = 0;

    seconds = @=$2@>;

    days = seconds / 86400;

    seconds %= 86400;

    hours = seconds / 3600;

    seconds %= 3600;    

    minutes = seconds / 60;

    seconds %= 60;


    temp_strm << "DUMMY_STATEMENT RESPONSE \""
              << "days ==    " << days 
              << endl
              << "hours ==   " << hours
              << endl 
              << "minutes == " << minutes
              << endl
              << "seconds == " << seconds
              << "\"";

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DUMMY_STATEMENT_YY TIME_SPECIFICATION_YY':"
             << endl
             << "`days' == " << days
             << endl 
             << "`hours' == " << hours
             << endl 
             << "`minutes' == " << minutes
             << endl 
             << "`seconds' == " << seconds
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 



    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

    response.command = temp_strm.str();

    param->response_deque.push_back(response);

    temp_strm.str("");

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> CHECKSUM_YY STRING_YY checksum_option_list @>

@ \<statement> $\longrightarrow$ \.{CHECKSUM\_YY} \.{STRING\_YY}
\<checksum option list>.
\initials{LDF 2013.12.24.}

\LOG
\initials{LDF 2013.12.24.}
Added this rule.  
\ENDLOG

@<Rules@>=

@=statement: CHECKSUM_YY STRING_YY checksum_option_list @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: CHECKSUM_YY STRING_YY STRING_YY checksum_option_list'."
             << endl
             << "`STRING_YY'            (2) (Filename) == " << @=$2@>
             << endl 
             << "`checksum_option_list' (3) (Options)  == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex(); 
    lock_cerr_mutex(); 
    cout << "Checksum -->" 
         << endl
         << "Filename: " << @=$2@>
         << endl 
         << "Options:  " << @=$3@>
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex(); 

    Response_Type response;
    response.type           = Response_Type::GENERATE_CHECKSUM_TYPE;
    response.local_filename = @=$2@>;
    response.options        = @=$3@>;

    response.command = temp_strm.str();

    param->response_deque.push_back(response);

    temp_strm.str("");

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) statement --> VERIFY_YY CHECKSUM_YY STRING_YY STRING_YY checksum_option_list @>

@ \<statement> $\longrightarrow$ \.{VERIFY\_YY} \.{CHECKSUM\_YY} \.{STRING\_YY} 
\.{STRING\_YY} \<checksum option list>.
\initials{LDF 2014.01.03.}

\LOG
\initials{LDF 2014.01.03.}
Added this rule.  
\ENDLOG

@<Rules@>=

@=statement: VERIFY_YY CHECKSUM_YY STRING_YY STRING_YY checksum_option_list @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: VERIFY_YY CHECKSUM_YY STRING_YY checksum_option_list'."
             << endl
             << "`STRING_YY'            (2) (Filename) == " << @=$3@>
             << endl 
             << "`STRING_YY'            (2) (Checksum) == " << @=$4@>
             << endl 
             << "`checksum_option_list' (3) (Options)  == " << @=$5@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex(); 
    lock_cerr_mutex(); 
    cout << "Checksum -->" 
         << endl
         << "Filename:  " << @=$3@>
         << endl 
         << "Checksum:  " << @=$4@>
         << endl 
         << "Options:   " << @=$5@>
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex(); 

    Response_Type response;
    response.type           = Response_Type::VERIFY_CHECKSUM_TYPE;
    response.local_filename = @=$3@>;
    response.string_val     = @=$4@>;
    response.options        = @=$5@>;

    response.command = temp_strm.str();

    param->response_deque.push_back(response);

    temp_strm.str("");

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) checksum_option_list.  @>
@ \<checksum type optional>.
\initials{LDF 2013.12.24.}

\LOG
\initials{LDF 2013.12.24.}
Added this type declaration.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> checksum_option_list @>
@=%type <uint_value> checksum_option @>

@q ***** (5) checksum_option_list: /* Empty */  @>
@ \<checksum type optional> $\longrightarrow$ \.{Empty}.
\initials{LDF 2013.12.24.}

\LOG
\initials{LDF 2013.12.24.}
Added this rule
\ENDLOG

@<Rules@>=

@=checksum_option_list: /* Empty  */ @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`checksum_option_list: /* Empty  */'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 0U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) checksum_option_list: checksum_option_list checksum_option  @>
@ \<checksum type optional> $\longrightarrow$ \<checksum type optional>  
\<checksum option>.
\initials{LDF 2013.12.24.}

\LOG
\initials{LDF 2013.12.24.}
Added this rule
\ENDLOG

@<Rules@>=

@=checksum_option_list: checksum_option_list checksum_option @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`checksum_option_list: checksum_option_list checksum_option'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = @=$1@> | @=$2@>;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q ***** (5) checksum_option: MD5_YY  @>
@ \<checksum type optional> $\longrightarrow$ \.{MD5\_YY}.
\initials{LDF 2013.12.24.}

\LOG
\initials{LDF 2013.12.24.}
Added this rule
\ENDLOG

@<Rules@>=

@=checksum_option: MD5_YY @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`checksum_option: MD5_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 1U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) checksum_option: SHA1_YY  @>
@ \<checksum type optional> $\longrightarrow$ \.{SHA1\_YY}.
\initials{LDF 2013.12.24.}

\LOG
\initials{LDF 2013.12.24.}
Added this rule
\ENDLOG

@<Rules@>=

@=checksum_option: SHA1_YY @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`checksum_option: SHA1_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 2U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) checksum_option: SHA224_YY  @>
@ \<checksum type optional> $\longrightarrow$ \.{SHA224\_YY}.
\initials{LDF 2013.12.24.}

\LOG
\initials{LDF 2013.12.24.}
Added this rule
\ENDLOG

@<Rules@>=

@=checksum_option: SHA224_YY @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`checksum_option: SHA224_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 4U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) checksum_option: SHA256_YY  @>
@ \<checksum type optional> $\longrightarrow$ \.{SHA256\_YY}.
\initials{LDF 2013.12.24.}

\LOG
\initials{LDF 2013.12.24.}
Added this rule
\ENDLOG

@<Rules@>=

@=checksum_option: SHA256_YY @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`checksum_option: SHA256_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 8U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) checksum_option: SHA384_YY  @>
@ \<checksum type optional> $\longrightarrow$ \.{SHA384\_YY}.
\initials{LDF 2013.12.24.}

\LOG
\initials{LDF 2013.12.24.}
Added this rule
\ENDLOG

@<Rules@>=

@=checksum_option: SHA384_YY @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`checksum_option: SHA384_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 16U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) checksum_option: SHA512_YY  @>
@ \<checksum type optional> $\longrightarrow$ \.{SHA512\_YY}.
\initials{LDF 2013.12.24.}

\LOG
\initials{LDF 2013.12.24.}
Added this rule
\ENDLOG

@<Rules@>=

@=checksum_option: SHA512_YY @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`checksum_option: SHA512_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 32U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) checksum_option: NO_HANDLE_YY  @>
@ \<checksum type optional> $\longrightarrow$ \.{NO\_HANDLE\_YY}.
\initials{LDF 2013.12.25.}

\LOG
\initials{LDF 2013.12.25.}
Added this rule
\ENDLOG

@<Rules@>=

@=checksum_option: NO_HANDLE_YY @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`checksum_option: NO_HANDLE_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 64U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) checksum_option: CHECK_YY  @>
@ \<checksum type optional> $\longrightarrow$ \.{CHECK\_YY}.
\initials{LDF 2014.01.02.}

\LOG
\initials{LDF 2014.01.02.}
Added this rule
\ENDLOG

@<Rules@>=

@=checksum_option: CHECK_YY @>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`checksum_option: CHECK_YY'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 128U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q ***** (5) @>


@q **** (4) statement --> STORE_YY PUBLIC_KEY_YY store_public_key_options.  @>

@ \<statement> $\longrightarrow$ \.{STORE\_YY} \.{PUBLIC\_KEY\_YY}
\<store public key options>.
\initials{LDF 2014.01.21.}

\LOG
\initials{LDF 2014.01.21.}
Added this rule.  
\ENDLOG

@<Rules@>=

@=statement: STORE_YY PUBLIC_KEY_YY store_public_key_options @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: STORE_YY PUBLIC_KEY_YY store_public_key_options'."
             << endl
             << "`store_public_key_options' (3) (Options) == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    Response_Type response;
    response.type = Response_Type::PROCESS_PENDING_TYPE;
    param->response_deque.push_back(response);

    stringstream temp_strm;

    response.clear();
    response.type           = Response_Type::STORE_PUBLIC_KEY_TYPE;
    response.local_filename = "";
    response.string_val     = "";
    response.options        = @=$3@>;

    response.command = temp_strm.str();

    param->response_deque.push_back(response);

    temp_strm.str("");

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};


@q **** (4) store_public_key_options @>
@ \<store public key options>.
\initials{LDF 2014.01.22.}

\LOG
\initials{LDF 2014.01.22.}
Added this rule.
\ENDLOG

@<Token and type declarations@>=

@=%type <uint_value> store_public_key_options @>

@q ***** (5) store_public_key_options: /* Empty  */  @>

@ \<store public key options> $\longrightarrow$ \.{Empty}.
\initials{LDF 2014.01.22.}

\LOG
\initials{LDF 2014.01.22.}
Added this rule.
\ENDLOG

@<Rules@>=
@=store_public_key_options: /* Empty */@>
{
    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`store_public_key_options: /* Empty  */'."
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    @=$$@> = 0U;

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};

@q **** (4) statement --> PULL_YY RESPONSE_YY INTEGER_YY STRING_YY STRING_YY STRING_YY @>

@ \<statement> $\longrightarrow$ \.{PULL\_YY} \.{RESPONSE\_YY} 
\.{INTEGER\_YY} \.{STRING\_YY} \.{STRING\_YY} \.{STRING\_YY}.
\initials{LDF 2014.02.11.}

\LOG
\initials{LDF 2014.02.11.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: PULL_YY RESPONSE_YY INTEGER_YY STRING_YY STRING_YY STRING_YY@>
{
@q ***** (5) @>

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: PULL_YY RESPONSE_YY INTEGER_YY STRING_YY'."
             << endl
             << "`INTEGER_YY' (3) (Response code) == " << @=$3@>
             << endl
             << "`STRING_YY'  (4) (Client-side path) == " << @=$4@>
             << endl
             << "`STRING_YY'  (5) (Server-side path) == " << @=$5@>
             << endl
             << "`STRING_YY'  (6) (Message)          == " << @=$6@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex(); 
    lock_cerr_mutex(); 
    cout << "Pull response -->" 
         << endl
         << "Response code:     " << @=$3@> << "   " << gwstrerror(@=$3@>)
         << endl
         << "Client-side path:  " << @=$4@>
         << endl
         << "Server-side path:  " << @=$5@>
         << endl
         << "Message:           " << @=$6@>
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex(); 

    if (@=$3@> == GW_ERROR)
    {
       ++param->errors_occurred; 
    }
    else if (@=$3@> == GW_WARNING)
    {
       ++param->warnings_occurred; 
    }
    else if (@=$3@> == GW_NOTICE || @=$3@> == GW_IRODS_OBJECT_UNCHANGED)
    {
       ++param->notices_occurred;   
    }

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

@q ***** (5) @>

};



@q **** (4) statement --> DUMMY_STATEMENT_YY STRING_YY @>

@ \<statement> $\longrightarrow$ \.{DUMMY\_STATEMENT\_YY} \.{STRING\_YY}.
\initials{LDF 2013.07.17.}

\LOG
\initials{LDF 2013.07.17.}
Added this rule.  It's used for testing.
\ENDLOG

@<Rules@>=

@=statement: DUMMY_STATEMENT_YY STRING_YY @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "] "
             << "`statement: DUMMY_STATEMENT_YY STRING_YY'."
             << endl
             << "`STRING_YY' == " << @=$2@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex(); 
    lock_cerr_mutex(); 
    cout << "Dummy statement -->" 
         << endl
         << "String:  " << @=$2@>
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex(); 

    temp_strm.str("");

    temp_strm << "DUMMY_STATEMENT RESPONSE 0";

    Response_Type response;
    response.type = Response_Type::COMMAND_ONLY_TYPE;

    response.command = temp_strm.str();

    param->response_deque.push_back(response);

    temp_strm.str("");

    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};



@q **** (4) statement --> DUMMY_STATEMENT_YY RESPONSE_YY INTEGER_YY @>

@ \<statement> $\longrightarrow$ \.{DUMMY\_STATEMENT\_YY} \.{RESPONSE\_YY} 
\.{INTEGER\_YY}.
\initials{LDF 2013.04.19.}

\LOG
\initials{LDF 2013.04.19.}
Added this rule.
\ENDLOG

@<Rules@>=

@=statement: DUMMY_STATEMENT_YY RESPONSE_YY INTEGER_YY @>
{

    Scan_Parse_Parameter_Type* param 
         = static_cast<Scan_Parse_Parameter_Type*>(yyget_extra(parameter));

    bool save_PARSER_DEBUG = param->PARSER_DEBUG;
    param->PARSER_DEBUG = false;  /* |true| |save_PARSER_DEBUG| */

#if DEBUG_COMPILE 
    if (param->PARSER_DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "[Thread " << param->thread_ctr << "]  In `yyparse', rule "
             << "`statement: DUMMY_STATEMENT_YY RESPONSE_YY INTEGER_YY'."
             << endl
             << "`INTEGER_YY' == " << @=$3@>
             << endl;
        unlock_cerr_mutex(); 

    }  /* |if (param->PARSER_DEBUG)|  */  
#endif  /* |DEBUG_COMPILE|  */ 

    lock_cout_mutex(); 
    lock_cerr_mutex(); 
    cout << "Dummy statement response -->" 
         << endl
         << "Response code:  " << @=$3@>
         << endl;
    unlock_cerr_mutex(); 
    unlock_cout_mutex(); 


    param->PARSER_DEBUG = save_PARSER_DEBUG; 

};



@
@<Garbage@>=
/* Empty  */

@ Putting parser together.
@c
@=%{@>
@<Include files@>@;@/
using namespace std;
using namespace gwrdifpk;
static stringstream temp_strm;
static int status;
@<Declarations of additional functions@>@;@/
#if 0 
@<Garbage@>@;@/
#endif 
@=%}@>
@<Options@>@;@/
@<|union| declaration@>@;@/
@<Token and type declarations@>@;@/
@=%%@>
@q Rules @>
@<Rules@>@;@/

@q * (1) Emacs-Lisp code for use in indirect buffers  @>

@q (progn (cweb-mode) (outline-minor-mode) (setq abbrev-mode t)        @>

@q * (1) Local variables for Emacs @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q abbrev-mode:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>

