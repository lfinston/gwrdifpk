@q spptfnc1.web  @>
@q Created by Laurence D. Finston (LDF) Wed Feb 13 13:03:58 CET 2013  @>

@q * (1) Copyright and License.@>

@q This file is part of gwrdifpk, a package for long-term archiving.  @>
@q Copyright (C) 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021 Gesellschaft fuer wissenschaftliche Datenverarbeitung mbH Goettingen @>

@q gwrdifpk is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version.  @>

@q gwrdifpk is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details.  @>

@q You should have received a copy of the GNU General Public License          @>
@q along with gwrdifpk; if not, write to the Free Software                    @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q gwrdifpk is available for downloading via Git from @>
@q https://github.com/gwdg/gwrdifpk.git    @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de@>

@q Laurence D. Finston                                                   @>
@q Kreuzbergring 41         					         @>
@q 37075 Goettingen              					 @>
@q Germany                           					 @>                                

@q Laurence.Finston@@gmx.de (@@ stands for a single "at" sign.)@>

@q ** (2) spptfnc1.web  @>
@* {\bf Scan\_Parse\_Parameter\_Type} function definitions 1.

@q ** (2) Include files  @>

@ Include files.

@<Include files@>=
#include <stdlib.h>  /* Standard Library for C  */
#include <stdio.h>
#include <sys/mman.h>
#include <errno.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <limits.h>
#include <string.h>
#include <ctype.h>

#include <algorithm> /* Standard Template Library (STL) for C++  */
#include <bitset>
#include <fstream> 
#include <iomanip>
#include <ios>
#include <iostream>
#include <map>
#include <string>
#include <time.h>
#include <math.h>
#include <sstream>  

#include <vector>
#include <deque>
#include <stack>
#include <set>

#include <pthread.h>  /* POSIX threads  */

#include <gcrypt.h> /* for |gcry_control| */
#include <gnutls/gnutls.h>
#include<gnutls/x509.h>

#include <mysql.h>

#include <expat.h>

#if HAVE_CONFIG_H
#include <config.h>
#endif 

#undef NAME_LEN
#undef LOCAL_HOST

#include "rspercds.h++"
#include "glblcnst.h++"
#include "glblvrbl.h++"
#include "excptntp.h++"
#include "utilfncs.h++"
#include "grouptp.h++"
#include "hndlvltp.h++"
#include "irdsavtp.h++"
#include "helper.h++"
#include "tanfncs.h++"
#include "pidfncs.h++"
#include "parser.h++"
#include "scanner.h++"
#include "rspnstp.h++"
#include "irdsobtp.h++"
#include "hndltype.h++"
#include "dcmdsbtp.h++"
#include "dcmtdttp.h++"
#include "x509cert.h++"
#include "dstngnmt.h++"
#include "pullrqtp.h++"
#include "scprpmtp.h++"
#include "usrinftp.h++"

@q ** (2) @>
@
@<External function declarations@>=
int 
yyparse(yyscan_t parameter);

@q *** (3) |Scan_Parse_Parameter_Type| functions 1.@>
@ {\bf Scanner\_Type} functions 1.
\initials{LDF 2013.02.13.}

@q **** (4) Get handle.  (|get_handle|).  @>
@ Get handle.  (|get_handle|).
\initials{LDF 2012.10.15.}

\LOG
\initials{LDF 2012.10.15.}
Added this function.

\initials{LDF 2013.02.13.}
Moved the definition of this function from \filename{scprpmtp.web} to 
this file (\filename{spptfnc1.web}).

\initials{LDF 2013.12.19.}
Added optional argument |unsigned int options = 0U|.
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::get_handle| definition@>=

int
Scan_Parse_Parameter_Type::get_handle(string s, 
                                      unsigned int flags, 
                                      unsigned int options,
                                      string filename_1)
{
@q ****** (6) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] Entering `Scan_Parse_Parameter_Type::get_handle'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

   int status;

   string filename;
   string handle_str;

   stringstream sql_strm;
   stringstream temp_strm;


   MYSQL_RES *result = 0;
   unsigned int row_ctr;
   unsigned int field_ctr;

   Response_Type response;
   response.type = Response_Type::COMMAND_ONLY_TYPE;

@q ****** (6) Select ``handlesystem'' or ``handlesystem_standalone'' database.  @>

@ Select ``handlesystem'' or ``handlesystem\_standalone'' database.
\initials{LDF 2012.10.15.}

@<|Scan_Parse_Parameter_Type::get_handle| definition@>=

   string database_name = (standalone_handle) ? "handlesystem_standalone" : "handlesystem";

   status = mysql_select_db(mysql_ptr, database_name.c_str());

   if (status == 0)
   {  

#if DEBUG_COMPILE
        
       if (DEBUG)
       {
          lock_cerr_mutex(); 
          cerr << "In `Scan_Parse_Parameter_Type::get_handle':  "
               << "`mysql_select_db succeeded'."
               << endl
               << "Selected `" << database_name << "' database successfully."
               << endl;
          unlock_cerr_mutex();

       }  /* |if (DEBUG)|  */ 

#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |if (status == 0)| */

   else /* |status != 0| */
   {
      lock_cerr_mutex(); 
      cerr << "In `Scan_Parse_Parameter_Type::get_handle':  "  
           << "`mysql_select_db' failed, returning " << status 
           << endl
           << "Failed to select `" << database_name << "' database:"
           << endl
           << "Error:  " << mysql_error(mysql_ptr)
           << endl 
           << "Exiting function unsuccessfully with return value 1."
           << endl;
      unlock_cerr_mutex();

      temp_strm.str("");

      temp_strm << "GET HANDLE RESPONSE 1 " << options << "U HANDLE \"" << s << "\"\n";
      response.command = temp_strm.str();
      response_deque.push_back(response);

      ++errors_occurred;

      return 1;

   }   /* |else| (|status != 0|) */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_handle| definition@>=

   if (flags & 1U)
   {
@q ******* (7) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::get_handle':"
                << endl 
                << "`flags & 1U' == 1.  Getting handle for filename `" << s << "'." 
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       filename = s;

       Irods_Object_Type irods_object;
       irods_object.path = filename;

       temp_strm.str("");

       temp_strm << "env irodsEnvFile=" << irods_env_filename 
                 << " imeta ls -ld " << filename << " PID";
 
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       int ctr;

       status = irods_object.get_avus_from_irods_system(temp_strm.str(), filename, *this, &ctr);
  
       if (status != 0)
       {
          cerr << "[Thread " << thread_ctr << "] "
               << "ERROR!  In `Scan_Parse_Parameter_Type::get_handle':"
               << endl
               << "``Irods_Object_Type::get_avus_from_irods_system' failed, returning " 
               << status << "."
               << endl
               << "Failed to read iRODs user-defined metadata for iRODS object "
               << "`" << filename << "."
               << endl 
               << "Exiting function unsuccessfully with return value 1."
               << endl;

          temp_strm.str("");
          temp_strm << "GET HANDLE RESPONSE 1 " << options << "U";

          response.command = temp_strm.str();
          response_deque.push_back(response);

          ++errors_occurred;

          return 1;

       }  /* |if (status != 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_handle| definition@>=

#if DEBUG_COMPILE
       else if (DEBUG)
       {
          lock_cerr_mutex(); 
          cerr << "[Thread " << thread_ctr << "] "
               << "In `Scan_Parse_Parameter_Type::get_handle':"
               << endl
               << "``Irods_Object_Type::get_avus_from_irods_system' succeeded, returning 0."
               << endl;

          irods_object.show("irods_object:");
          cerr << "ctr == " << ctr << endl;

          unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

 
@q ******* (7) Call this function recursively in loop.  @>

@ Call this function recursively in loop.  
\initials{LDF 2012.11.22.}

@<|Scan_Parse_Parameter_Type::get_handle| definition@>=

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "Before loop." << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       for (vector<Irods_AVU_Type>::iterator iter = irods_object.avu_vector.begin();
            iter != irods_object.avu_vector.end();
            ++iter)
       {
@q ******** (8) @>

             status = get_handle(iter->value, 0, 0, filename);
  
@q ******** (8) @>

             if (status != 0)
             {
                 lock_cerr_mutex(); 
                 cerr << "[Thread " << thread_ctr << "] WARNING!"
                      << endl 
                      << "In `Scan_Parse_Parameter_Type::get_handle':"
                      << endl
                      << "Recursive call to `Scan_Parse_Parameter_Type::get_handle' failed, "
                      << "returning " << status << "."
                      << endl
                      << "Will try to continue."
                      << endl;
                 unlock_cerr_mutex(); 

                 ++warnings_occurred;

                 continue;
        
             }  /* |if (status != 0)|  */


@q ******** (8) @>

#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << "[Thread " << thread_ctr << "] "
                      << "In `Scan_Parse_Parameter_Type::get_handle':"
                      << endl
                      << "Recursive call to `Scan_Parse_Parameter_Type::get_handle' succeeded, "
                      << "returning 0."
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
  
@q ******** (8) @>
 
       }  /* |for|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_handle| definition@>=

       return 0;

   }  /* |if (flags & 1U)|  */

@q ****** (6) @>

   else /* | (flags & 1U == 0)|  */
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::get_handle':"
                << endl 
                << "`flags & 1U' == 0.  Getting handle for PID `" << s << "'." 
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


       handle_str = s;

       sql_strm << "select handle_id, handle_value_id, idx, type, "
                << "length(data), data, "           
                << "ttl_type, ttl, timestamp, length(refs), refs, admin_read, "
                << "admin_write, pub_read, pub_write, marked_for_deletion, created, "
                << "last_modified, "
                << "handle, created_by_user_id, irods_object_id, delete_from_database_timestamp "
                << "from handles where handle = '" << handle_str << "' "
                << "order by idx";

   }  /* |else| (|flags & 1U == 0|)  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_handle| definition@>=


#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_handle| definition@>=

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);                   

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  In `Scan_Parse_Parameter_Type::get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
            << status << "."
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to retrieve handle values."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
           mysql_free_result(result);
       }

       temp_strm.str("");

       temp_strm << "GET HANDLE RESPONSE 2 " << options << "U HANDLE \"" << s << "\"\n";
       response.command = temp_strm.str();
       response_deque.push_back(response);

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
            << endl
            << "`row_ctr' == " << row_ctr
            << endl
            << "`field_ctr' == " << field_ctr
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_handle| definition@>=

   if (row_ctr == 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] WARNING!  "
            << "In `Scan_Parse_Parameter_Type::get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned 0 rows."
            << endl
            << "Failed to retrieve handle data."
            << endl 
            << "Exiting function unsuccessfully with return value 2."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       temp_strm.str("");

       temp_strm << "GET HANDLE RESPONSE 3 " << options << "U HANDLE \"" << s << "\"";

       response.command = temp_strm.str();
       response_deque.push_back(response);

       ++warnings_occurred;

       return 2;

   }  /* |if (row_ctr == 0)|  */
   
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::get_handle':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded, returning "
            << row_ctr << " rows."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

@ 
\LOG
\initials{LDF 2013.03.01.}
@:BUG FIX@> BUG FIX:  Changed the type of |temp_handle_value_vector| 
from |vector<Handle_Value_Type*>| to 
|vector<Handle_Value_Type>| and that of |handle_obj| from |Handle_Value_Type*| to 
|Handle_Value_Type|.  Previously, I was using pointers and allocating memory on the 
heap because of errors when using |Handle_Value_Type|.  The reason for the errors 
was bugs in the |Handle_Value_Type| default constructor and destructor with respect 
to the way the data members |char *data| and |char *refs| were handled.  I have since
corrected the errors, so there's no need to use pointers now.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::get_handle| definition@>=

   MYSQL_ROW curr_row;

   vector<Handle_Value_Type> temp_handle_value_vector;

   Handle_Value_Type handle_obj;

   Handle_Type *curr_handle = new Handle_Type;

   for (int i = 0; i < row_ctr; ++i)
   {
@q ******* (7) @>

       if ((curr_row = mysql_fetch_row(result)) == 0)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_handle':"
                << endl 
                << "`mysql_fetch_row' failed:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           temp_strm.str("");

           temp_strm << "GET HANDLE RESPONSE 4 " << options << "U HANDLE \"" << s << "\"\n";
           response.command = temp_strm.str();
           response_deque.push_back(response);

           ++errors_occurred;

           return 1;

       }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ******* (7) @>

       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::get_handle':"
                << endl 
                << "`mysql_fetch_row' succeeded."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */ 


@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_handle| definition@>=

       status = handle_obj.set(curr_row, field_ctr, handle_str, thread_ctr);

       if (status != 0)
       {

           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_handle':"
                << endl 
                << "`Handle_Value_Type::set' failed, returning " << status << "."
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           if (result)
              mysql_free_result(result);
 
           temp_strm.str("");

           temp_strm << "GET HANDLE RESPONSE 5 " << options << "U HANDLE \"" << s << "\"\n";
           response.command = temp_strm.str();
           response_deque.push_back(response);

           ++errors_occurred;

           return 1;

       }  /* |if (status != 0)|  */
#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "`Handle_Value_Type::set' succeeded, returning 0."
                << endl;
           unlock_cerr_mutex(); 
       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (!filename_1.empty())
       {
           handle_obj.filename = filename_1;
       }

       curr_handle->handle_value_map[handle_obj.idx] = handle_obj;

       temp_handle_value_vector.push_back(handle_obj);

       handle_obj.clear();

@q ******* (7) @>

   }  /* |for|  */

   mysql_free_result(result);
   result = 0;


   curr_handle->handle    = curr_handle->handle_value_map.begin()->second.handle;
   curr_handle->handle_id = curr_handle->handle_value_map.begin()->second.handle_id;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "temp_handle_value_vector.size() == " << temp_handle_value_vector.size() << endl;
    
       for (vector<Handle_Value_Type>::const_iterator iter = temp_handle_value_vector.begin();
            iter != temp_handle_value_vector.end();
            ++iter)
       {
           iter->show();

       }  /* |for|  */

       curr_handle->show("*curr_handle:");

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_handle| definition@>=

   response.type = Response_Type::SEND_HANDLE_TYPE;

   response.handle = curr_handle;
   response.options = options;
   response_deque.push_back(response);
    

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_handle| definition@>=

   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] Exiting `Scan_Parse_Parameter_Type::get_handle' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 

   return 0;

@q ****** (6) @>

}  /* End of |Scan_Parse_Parameter_Type::get_handle| definition  */

@q **** (4) Get metadata.  @>
@ Get metadata.
\initials{LDF 2012.10.09.}

\LOG
\initials{LDF 2012.10.09.}
Added this function.

\initials{LDF 2012.12.21.}
Added the optional arguments |bool send_response|, |bool do_output|, 
|bool do_irods_user_metadata| and 
|vector<Dublin_Core_Metadata_Type> *dc_metadata_type_vector_ptr|.  Adapting this
function for use with |Scan_Parse_Parameter_Type::add_metadata|.  For this use, 
|get_metadata| should store the data from the database in |Dublin_Core_Metadata_Type|
objects in |*dc_metadata_type_vector_ptr| but neither output XML code to a temporary file
nor send responses to the peer.

\initials{LDF 2012.12.31.}
Added optional argument |unsigned int options| with the default 0.

\initials{LDF 2013.01.04.}
Added code for sending responses in the error cases.

\initials{LDF 2013.02.13.}
Moved the definition of this function from \filename{scprpmtp.web} to 
this file (\filename{spptfnc1.web}).

\initials{LDF 2013.05.23.}
Replaced the optional argument |bool send_response = true| with the 
optional arguments |char *buffer_ptr = 0| and |size_t buffer_size = 0|.

\initials{LDF 2013.12.18.}
Replaced optional argument 
|vector<Dublin_Core_Metadata_Type> *dc_metadata_type_vector_ptr = 0|
with 
|map<unsigned long int, Dublin_Core_Metadata_Type> *dc_metadata_type_map_ptr = 0|.
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

int
Scan_Parse_Parameter_Type::get_metadata(string filename, 
                                        unsigned int flags, 
                                        int *ctr,
                                        unsigned int options,
                                        char *buffer_ptr,
                                        size_t buffer_size,
                                        bool do_output,
                                        bool do_irods_user_metadata,
                                        map<unsigned long int, Dublin_Core_Metadata_Type>
                                           *dc_metadata_map_ptr)
{
@q ****** (6) @>

     bool DEBUG = false;  /* |true|  */ 

     set_debug_level(DEBUG, 0, 0);

     stringstream temp_strm;

     int status = 0;

     Response_Type response;
     response.type = Response_Type::COMMAND_ONLY_TYPE;

     unsigned long temp_val;

     Dublin_Core_Metadata_Sub_Type dcm_sub;

     multimap<unsigned int, Dublin_Core_Metadata_Sub_Type>::iterator dc_metadata_sub_iter;

     vector<string> irods_object_path_vector;

     map<unsigned long int, Dublin_Core_Metadata_Type> dc_metadata_map;

     temp_strm << "[Thread " << thread_ctr << "] ";

     string thread_str = temp_strm.str();

     temp_strm.str("");

     string database = (is_gwirdsif) ? "gwirdsif" : "gwirdcli";

#if DEBUG_COMPILE 
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << thread_str
              << "Entering `Scan_Parse_Parameter_Type::get_metadata'."
              << endl
              << "`filename' == " << filename
              << endl 
              << "`flags' == " << hex << flags << dec 
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */

     string cmd_str;




@q ****** (6) @>
@ 
\LOG
\initials{LDF 2013.01.09.}
@:BUG FIX@> BUG FIX:  Added code for setting |cmd_str|.  Similar code must have
existed before;  I must have removed it by mistake sometime.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

     if (flags & 1U)
        cmd_str = "PIDS";
     else
        cmd_str = "METADATA";

@q ****** (6) Check whether |filename| includes a slash.  @>
@ Check whether |filename| includes a slash.  If it doesn't, insert
|irods_current_dir| at the front of it.
\initials{LDF 2012.12.12.}

\LOG
\initials{LDF 2012.12.12.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

   
   size_t pos = filename.find('/');

   if (pos == string::npos)
   {
       filename.insert(0, "/");
       filename.insert(0, irods_current_dir);
   }

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "filename == " << filename << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   irods_object_path_vector.push_back(filename);

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

   Response_Type new_response;
   new_response.options |= 8U;  /* Get |Dublin_Core_Metadata_Sub_Type| items
                                   \initials{LDF 2013.12.18.}  */

   vector<unsigned int> id_vector;

   status = Dublin_Core_Metadata_Type::get_dc_metadata_from_database(mysql_ptr,
                                                                     new_response,
                                                                     dc_metadata_map,
                                                                     irods_object_path_vector,
                                                                     id_vector,
                                                                     false,
                                                                     0,
                                                                     database,
                                                                     thread_str);


@q ****** (6) @>
@
\LOG
\initials{LDF 2014.01.03.}
@:BUG FIX@> BUG FIX:  Added this conditional.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

   if (status == 2)
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::get_metadata':"
                << endl 
                << "`Dublin_Core_Metadata_Type::get_dc_metadata_from_database' succeeded, "
                << "returning 2:"
                << endl
                << "No existing Dublin Core metadata for iRODS object "
                << "with path `" << filename << "'"
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |if (status == 2)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

   else if (status != 0)
   {
            lock_cerr_mutex(); 
            cerr << thread_str << "ERROR!  "
                 << "In `Scan_Parse_Parameter_Type::get_metadata':"
                 << endl 
                 << "`Dublin_Core_Metadata_Type::get_dc_metadata_from_database' failed, "
                 << "returning " << status << ":"
                 << endl 
                 << "Failed to retrieve Dublin Core metadata from the `" << database << "' "
                 << "database."
                 << endl;

             if (buffer_ptr != 0 && buffer_size > 0)
             {
                 cerr << "Will send failure notice to client and "
                      << "exit function unsuccessfully with return value 1."
                      << endl;
             }
             else 
                 cerr << "Exiting function unsuccessfully with return value 1."
                      << endl;

            unlock_cerr_mutex(); 

            ++errors_occurred;

            if (buffer_ptr != 0 && buffer_size > 0)
            {
                temp_strm.str("");
                temp_strm << "GET " << cmd_str << " RESPONSE \"" << filename << "\" "
                          << "1 0 " << options << "U "
                          << "\"Error:  Failed to retrieve Dublin Core metadata from "
                          << "`" << database << "' database for iRODS object "
                          << "`" << filename << "'\"";
         
                strcpy(buffer_ptr, temp_strm.str().c_str());

            }  /* |if (buffer_ptr != 0 && buffer_size > 0)|  */

            ++errors_occurred;

            return 1;

   }  /* |else if (status != 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str
            << "In `Scan_Parse_Parameter_Type::get_metadata':"
            << endl 
            << "`Dublin_Core_Metadata_Type::get_dc_metadata_from_database' succeeded, "
            << "returning 0:"
            << endl
            << "`dc_metadata_map.size()' == " << dc_metadata_map.size()
            << endl;

#if 0 
       if (dc_metadata_map.size() > 0)
          cerr << "`dc_metadata_map':"
               << endl;

       for (map<unsigned long int, Dublin_Core_Metadata_Type>::iterator iter 
               = dc_metadata_map.begin();
            iter != dc_metadata_map.end();
            ++iter)
       {
           iter->second.show();
       }
#endif 

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "user_id == " << user_id << endl;
       cerr << "irods_current_dir == " << irods_current_dir << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

/* !! TODO:  LDF 2012.12.12.  Adjust to account for different "where" clauses.
   A query may return data for more than one user, |irods_object_path| value, etc.

 */

@q ****** (6) Send Dublin Core metadata to client to be shown.  @>

@ Send Dublin Core metadata to client to be shown.  
\initials{LDF 2013.12.18.}

\LOG
\initials{LDF 2013.12.18.}
Added this section.
\ENDLOG
 
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=


    if (   dc_metadata_map.size() > 0
        && buffer_ptr != 0 
        && buffer_size > 0 
        && options & 2U)  /* Show Dublin Core metadata.  \initials{LDF 2013.12.18.}  */
    {
@q ******* (7) @>
       
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str
                << "In `Scan_Parse_Parameter_Type::get_metadata':"
                << endl 
                << "`dc_metadata_map.size()' > 0 && "
                << "`buffer_ptr' != 0 && `buffer_size' > 0 && "
                << "`options & 2U' == `true':"
                << endl
                << "`dc_metadata_map.size()' == " << dc_metadata_map.size() << " (> 0)"
                << endl 
                << "`(buffer_ptr != 0)'      == " << (buffer_ptr != 0)
                << endl 
                << "`(buffer_size > 0)'      == " << (buffer_size > 0)
                << endl 
                << "`(options & 2U)'         == " << (options & 2U)
                << endl 
                << "Sending Dublin Core metadata to client to be shown."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */        

@q ******* (7) @>

       response.clear();
       response.type = Response_Type::FETCH_DC_METADATA_TYPE;

       for (map<unsigned long int, Dublin_Core_Metadata_Type>::iterator iter
               = dc_metadata_map.begin();
            iter != dc_metadata_map.end();
            ++iter)
          response.int_vector.push_back(iter->first);

       response.options = 8U;  /* Show full, i.e., with |Dublin_Core_Metadata_Sub_Type| 
                                  objects.   */


       response_deque.push_back(response);

       response.clear();

@q ******* (7) @>


    }  /* |if| Show Dublin Core metadata.  \initials{LDF 2013.12.18.}  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

#if DEBUG_COMPILE
    else if (DEBUG)
    {
        lock_cerr_mutex();
        cerr << thread_str
             << "In `Scan_Parse_Parameter_Type::get_metadata':"
             << endl 
             << "`dc_metadata_map.size()' == 0 || "
             << "`buffer_ptr' == 0 || `buffer_size' == 0 || "
             << "`options & 2U' == `false':"
             << endl 
             << "`dc_metadata_map.size()' == 0"
             << endl 
             << "`(buffer_ptr == 0)'      == " << (buffer_ptr == 0)
             << endl 
             << "`(buffer_size == 0)'     == " << (buffer_size == 0)
             << endl 
             << "`(options & 2U)'         == " << (options & 2U)
             << endl 
             << "Not sending Dublin Core metadata to client to be shown."
             << endl; 
        unlock_cerr_mutex(); 

    }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=




@q ****** (6) If |do_output == true|:  Output |dc_metadata_map| (XML).  @>

@ If |do_output == true|:  Output |dc_metadata_map| (XML).  
\initials{LDF 2012.12.13.}

The amount of XML code generated is likely to be fairly large, so a temporary file
is always created to hold it.  The gain in efficiency that could be acheived by using
a |char| buffer or a |stringstream| is outweighed by the inconvenience of writing code 
for dumping the contents to a file, if the size of the buffer is insufficient.
\initials{LDF 2012.12.13.}

@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

   if (dc_metadata_map.size() > 0 && do_output)
   {
@q ******* (7) @>

       ofstream out_strm;

       char temp_filename[] = "/tmp/gwirdsif.XXXXXX";

       errno = 0;
       int fd = mkstemp(temp_filename);

       if (fd == -1)
       {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] ERROR!  "
                 << "In `Scan_Parse_Parameter_Type::get_metadata':"
                 << endl 
                 << "`mkstemp' failed, returning -1:"
                 << endl 
                 << strerror(errno)
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            ++errors_occurred;

            if (buffer_ptr != 0 && buffer_size > 0)
            {
                temp_strm.str("");
                temp_strm << "GET " << cmd_str << " RESPONSE \"" << filename << "\" "
                          << "1 0 " << options << "U "
                          << "\"Error:  Failed to create server-side temporary file "
                          << "for XML metadata for iRODS object `" << filename << "'\"";
         
                strcpy(buffer_ptr, temp_strm.str().c_str());

            }  /* |if (buffer_ptr != 0 && buffer_size > 0)|  */

            ++errors_occurred;

            return 1;


       }  /* |if (fd == -1)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_metadata':"
                << endl 
                << "`mkstemp' succeeded.  `temp_filename' == `" << temp_filename << "'."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
   
       temp_file_vector.push_back(temp_filename);

       close(fd);  /* We just need the name.  \initials{LDF 2012.12.13.}  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

       out_strm.open(temp_filename);

       if (!(out_strm && out_strm.is_open() && out_strm.good()))
       {
             lock_cerr_mutex(); 
             cerr << "[Thread " << thread_ctr << "] ERROR!  "
                  << "In `Scan_Parse_Parameter_Type::get_metadata':"
                  << endl 
                  << "`ofstream::open' failed.  Failed to open `ofstream out_strm' "
                  << "(`" << temp_filename << "')."
                  << endl
                  << "Exiting function unsuccessfully with return value 1."
                  << endl;
             unlock_cerr_mutex(); 
 
             if (buffer_ptr != 0 && buffer_size > 0)
             {
                 temp_strm.str("");
                 temp_strm << "GET " << cmd_str << " RESPONSE \"" << filename << "\" "
                           << "1 0 " << options << "U "
                           << "\"Error:  Failed to write to server-side temporary file "
                           << "for XML metadata "
                           << "for iRODS object `" << filename << "'\"";
         
                 strcpy(buffer_ptr, temp_strm.str().c_str());

             }  /* |if (buffer_ptr != 0 && buffer_size > 0)|  */

             ++errors_occurred;

             return 1;

       }  /* |if (!(out_strm && out_strm.is_open() && out_strm.good()))|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_metadata':"
                << endl 
                << "`ofstream::open' succeeded.  "
                << "Opened `ofstream out_strm' (`" << temp_filename << "') " 
                << "successfully."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

       out_strm << "<?xml version=\"1.0\"?>"
                << endl << endl;


        for (map<unsigned long int, Dublin_Core_Metadata_Type>::const_iterator iter = 
                dc_metadata_map.begin();
             iter != dc_metadata_map.end();
             ++iter)
        {    
@q ******** (8) @>

             status = iter->second.output(out_strm);

             if (status != 0)
             {
                 lock_cerr_mutex(); 
                 cerr << "[Thread " << thread_ctr << "] ERROR!  "
                      << "In `Scan_Parse_Parameter_Type::get_metadata':"
                      << endl 
                      << "`Dublin_Core_Metadata_Type' failed, returning " << status << "."
                      << endl 
                      << "Will try to continue."
                      << endl;
                 unlock_cerr_mutex(); 

                 ++errors_occurred;

                 if (buffer_ptr != 0 && buffer_size > 0)
                 {
                     temp_strm.str("");
                     temp_strm << "GET " << cmd_str << " RESPONSE \"" << filename << "\" "
                               << "1 0 " << options << "U "
                               << "\"Error (server-side):  Failed to output XML metadata "
                               << "for iRODS object `" << filename << "'\"";
         
                     strcpy(buffer_ptr, temp_strm.str().c_str());

                 }  /* |if (buffer_ptr != 0 && buffer_size > 0)|  */

             }  /* |if|  */

@q ******** (8) @>

#if DEBUG_COMPILE
             else if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << "[Thread " << thread_ctr << "] "
                      << "In `Scan_Parse_Parameter_Type::get_metadata':"
                      << endl 
                      << "`Dublin_Core_Metadata_Type::output' succeeded, returning 0."
                      << endl;
                 unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

        }  /* |for|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

        out_strm.close();

#if DEBUG_COMPILE
        if (DEBUG)
        {
            temp_strm.str("");

            temp_strm << "cat " << temp_filename;

            lock_cerr_mutex(); 
            cerr << "Outputting `" << temp_filename << "':" 
                 << endl << endl;

            status = system(temp_strm.str().c_str());

            cerr << endl;

            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

        if (buffer_ptr != 0 && buffer_size > 0)
        {
            response.clear();
            response.type = Response_Type::SEND_METADATA_TYPE;

            temp_strm.str("");

            temp_strm << "SERVER SENDING METADATA FILE "
                      << "\"" << filename << "\" " << options << "U";

            response.command = temp_strm.str();
  
            temp_strm.str("");

            response.local_filename = temp_filename;

            response_deque.push_back(response); 
  
        }  /* |if (buffer_ptr != 0 && buffer_size > 0)|  */
  
@q ******* (7) @>

   }  /* |if (dc_metadata_map.size() > 0 && do_output)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "dc_metadata_map.size() == 0 || `do_output' == `false':"
            << endl 
            << "`dc_metadata_map.size()' == " << dc_metadata_map.size()
            << endl 
            << "`do_output'              == " << do_output
            << endl 
            << "Not writing XML data to a temporary file."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

   if (dc_metadata_map.size() > 0 && dc_metadata_map_ptr != 0)
   {
@q ******* (7) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "`dc_metadata_map_ptr' != 0.  Will copy "
                << "`dc_metadata_map' to `*dc_metadata_map_ptr'."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

       dc_metadata_map_ptr->clear();
       *dc_metadata_map_ptr = dc_metadata_map;

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "`dc_metadata_map_ptr->size()' == "
                << dc_metadata_map_ptr->size()
                << "." << endl;
           
           for (map<unsigned long int, Dublin_Core_Metadata_Type>::const_iterator iter 
                   = dc_metadata_map_ptr->begin();
                iter != dc_metadata_map_ptr->end();
                ++iter)
            {
                iter->second.show();
            }

            cerr << endl;

           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

   }  /* |if (dc_metadata_map.size() > 0 && dc_metadata_map_ptr != 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

GET_METADATA_IRODS_USER_METADATA:

   if (!do_irods_user_metadata)
   {

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::get_metadata':"
                 << endl
                 << "`do_irods_user_metadata' == `false'.  Not retrieving iRODS user metadata "
                 << "(AVU triplets)." 
                 << endl 
                 << "Exiting function successfully with return value 0."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       return 0;

   }  /* |if (!do_irods_user_metadata)|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

     if (icommands)
     {
@q ******* (7) @>

#if DEBUG_COMPILE 
         if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "[Thread " << thread_ctr << "] In `Scan_Parse_Parameter_Type::get_metadata':"
                  << endl
                  << "`icommands' == `true'."
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

         response.clear();
         response.type = Response_Type::COMMAND_ONLY_TYPE;

         temp_strm.str("");

         temp_strm << "env irodsEnvFile=" << irods_env_filename << " "
                   << "imeta ls -ld "
                   << filename;

         if (flags & 1U)  /* (PID attribute-value-units triplets only) */
         {
@q ******** (8) @>


#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "] "
                     << "In `Scan_Parse_Parameter_Type::get_metadata':"
                     << endl
                     << "`flags & 1U' == " << (flags & 1U)
                     << endl
                     << "Only retrieving \"PID\" attribute-value pairs."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

            temp_strm  << " PID";

            cmd_str = "PIDS";

@q ******** (8) @>

         }  /* |if (flags & 1U)| (PID attribute-value-units triplets only)  */

         else
            cmd_str = "METADATA";

@q ******* (7) @>

#if DEBUG_COMPILE
         if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "temp_strm.str() == " << temp_strm.str() << endl;
             unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=
          
             Irods_Object_Type irods_object;
             irods_object.path = filename;

             status = irods_object.get_avus_from_irods_system(temp_strm.str(), 
                                                              filename, 
                                                              *this, 
                                                              ctr);
  
             if (status != 0)
             {
                cerr << "[Thread " << thread_ctr << "] "
                     << "ERROR!  In `Scan_Parse_Parameter_Type::get_metadata':"
                     << endl
                     << "``Irods_Object_Type::get_avus_from_irods_system' failed, returning " 
                     << status << "."
                     << endl
                     << "Failed to read iRODs user-defined metadata for iRODS object "
                     << "`" << filename << "."
                     << endl 
                     << "Exiting function unsuccessfully with return value 1."
                     << endl;

                ++errors_occurred;

                if (buffer_ptr != 0 && buffer_size > 0)
                {
                    temp_strm.str("");
                    temp_strm << "GET " << cmd_str << " RESPONSE \"" << filename << "\" "
                              << "1 0 " << options << "U "
                              << "\"Error:  Failed to read iRODS user-defined metadata "
                              << "for iRODS object `" << filename << "'\"";
                
                    strcpy(buffer_ptr, temp_strm.str().c_str());

                }  /* |if (buffer_ptr != 0 && buffer_size > 0)|  */

                ++errors_occurred;

                return 1;

             }  /* |if (status != 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

/* !! TODO:  LDF 2013.03.22.  Try getting the AVUs out of the database;  
   probably at an earlier point
   than here, i.e., when the |Irods_Object_Type| object is created. */


#if DEBUG_COMPILE
             else if (DEBUG)
             {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "] "
                     << "In `Scan_Parse_Parameter_Type::get_metadata':"
                     << endl
                     << "``Irods_Object_Type::get_avus_from_irods_system' succeeded, returning 0."
                     << endl;

                irods_object.show("irods_object:");
                unlock_cerr_mutex(); 

             }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

             temp_strm.str("");

             string blank_str;

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

             if (flags & 1U)  /* (PID attribute-value-units triplets only) */
             {
                temp_strm << "GET PIDS RESPONSE \"" << filename << "\" 0 "
                          << irods_object.avu_vector.size() << " " << options << "U \"";

                for (vector<Irods_AVU_Type>::const_iterator iter 
                        = irods_object.avu_vector.begin();
                     iter != irods_object.avu_vector.end();
                     ++iter)
                {
                    temp_strm << blank_str << iter->value;

                    blank_str = " ";
                }

                temp_strm << "\"";

             }  /* |if (flags & 1U)|  (PID attribute-value-units triplets only) */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=


             else  /* (all attribute-value-units triplets) */
             {
                temp_strm << "GET METADATA RESPONSE \"" << filename << "\" 0 "
                          << irods_object.avu_vector.size() << " " << options << "U ";

                for (vector<Irods_AVU_Type>::const_iterator iter 
                        = irods_object.avu_vector.begin();
                     iter != irods_object.avu_vector.end();
                     ++iter)
                {
                    temp_strm << blank_str << "ATTRIBUTE \"" << iter->attribute << "\" "
                              << "VALUE \"" << iter->value << "\" "
                              << "UNITS \"" << iter->units << "\" "
                              << "TIME_SET " << iter->time_set << "U";

                    blank_str = " ";
                }

             }  /* |else|  (all attribute-value-units triplets) */


#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << "temp_strm.str() == " << temp_strm.str() << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

             if (buffer_ptr != 0 && buffer_size > 0)
             {
                 strcpy(buffer_ptr, temp_strm.str().c_str());

             }  /* |if (buffer_ptr != 0 && buffer_size > 0)|  */


@q ******* (7) @>

     }  /* |if (icommands)|  */

@q ****** (6) @>

     else  /* |!icommands|  */
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] "
              << "WARNING!  In `Scan_Parse_Parameter_Type::get_metadata':"
              << "`icommands' == `false'.  This case hasn't been programmed yet."
              << endl
              << "Continuing."
              << endl;
         unlock_cerr_mutex(); 

     }   /* |else| (|!icommands|)  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>=

#if DEBUG_COMPILE 
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] "
              << "Exiting `Scan_Parse_Parameter_Type::get_metadata' "
              << "successfully with return value 0."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */       
#endif /* |DEBUG_COMPILE|  */

     return 0;

}  /* End of |Scan_Parse_Parameter_Type::get_metadata| definition  */



@q **** (4) Add metadata.  @>
@ Add metadata..
\initials{LDF 2012.12.14.}

\LOG
\initials{LDF 2012.12.14.}
Added this function.

\initials{LDF 2013.02.13.}
Moved the definition of this function from \filename{scprpmtp.web} to 
this file (\filename{spptfnc1.web}).
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

int
Scan_Parse_Parameter_Type::add_metadata(Response_Type &response)
{
@q ****** (6) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   int status;

   size_t pos;

   stringstream temp_strm;

   Response_Type new_response;
   new_response.type = Response_Type::COMMAND_ONLY_TYPE;

   int items_written = 0;

   vector<Handle_Type> handle_vector;

   vector<Handle_Type> irods_object_handle_vector;

   bool store       = false;
   bool force_add   = false;
   bool force_store = false;

   string irods_object_path;  

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] Entering `Scan_Parse_Parameter_Type::add_metadata'."
            << endl;
       response.show("response:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

   if (response.metadata_options & 1U)
      force_add = true;

   if (response.metadata_options & 2U)
      force_store = true;

   if (response.metadata_options & 4U)
      store = true;

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

    pos = response.local_filename.find("/");
 
    if (pos == string::npos)
    {
        response.local_filename.insert(0, "/");
        response.local_filename.insert(0, irods_current_dir);

    }

    pos = response.remote_filename.find("/");
 
    if (pos == string::npos)
    {
        response.remote_filename.insert(0, "/");
        response.remote_filename.insert(0, irods_current_dir);

    }



#if DEBUG_COMPILE
    if (DEBUG)
    {
        lock_cerr_mutex(); 
        cerr << "response.local_filename == " << response.local_filename << endl
             << "response.remote_filename == " << response.remote_filename << endl;
        unlock_cerr_mutex(); 

    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) Test for existence of iRODS object.  @>

@ Test for existence of iRODS object.  
\initials{LDF 2012.12.31.}

\LOG
\initials{LDF 2012.12.31.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

@q ******* (7) @>

   bool irods_object_exists;

   Irods_AVU_Type curr_avu;

   Irods_Object_Type curr_irods_object(user_id, response.local_filename);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       curr_irods_object.show("curr_irods_object:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ******* (7) @>

@ Calling |Irods_Object_Type::get_from_database| with the |bool id_only| argument $=$ |false|.
This way, the |curr_irods_object.handle_id_vector| will be filled, if there are
entries for this iRODS object in the \.{gwirdsif.Irods\_Objects\_Handles}.
\initials{LDF 2013.01.31.}

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

   status = curr_irods_object.get_from_database(mysql_ptr, false);

   if (status < 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "ERROR! In `Scan_Parse_Parameter_Type::add_metadata':"
            << endl
            << "`Irods_Object_Type::get_from_database' failed, returning " 
            << status << "."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       temp_strm.str("");

       temp_strm << "ADD METADATA RESPONSE 1 \"" << response.remote_filename << "\" " 
                 << "\"" << response.local_filename << "\" "
                 << "\"Checking for existence of iRODS object " 
                 << "`" << response.local_filename << "' failed.\"";

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       new_response.command = temp_strm.str();
  
       response_deque.push_back(new_response);

       ++errors_occurred;

       return 1;


   }  /* |if (status < 0)|  */
    
@q ******* (7) @>

@ Under normal circumstances, this should never happen.  It could happen, if
iRODS objects are created without using \.{gwrdifpk}, i.e., using \.{iput} 
directly.  This shouldn't be possible, except for the administrator of 
\.{gwrdifpk}.  However, as of this date, the database tables in the \.{gwirdsif} database
(\.{Irods\_Objects}, \.{Irods\_AVUs}, etc.) are not needed for the proper operation 
of \.{gwrdifpk}.
\initials{LDF 2013.06.06.}

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

   else if (status == 0)
   {
@q ******** (8) @>

       irods_object_exists = false;

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::add_metadata':"
                << endl
                << "`Irods_Object_Type::get_from_database' returned 0."
                << endl
                << "Will use `ils' to query iRODS server."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */        


@q ******** (8) @>

       char buffer[512];
       memset(buffer, 0, 512);
       string temp_filename;

       status = ls(buffer, 512, &temp_filename, 0, response.local_filename, false);

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "ls returned status == " << status << endl
                << "buffer == " << buffer << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       temp_strm.str();
       temp_strm << buffer;
       temp_strm.clear();

       memset(buffer, 0, 512);

       temp_strm.getline(buffer, 512);

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "buffer after first getline:  " << buffer << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       memset(buffer, 0, 512);

       temp_strm.getline(buffer, 512);

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "buffer after second getline:  " << buffer << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       errno = 0;
       long int temp_val = strtol(buffer, 0, 10);

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

       if (temp_val == LONG_MAX || temp_val == LONG_MIN)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "ERROR! In `Scan_Parse_Parameter_Type::add_metadata':"
                << endl
                << "`strtol' failed, returning `temp_val' (`LONG_MAX' or `LONG_MIN')." 
                << endl
                << "Failed to read return value of `ils' command."
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           ++errors_occurred;

           temp_strm.str("");

           temp_strm << "ADD METADATA RESPONSE 1 \"" << response.remote_filename << "\" " 
                     << "\"" << response.local_filename << "\" "
                     << "\"Checking for existence of iRODS object " 
                     << "`" << response.local_filename << "' failed.\"";

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "temp_strm.str() == " << temp_strm.str() << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif      /* |DEBUG_COMPILE|  */ 

           new_response.command = temp_strm.str();
  
           response_deque.push_back(new_response);

           ++errors_occurred;

           return 1;
         
       }  /* |if (temp_val == LONG_MAX || temp_val == LONG_MIN)|  */

@q ******** (8) @>

       else if (temp_val != 0)
       {

#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "iRODS object `" << response.local_filename << "' doesn't exist."
                     << endl
                     << "Setting `irods_object_exists' to `false'."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

            irods_object_exists = false;

       }  /* |else if (temp_val != 0)|   */

@q ******** (8) @>
@
\LOG
\initials{LDF 2013.01.11.}
Now sending response with a warning to client.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

       else /* |temp_val == 0|  */
       {
#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "iRODS object `" << response.local_filename << "' exists."
                     << endl
                     << "Setting `irods_object_exists' to `true'."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

            irods_object_exists = true;

            temp_strm.str("");
            temp_strm << "ADD METADATA RESPONSE 3 \"" << response.remote_filename << "\" " 
                 << "\"" << response.local_filename << "\" \"WARNING!  iRODS object exists, "
                 << "but there is no entry for it in the "
                 << "`gwirdsif.Irods_Objects' database table.\"";

#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "temp_strm.str() == " << temp_strm.str() << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

            new_response.command = temp_strm.str();
  
            response_deque.push_back(new_response);


       }  /* |else| (|temp_val == 0|)   */

@q ******** (8) @>

   }  /* |else if (status == 0)|  */

@q ******* (7) iRODS object found in database.  @>

@ iRODS object found in database.  
\initials{LDF 2013.06.06.}

This is what should normally happen.
\initials{LDF 2013.06.06.}

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

   else if (status >= 1)  
   {
       irods_object_exists = true;

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::add_metadata':"
                << endl
                << "`Irods_Object_Type::get_from_database' returned " << status << " (>= 1)."
                << endl
                << "Set `irods_object_exists' to `true'."
                << endl;
           unlock_cerr_mutex(); 
       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */        

   }  /* |else if (status >= 1)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       curr_irods_object.show("curr_irods_object:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>
@
\LOG
\initials{LDF 2012.12.31.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

   if (force_add)  
   {
        /* \.{--force-add}, \.{--force} or \.{--force-all} option used.  
           \initials{LDF 2012.12.31.}  */

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::add_metadata':"
                 << endl 
                 << "`--force-add' option used.  Will add metadata even if iRODS object "
                 << "doesn't exist."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }   /* |if (force_add)|  */

@q ******* (7) @>

   else if (!irods_object_exists) /* |response.metadata_options & 1U == false|  */  
   {
        /* \.{--force-add}, \.{--force} or \.{--force-all} option not used.  
           \initials{LDF 2012.12.31.}  */

       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "ERROR! In `Scan_Parse_Parameter_Type::add_metadata':"
            << endl
            << "iRODS object `" << response.local_filename << "' doesn't exist "
            << "and `--force' option not used."
            << endl
            << "Not adding metadata."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       temp_strm.str("");

       temp_strm << "ADD METADATA RESPONSE 1 \"" << response.remote_filename << "\" " 
                 << "\"" << response.local_filename << "\" "
                 << "\"iRODS object `" << response.local_filename << "' "
                 << "doesn't exist and --force-add option not used.  Metadata " 
                 << "not added.\"";

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       new_response.command = temp_strm.str();
  
       response_deque.push_back(new_response);

       ++errors_occurred;

       return 1;

   }  /* |else if (!irods_object_exists)| (|force_add == false|)  */  

@q ******* (7) @>

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       curr_irods_object.show("curr_irods_object:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    vector<Dublin_Core_Metadata_Type> dc_metadata_vector;

    status = parse_metadata(dc_metadata_vector, response);

    if (status != 0)
    {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::add_metadata':"
            << endl 
            << "`Scan_Parse_Parameter_Type::parse_metadata' failed, returning "
            << status << "."
            << endl 
            << "Failed to parse metadata in file `" << response.temporary_filename << "'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       temp_strm.str("");

       temp_strm << "ADD METADATA RESPONSE 1 \"" << response.remote_filename << "\" " 
                 << "\"" << response.local_filename << "\" \"Failed to parse metadata\"";

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       new_response.command = temp_strm.str();
  
       response_deque.push_back(new_response);

       ++errors_occurred;

       return 1;

    }  /* |if (status != 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]  In `Scan_Parse_Parameter_Type::add_metadata':"
            << endl 
            << "`Scan_Parse_Parameter_Type::parse_metadata' succeeded, returning 0."
            << endl 
            << "Parsed metadata in file `" << response.temporary_filename << "' successfully."
            << endl
            << "`dc_metadata_vector.size()' == " << dc_metadata_vector.size() << endl;
 
#if 0 
       for (vector<Dublin_Core_Metadata_Type>::const_iterator iter 
               = dc_metadata_vector.begin();
            iter != dc_metadata_vector.end();
            ++iter)
       {
           iter->show();
       }
#endif 

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   map<unsigned long int, Dublin_Core_Metadata_Type> existing_metadata_map;

   status = get_metadata( response.local_filename,  /* |filename|               */
                          0,                        /* |flags|                  */
                          0,                        /* |int *ctr|               */
                          0,                        /* |unsigned int options|   */
                          0,                        /* |char *buffer_ptr|       */
                          0,                        /* |size_t buffer_size|     */
                          false,                    /* |do_output|              */
                          false,                    /* |do_irods_user_metadata| */
                          &existing_metadata_map 
                         );

   if (status == 2)
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex();
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::add_metadata':"
                << endl 
                << "`Scan_Parse_Parameter_Type::get_metadata' returned 2:  No existing "
                << "metadata for user " << user_id 
                << " and iRODS object `" << response.local_filename << "' in database."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       existing_metadata_map.clear();  /* Just to be sure.  It should be 
                                          empty in this case.
                                          \initials{LDF 2012.12.21.}  */

   }  /* |if (status == 2)|  */
  
   else if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::add_metadata':"
            << endl 
            << "`Scan_Parse_Parameter_Type::get_metadata' failed, returning "
            << status << "."
            << endl 
            << "Failed to check for existing metadata in database for file "
            << "`" << response.temporary_filename << "'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       temp_strm.str("");

       temp_strm << "ADD METADATA RESPONSE 1 \"" << response.remote_filename << "\" " 
                 << "\"" << response.local_filename << "\" "
                 << "\"Checking for existing metadata failed\"";

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       new_response.command = temp_strm.str();
  
       response_deque.push_back(new_response);

       ++errors_occurred;

       return 1;

   }  /* |else if (status != 0)|  */


#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "existing_metadata_map.size() == " << existing_metadata_map.size() 
            << endl;

#if 0 
       for (vector<Dublin_Core_Metadata_Type>::const_iterator iter
               =  existing_metadata_map.begin();
            iter != existing_metadata_map.end();
            ++iter)
       {
           iter->second.show();
       }

       cerr << endl;
#endif 

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

   bool matched;

   vector<Dublin_Core_Metadata_Type>::iterator iter;
   map<unsigned long int, Dublin_Core_Metadata_Type>::iterator iter_1;

   string curr_pid;

   for (iter = dc_metadata_vector.begin();  /* outer |for|  */
        iter != dc_metadata_vector.end();
        ++iter)
   {
@q ******* (7) @>

       iter->irods_object_ref_id = curr_irods_object.id;

       iter->dc_metadata_irods_object_path = response.remote_filename;

       matched = false;

       for (iter_1 = existing_metadata_map.begin();
            iter_1 != existing_metadata_map.end();
            ++iter_1)
       {
@q ******** (8) @>

            if (*iter == iter_1->second)
            {
#if DEBUG_COMPILE
                if (DEBUG)   
                {
                    lock_cerr_mutex(); 
                    cerr << "In `Scan_Parse_Parameter_Type::add_metadata':"
                         << endl 
                         << "`*iter' == `iter_1->second'.  Matching metadata found in database."
                         << endl
                         << "Breaking out of inner loop."
                         << endl;
                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

                matched = true;
                break;              

            }  /* |if|  */


@q ******** (8) @>

       }  /* inner |for|  */

       if (matched)
       {
#if DEBUG_COMPILE
                if (DEBUG)   
                {
                    lock_cerr_mutex(); 
                    cerr << "In `Scan_Parse_Parameter_Type::add_metadata':"
                         << endl 
                         << "In outer loop:  Matching metadata found in database."
                         << endl
                         << "Not calling "
                         << "`Dublin_Core_Metadata_Type::write_dc_metadata_to_database'."
                         << endl
                         << "Continuing."
                         << endl;
                    unlock_cerr_mutex(); 


                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           continue;

       }  /* |if (matched)|  */

@q ******* (7) @>

       else /* |matched == false|  */
       {

#if DEBUG_COMPILE
           if (DEBUG)   
           {
               lock_cerr_mutex(); 
               cerr << "In outer loop:  No matching metadata found in database."
                    << endl
                    << "Will call `Dublin_Core_Metadata_Type::write_dc_metadata_to_database'."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=          

           status = iter->write_dc_metadata_to_database(mysql_ptr, curr_irods_object.id);

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=          

           if (status != 0)  
           {
@q ********* (9) @>

               /* |Dublin_Core_Metadata_Type::write_dc_metadata_to_database| failed  */

               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] ERROR!  "
                    << "In `Scan_Parse_Parameter_Type::add_metadata':"
                    << endl 
                    << "`Dublin_Core_Metadata_Type::write_dc_metadata_to_database' "
                    << "failed, returning "
                    << status << "."
                    << endl 
                    << "Failed to write XML metadata to database for file "
                    << "`" << response.temporary_filename << "'."
                    << endl 
                    << "Will try to continue."
                    << endl;
               unlock_cerr_mutex(); 

               ++errors_occurred;

               temp_strm.str("");

               temp_strm << "ADD METADATA RESPONSE 1 \"" << response.remote_filename << "\" " 
                           << "\"" << response.local_filename << "\" "
                           << "\"Failed to write metadata to database\"";

#if DEBUG_COMPILE
               if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << "temp_strm.str() == " << temp_strm.str() << endl;
                   unlock_cerr_mutex(); 

               }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

               new_response.command = temp_strm.str();
  
               response_deque.push_back(new_response);

               continue;

           }  /* |if (status != 0)|  
                 (|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| failed)  */

@q ******** (8) @>

           else  /* |Dublin_Core_Metadata_Type::write_dc_metadata_to_database| succeeded  */
           {
@q ********* (9) @>

               ++items_written;

#if DEBUG_COMPILE
               if (DEBUG)  
               {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr << "] "
                        << "In `Scan_Parse_Parameter_Type::add_metadata':"
                        << endl 
                        << "`Dublin_Core_Metadata_Type::write_dc_metadata_to_database' succeeded, "
                        << "returning 0."
                        << endl 
                        << "Wrote XML metadata to database for file "
                        << "`" << response.temporary_filename << "' successfully."
                        << endl;
                   unlock_cerr_mutex(); 

               }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

               curr_pid = "";

               status = generate_pids(mysql_ptr, 
                                      default_handle_prefix, 
                                      curr_pid,
                                      0,      /* PID vector pointer (|vector<string> *|) */
                                      1,      /* Number of PIDS  */
                                      0,      /* Handle ID vector pointer */
                                      0,      /* Handle value ID vector pointer */
                                      true,   /* standalone handle server  */
                                      "",     /* Institute string  */
                                      "",     /* Suffix string  */
                                      &handle_vector,
                                      "", /* |fifo_pathname|  */
                                      user_id,
                                      username);

               if (status != 0)
               {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr << "] ERROR!  "
                        << "In `Scan_Parse_Parameter_Type::add_metadata':"
                        << endl 
                        << "`generate_pids' failed, returning "
                        << status << "."
                        << endl 
                        << "Failed to generate PID."
                        << endl 
                        << "Will try to continue."
                        << endl;
                   unlock_cerr_mutex(); 

                   ++errors_occurred;

                   continue;


               }  /* |if (status != 0)|  */


@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

               else  /* |status == 0|  */
               {
#if DEBUG_COMPILE
                   if (DEBUG)      
                   {
                       lock_cerr_mutex(); 
                       cerr << "[Thread " << thread_ctr << "] "
                            << "In `Scan_Parse_Parameter_Type::add_metadata':"
                            << endl 
                            << "`generate_pids' succeeded, returning 0:"
                            << endl
                            << "`curr_pid' == " << curr_pid 
                            << endl;

                        if (handle_vector.size() != 0)
                        {
                             cerr << "Showing `handle_vector.back()':" << endl;

                             handle_vector.back().show("*handle_value.back():");

                        }  /* |if|  */
                        unlock_cerr_mutex(); 

                   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

               temp_strm.str("");

               temp_strm << "ADD METADATA RESPONSE 0 \"" << response.remote_filename << "\" " 
                           << "\"" << response.local_filename << "\" "
                           << "\"Generated handle for metadata:  " << curr_pid << ".\"";

               new_response.command = temp_strm.str();
  
               response_deque.push_back(new_response);

               }  /* |else| (|status == 0|)  */

@q ********* (9) @>
@
\LOG
\initials{LDF 2013.02.28.}
Added this section.
\ENDLOG
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=
       
               status = iter->set_handle_id(mysql_ptr, handle_vector.back().handle_id);

               if (status != 0)
               {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr << "] ERROR!  "
                        << "In `Scan_Parse_Parameter_Type::add_metadata':"
                        << endl 
                        << "`Dublin_Core_Metadata_Type::set_handle_id' failed, returning "
                        << status << "."
                        << endl 
                        << "Failed to update IDs in `Dublin_Core_Metadata_Type' object."
                        << endl 
                        << "Will try to continue."
                        << endl;
                   unlock_cerr_mutex(); 

                   ++errors_occurred;

                   continue;

               }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
               else if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr << "] "
                        << "In `Scan_Parse_Parameter_Type::add_metadata':"
                        << endl 
                        << "`Dublin_Core_Metadata_Type::set_handle_id' succeeded, returning 0."
                        << endl;
                   unlock_cerr_mutex(); 

               }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

           }  /* |else| (|Dublin_Core_Metadata_Type::write_dc_metadata_to_database| succeeded) */

@q ******** (8) @>

       }   /* |else| (|matched == false|)  */

@q ******* (7) @>

   }  /* Outer |for|  */

@q ****** (6)  Get handles for |curr_irods_object|.  @>

@ Get handles for |curr_irods_object|.  
\initials{LDF 2013.02.08.}

\initials{LDF 2013.03.01.}
@:TODO@> !! TODO: If there was no |Irods_Object_Type| object, but there was an iRODS object,
I'll have to use `imeta' to get its PID.

\LOG
\initials{LDF 2013.02.08.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=


   if (curr_irods_object.handle_id_vector.size() > 0)
   {
@q ******* (7) @>

       status = fetch_handles_from_database(curr_irods_object.handle_id_vector, 
                                            irods_object_handle_vector,
                                            "IRODS_OBJECT");


       if (status != 0)
       {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] ERROR!  "
                 << "In `Scan_Parse_Parameter_Type::add_metadata':"
                 << endl 
                 << "`fetch_handles_from_database' failed, returning "
                 << status << "."
                 << endl 
                 << "Failed to fetch handles for iRODS object `" << curr_irods_object.path << "' "
                 << "from `handlesystem_standalone.handles' database."
                 << endl 
                 << "Will try to continue."
                 << endl;
            unlock_cerr_mutex(); 

            ++errors_occurred;

            temp_strm.str("");

            temp_strm << "ADD METADATA RESPONSE 1 \"" << response.remote_filename << "\" " 
                        << "\"" << response.local_filename << "\" "
                        << "\"Failed to fetch handles for iRODS object "
                        << "`" << curr_irods_object.path << "'\"";

            new_response.command = temp_strm.str();
  
            response_deque.push_back(new_response);
        
       }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::add_metadata':"
                << endl 
                << "`fetch_handles_from_database' succeeded, returning 0."
                << endl
                << "`irods_object_handle_vector.size()' == " 
                << irods_object_handle_vector.size()
                << endl;

           if (irods_object_handle_vector.size() > 0)
           {
               for (vector<Handle_Type>::const_iterator iter 
                       = irods_object_handle_vector.begin();
                    iter != irods_object_handle_vector.end();
                    ++iter)
                {

                     iter->show();

                }  /* |for|  */
 
                cerr << endl;

           }  /* |if (irods_object_handle_vector.size() > 0)|  */

           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

   }  /* |if (curr_irods_object.handle_id_vector.size() > 0)|  */


@q ****** (6)  Add handle values to the handles for the metadata.   @>

@ Add handle values to the handles for the metadata.  
\initials{LDF 2013.01.11.}

\LOG
\initials{LDF 2013.01.11.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

   for (vector<Handle_Type>::iterator iter = handle_vector.begin();
        iter != handle_vector.end();
        ++iter)
   {
@q ******* (7) @>

        temp_strm.str("");
        temp_strm << "Qualified Dublin Core XML Metadata for iRODS object " 
                  << response.local_filename << ".";

        status = iter->add_value(mysql_ptr, 
                                 Handle_Value_Type::DC_METADATA_INDEX, 
                                 "DC_METADATA", 
                                 temp_strm.str(),
                                 user_id);

@q ******* (7) @>

        if (status != 0)
        {
                   lock_cerr_mutex(); 
                   cerr << "[Thread " << thread_ctr << "] ERROR!  "
                        << "In `Scan_Parse_Parameter_Type::add_metadata':"
                        << endl 
                        << "`Handle_Value_Type::add_value' failed, returning "
                        << status << "."
                        << endl 
                        << "Failed to add handle value for handle " 
                        << iter->handle << "."
                        << endl 
                        << "Will try to continue."
                        << endl;
                   unlock_cerr_mutex(); 

                   ++errors_occurred;

                   continue;


        }  /* |if (status != 0)|  */

@q ******* (7) @>

#if DEBUG_COMPILE
        else if (DEBUG)
        {
             lock_cerr_mutex(); 
             cerr << "[Thread " << thread_ctr << "] "
                  << "In `Scan_Parse_Parameter_Type::add_metadata':"
                  << endl 
                  << "`Handle_Value_Type::add_value' succeeded, returning 0."
                  << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>
@

@:TODO@> !! TODO: 
If there's no |Irods_Object_Type| object, then I could 
try to get the PID using `imeta' after calling `ils'.  
This shouldn't be necessary but would be good as a backup.
\par
\.{ils} is not currently called in |Irods_Object_Type::get_from_database|.
I could implement this an call `imeta' there to try to extract the PIDs.  
I should then check to see if they exist.
\par
Or perhaps I should just check the `handlesystem\_standalone' database in
the first place.  Or maybe both and synchronize it with the iRODS user metadata, 
if necessary.
\initials{LDF 2013.03.01.}

\LOG
\initials{LDF 2013.01.31.}
Added this section.
\ENDLOG
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

@q ******* (7) @>
@
\LOG
\initials{LDF 2013.02.08.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=


       if (irods_object_handle_vector.size() == 0)
       {
@q ******** (8) @>

            status = iter->add_value(mysql_ptr, 
                                     Handle_Value_Type::IRODS_OBJECT_REF_INDEX, 
                                     "IRODS_OBJECT_REF",
                                     response.local_filename,
                                     user_id);

            if (status != 0)
            {
                       lock_cerr_mutex(); 
                       cerr << "[Thread " << thread_ctr << "] ERROR!  "
                            << "In `Scan_Parse_Parameter_Type::add_metadata':"
                            << endl 
                            << "`Handle_Value_Type::add_value' failed, returning "
                            << status << "."
                            << endl 
                            << "Failed to add handle value for (non-existent) " 
                            << "iRODS object `" << response.local_filename << "' "
                            << "with type `IRODS_OBJECT' to handle "
                            << "`" << iter->handle << "'."
                            << endl 
                            << "Will try to continue."
                            << endl;
                       unlock_cerr_mutex(); 

                       ++errors_occurred;

                       temp_strm.str("");

                       temp_strm << "ADD METADATA RESPONSE 2 "
                                 << "\"" << response.remote_filename << "\" " 
                                 << "\"" << response.local_filename << "\" "
                                 << "\"Failed to add handle value for (non-existent) " 
                                 << "iRODS object `" << response.local_filename << "' "
                                 << "with type `IRODS_OBJECT' to handle "
                                 << "`" << iter->handle << "'.\"";

                       new_response.command = temp_strm.str();
  
                       response_deque.push_back(new_response);

            }  /* |if (status != 0)|  */

@q ******** (8) @>

            else 
            {

#if DEBUG_COMPILE
                  if (DEBUG)
                  {
                       lock_cerr_mutex(); 
                       cerr << "[Thread " << thread_ctr << "] "
                            << "In `Scan_Parse_Parameter_Type::add_metadata':"
                            << endl 
                            << "`Handle_Value_Type::add_value' succeeded, returning 0."
                            << endl 
                            << "Added handle value for (non-existent) " 
                            << "iRODS object `" << response.local_filename << "' "
                            << "with type `IRODS_OBJECT' to handle "
                            << "`" << iter->handle << "' successfully."
                            << endl;
                       unlock_cerr_mutex(); 
                  }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


                  temp_strm.str("");

                  temp_strm << "ADD METADATA RESPONSE 0 \"" << response.remote_filename << "\" " 
                            << "\"" << response.local_filename << "\" "
                            << "\"Added handle value for (non-existent) " 
                            << "iRODS object `" << response.local_filename << "' "
                            << "with type `IRODS_OBJECT' to handle "
                            << "`" << iter->handle << "' successfully.\"";

                  new_response.command = temp_strm.str();
  
                  response_deque.push_back(new_response);

            }  /* |else|  */

@q ******** (8) @>

       }  /* |if (irods_object_handle_vector.size() == 0)|  */

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=


        for (vector<Handle_Type>::iterator iter_2
                = irods_object_handle_vector.begin();
             iter_2 != irods_object_handle_vector.end();
             ++iter_2)
        {
@q ******** (8) @>

             status = iter->add_value(mysql_ptr, 
                                      Handle_Value_Type::IRODS_OBJECT_PID_INDEX, 
                                     "IRODS_OBJECT_PID", 
                                      iter_2->handle,
                                      user_id);

             if (status != 0)
             {
                        lock_cerr_mutex(); 
                        cerr << "[Thread " << thread_ctr << "] ERROR!  "
                             << "In `Scan_Parse_Parameter_Type::add_metadata':"
                             << endl 
                             << "`Handle_Value_Type::add_value' failed, returning "
                             << status << "."
                             << endl 
                             << "Failed to add handle value for handle " 
                             << iter_2->handle << " with type `IRODS_OBJECT_PID' to handle "
                             << "`" << iter->handle << "'."
                             << endl 
                             << "Will try to continue."
                             << endl;
                        unlock_cerr_mutex(); 

                        ++errors_occurred;

                        temp_strm.str("");

                        temp_strm << "ADD METADATA RESPONSE 2 "
                                  << "\"" << response.remote_filename << "\" " 
                                  << "\"" << response.local_filename << "\" "
                                  << "\"Failed to add handle value for handle "
                                  << "`" << iter_2->handle << "' "
                                  << "with type `IRODS_OBJECT_PID' to handle "
                                  << "`" << iter->handle << "'\"";

                        new_response.command = temp_strm.str();
  
                        response_deque.push_back(new_response);


             }  /* |if (status != 0)|  */

@q ******** (8) @>

             else 
             {

#if DEBUG_COMPILE
                  if (DEBUG)
                  {
                       lock_cerr_mutex(); 
                       cerr << "[Thread " << thread_ctr << "] "
                            << "In `Scan_Parse_Parameter_Type::add_metadata':"
                            << endl 
                            << "`Handle_Value_Type::add_value' succeeded, returning 0."
                            << endl 
                            << "Added handle value for handle " 
                            << "`" << iter_2->handle << "' with type `IRODS_OBJECT_PID' to handle "
                            << "`" << iter->handle << "' successfully."
                            << endl;
                       unlock_cerr_mutex(); 
                  }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


                  temp_strm.str("");

                  temp_strm << "ADD METADATA RESPONSE 0 \"" << response.remote_filename << "\" " 
                              << "\"" << response.local_filename << "\" "
                              << "\"Added handle value for handle `" << iter_2->handle << "' "
                              << "with type `IRODS_OBJECT_PID' to handle "
                            << "`" << iter->handle << "' successfully\"";

                  new_response.command = temp_strm.str();
  
                  response_deque.push_back(new_response);

             }  /* |else|  */

@q ******** (8) Cross-reference with |type == "IRODS_OBJECT_REF"|.  @>

@ Cross-reference with |type == "IRODS_OBJECT_REF"|.  
\initials{LDF 2013.02.08.}

\LOG
\initials{LDF 2013.02.08.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

             status = iter->add_value(mysql_ptr, 
                                      Handle_Value_Type::IRODS_OBJECT_REF_INDEX, 
                                      "IRODS_OBJECT_REF", 
                                      curr_irods_object.path,
                                      user_id);

             if (status != 0)
             {
                        lock_cerr_mutex(); 
                        cerr << "[Thread " << thread_ctr << "] ERROR!  "
                             << "In `Scan_Parse_Parameter_Type::add_metadata':"
                             << endl 
                             << "`Handle_Value_Type::add_value' failed, returning "
                             << status << "."
                             << endl 
                             << "Failed to add handle value for iRODS object " 
                             << "`" << curr_irods_object.path << "' with type `IRODS_OBJECT_REF' "
                             << "to handle `" << iter->handle << "'."
                             << endl 
                             << "Will try to continue."
                             << endl;
                        unlock_cerr_mutex(); 

                        ++errors_occurred;

                        temp_strm.str("");

                        temp_strm << "ADD METADATA RESPONSE 2 "
                                  << "\"" << response.remote_filename << "\" " 
                                  << "\"" << response.local_filename << "\" "
                                  << "\"Failed to add handle value for iRODS object " 
                                  << "`" << curr_irods_object.path << "' "
                                  << "with type `IRODS_OBJECT_REF' to handle "
                                  << "`" << iter->handle << "'\"";

                        new_response.command = temp_strm.str();
  
                        response_deque.push_back(new_response);


             }  /* |if (status != 0)|  */

@q ******** (8) @>

             else 
             {

#if DEBUG_COMPILE
                  if (DEBUG)
                  {
                       lock_cerr_mutex(); 
                       cerr << "[Thread " << thread_ctr << "] "
                            << "In `Scan_Parse_Parameter_Type::add_metadata':"
                            << endl 
                            << "`Handle_Value_Type::add_value' succeeded, returning 0."
                            << endl 
                            << "Added handle value for iRODS object " 
                            << "`" << curr_irods_object.path << "' "
                            << "with type `IRODS_OBJECT_REF' to handle "
                            << "`" << iter->handle << "' successfully."
                            << endl;
                       unlock_cerr_mutex(); 
                  }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


                  temp_strm.str("");

                  temp_strm << "ADD METADATA RESPONSE 0 \"" << response.remote_filename << "\" " 
                            << "\"" << response.local_filename << "\" "
                            << "\"Added handle value for iRODS object " 
                            << "`" << curr_irods_object.path << "' "
                            << "with type `IRODS_OBJECT_REF' to handle "
                            << "`" << iter->handle << "' successfully\"";

                  new_response.command = temp_strm.str();
  
                  response_deque.push_back(new_response);

             }  /* |else|  */


@q ******** (8) @>
@
\LOG
\initials{LDF 2013.02.08.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

             status = iter_2->add_value(mysql_ptr, 
                                       Handle_Value_Type::DC_METADATA_PID_INDEX, 
                                       "DC_METADATA_PID", 
                                       iter->handle,
                                       user_id);

             if (status != 0)
             {
                  lock_cerr_mutex(); 
                  cerr << "[Thread " << thread_ctr << "] ERROR!  "
                       << "In `Scan_Parse_Parameter_Type::add_metadata':"
                       << endl 
                       << "`Handle_Value_Type::add_value' failed, returning "
                       << status << "."
                       << endl 
                       << "Failed to add handle value for handle " 
                       << iter->handle << " with type `DC_METADATA_PID' to handle "
                       << "`" << iter_2->handle << "'."
                       << endl 
                       << "Will try to continue."
                       << endl;
                  unlock_cerr_mutex(); 

                  ++errors_occurred;

                  temp_strm.str("");

                  temp_strm << "ADD METADATA RESPONSE 1 \"" << response.remote_filename << "\" " 
                              << "\"" << response.local_filename << "\" "
                              << "\"Failed to add handle value for handle "
                              << "`" << iter->handle << "' "
                              << "with type `DC_METADATA_PID' to handle "
                            << "`" << iter_2->handle << "'\"";

                  new_response.command = temp_strm.str();
  
                  response_deque.push_back(new_response);


             }  /* |if (status != 0)|  */

@q ******** (8) @>

             else 
             {

#if DEBUG_COMPILE
                  if (DEBUG)
                  {
                       lock_cerr_mutex(); 
                       cerr << "[Thread " << thread_ctr << "] "
                            << "In `Scan_Parse_Parameter_Type::add_metadata':"
                            << endl 
                            << "`Handle_Value_Type::add_value' succeeded, returning 0."
                            << endl 
                            << "Added handle value for handle " 
                            << "`" << iter->handle << "' with type `IRODS_OBJECT_PID' to handle "
                            << "`" << iter_2->handle << "' successfully."
                            << endl;
                       unlock_cerr_mutex(); 
                  }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


                  temp_strm.str("");

                  temp_strm << "ADD METADATA RESPONSE 0 \"" << response.remote_filename << "\" " 
                              << "\"" << response.local_filename << "\" "
                              << "\"Added handle value for handle `" << iter->handle << "' "
                              << "with type `DC_METADATA_PID' to handle "
                            << "`" << iter_2->handle << "' successfully\"";

                  new_response.command = temp_strm.str();
  
                  response_deque.push_back(new_response);

             }  /* |else|  */

@q ******** (8) @>
@
\LOG
\initials{LDF 2013.02.08.}
Added this section.

\initials{LDF 2013.06.06.}
@:BUG FIX@> BUG FIX:  Now calling \.{imeta rm} to remove the AVU, if it already exists.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=
 
              temp_strm.str("");

              temp_strm << "env irodsEnvFile=" << irods_env_filename
                        << " imeta rm -d \"" << curr_irods_object.path
                        << "\" DC_METADATA_PID \"" << iter->handle << "\" >/dev/null 2>&1; "
                        << "env irodsEnvFile=" << irods_env_filename
                        << " imeta add -d \"" << curr_irods_object.path
                        << "\" DC_METADATA_PID \"" << iter->handle << "\"";

#if DEBUG_COMPILE
              if (DEBUG) 
              {
                  lock_cerr_mutex(); 
                  cerr << "temp_strm.str() == " << temp_strm.str() << endl;
                  unlock_cerr_mutex(); 

              }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

              status = system(temp_strm.str().c_str());

              if (status == -1 || !WIFEXITED(status))
              {
                  lock_cerr_mutex(); 
                  cerr << "[Thread " << thread_ctr << "] "
                       << "ERROR!  In `Scan_Parse_Parameter_Type::add_metadata':  "
                       << "`system' failed, returning " << status << "."
                       << endl;

                  if (WIFEXITED(status))
                     cerr << "WEXITSTATUS(status) == " << WEXITSTATUS(status) 
                          << endl;
                  else
                     cerr << "Process failed to exit."
                          << endl;
                  unlock_cerr_mutex(); 

                  ++errors_occurred;

                  temp_strm.str("");

                  temp_strm << "ADD METADATA RESPONSE 1 \"" << response.remote_filename << "\" " 
                              << "\"" << response.local_filename << "\" "
                              << "\"Call to `imeta' failed to exit.  Failed to add AVU "
                              << "with type `DC_METADATA_PID' and value "
                              << "`" << iter->handle << "' to iRODS object "
                              << "`" << curr_irods_object.path << "'.\"";


                  new_response.command = temp_strm.str();
  
                  response_deque.push_back(new_response);


              }   /* |(status == -1 || !WIFEXITED(status))|  */

@q ******** (8) @>

              else if (WEXITSTATUS(status) != 0)
              {
                  lock_cerr_mutex(); 
                  cerr << "[Thread " << thread_ctr << "] "
                       << "ERROR!  In `Scan_Parse_Parameter_Type::add_metadata':  "
                       << "`imeta' command (called via `system') failed, "
                       << "returning " << WEXITSTATUS(status) << "."
                       << endl;
                  unlock_cerr_mutex(); 


                  ++errors_occurred;

                  temp_strm.str("");

                  temp_strm << "ADD METADATA RESPONSE 1 \"" << response.remote_filename << "\" " 
                              << "\"" << response.local_filename << "\" "
                              << "\"Call to `imeta' failed with exit status "
                              << WEXITSTATUS(status) << ".  Failed to add AVU "
                              << "with type `DC_METADATA_PID' and value "
                              << "`" << iter->handle << "' to iRODS object "
                              << "`" << curr_irods_object.path << "'.\"";


                  new_response.command = temp_strm.str();
  
                  response_deque.push_back(new_response);


              }  /* |else if (WEXITSTATUS(status) != 0)|  */

@q ******** (8) @>


              else  /* \.{imeta} command succeeded.  */
              {
@q ********* (9) @>

#if DEBUG_COMPILE 
                  if (DEBUG)  
                  {
                      lock_cerr_mutex(); 
                      cerr << "[Thread " << thread_ctr << "] "
                           << "In `Scan_Parse_Parameter_Type::add_metadata':  "
                           << "`system' succeeded `WEXITSTATUS(status)' == " 
                           << WEXITSTATUS(status) << "." << endl;
                      unlock_cerr_mutex(); 
                   
                  }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

                  temp_strm.str("");

                  temp_strm << "ADD METADATA RESPONSE 0 \"" << response.remote_filename << "\" " 
                              << "\"" << response.local_filename << "\" "
                              << "\"Call to `imeta' succeeded.  "
                              << "Added AVU "
                              << "with type `DC_METADATA_PID' and value "
                              << "`" << iter->handle << "' to iRODS object "
                              << "`" << curr_irods_object.path << "'.\"";

                  new_response.command = temp_strm.str();
  
                  response_deque.push_back(new_response);


                  curr_avu.clear();
                  curr_avu.set("DC_METADATA_PID", iter->handle);
                  curr_avu.irods_object_id = curr_irods_object.id;

                  curr_irods_object.avu_vector.push_back(curr_avu);

#if DEBUG_COMPILE
                  if (DEBUG)
                  {
                      lock_cerr_mutex(); 
                      curr_irods_object.show("curr_irods_object:");
                      unlock_cerr_mutex(); 

                  }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ********* (9) @>

                  status = curr_avu.write_to_database(mysql_ptr, thread_ctr);  

                  if (status != 0)
                  {
                      lock_cerr_mutex(); 
                      cerr << "[Thread " << thread_ctr << "] "
                           << "ERROR!  In `Scan_Parse_Parameter_Type::add_metadata':  "
                           << "`Irods_AVU_Type::write_to_database' failed, returning " 
                           << status << "."
                           << endl;
                      unlock_cerr_mutex(); 

                      ++errors_occurred;

                      temp_strm.str("");

                      temp_strm << "ADD METADATA RESPONSE 1 \"" 
                                << response.remote_filename << "\" " 
                                << "\"" << response.local_filename << "\" "
                                << "\"Call to `Irods_AVU_Type::write_to_database', returning "
                                << status << "\"";

                      new_response.command = temp_strm.str();
  
                      response_deque.push_back(new_response);

                      temp_strm.str("");

                  }  /* |if (status != 0)|  */

@q ********* (9) @>

#if DEBUG_COMPILE
                  else if (DEBUG)
                  {
                      lock_cerr_mutex(); 
                      cerr << "[Thread " << thread_ctr << "] "
                           << "In `Scan_Parse_Parameter_Type::add_metadata':  "
                           << "`Irods_AVU_Type::write_to_database' succeeded, returning 0." 
                           << endl;
                      unlock_cerr_mutex(); 

                  }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

                  curr_avu.clear();

@q ********* (9) @>

              }  /* |else| (\.{imeta} command succeeded.)  */

@q ******** (8) @>

        }  /* inner |for|  */

@q ******* (7) @>

   }  /* outer |for|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

   if (store)
   {
@q ******* (7) @>

        if (!items_written)
        {
@q ******** (8) @>

             lock_cerr_mutex(); 
             cerr << "[Thread " << thread_ctr << "] WARNING!  "
                  << "In `Scan_Parse_Parameter_Type::add_metadata':"
                  << endl 
                  << "`--store' option used but `items_written' == `false'."
                  << endl
                  << "Not storing metadata file in iRODS object.  Continuing."
                  << endl;
             unlock_cerr_mutex(); 

             temp_strm.str("");

             temp_strm << "ADD METADATA RESPONSE 4 \"" << response.remote_filename << "\" " 
                       << "\"" << response.local_filename << "\" \"--store option used "
                       << "but no XML metadata written to database.  Not storing XML file "
                       << "in an iRODS object.\"";

#if DEBUG_COMPILE
             if (DEBUG)
             {
                 lock_cerr_mutex(); 
                 cerr << "temp_strm.str() == " << temp_strm.str() << endl;
                 unlock_cerr_mutex(); 

             }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */ 

             new_response.command = temp_strm.str();
  
             response_deque.push_back(new_response);

@q ******** (8) @>

        }  /* |if (!items_written)|  */

@q ******* (7) @>             

        else /* |items_written == true|  */
        {
@q ******** (8) @>

#if DEBUG_COMPILE
            if (DEBUG)
            {
                lock_cerr_mutex(); 
                cerr << "[Thread " << thread_ctr << "] "
                     << "In `Scan_Parse_Parameter_Type::add_metadata':"
                     << endl 
                     << "`--store' option used and `items_written' == `true'."
                     << endl
                     << "Will store metadata file in iRODS object."
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

            if (   irods_object_handle_vector.size() == 0
                || handle_vector.size() == 0)
            {
                 lock_cerr_mutex(); 
                 cerr << "[Thread " << thread_ctr << "] WARNING!  "
                      << "In `Scan_Parse_Parameter_Type::add_metadata':"
                      << endl 
                      << "`irods_object_handle_vector.size()' == 0 and/or "
                      << "`handle_vector.size()' == 0."
                      << endl 
                      << "Two PIDs required for passing to "
                      << "`Scan_Parse_Parameter_Type::store_dc_metadata':"
                      << endl 
                      << "At least one is missing."
                      << endl 
                      << "Not calling `Scan_Parse_Parameter_Type::store_dc_metadata'."
                      << endl
                      << "Continuing."
                      << endl;
                 unlock_cerr_mutex(); 

                 temp_strm.str("");

                 temp_strm << "ADD METADATA RESPONSE 5 \"" << response.remote_filename << "\" " 
                           << "\"" << response.local_filename << "\" \"Failed to store "
                           << "Dublin Core metadata in iRODS object.\"";

#if DEBUG_COMPILE
                 if (DEBUG)
                 {
                     lock_cerr_mutex(); 
                     cerr << "temp_strm.str() == " << temp_strm.str() << endl;
                     unlock_cerr_mutex(); 

                 }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */ 

                 ++warnings_occurred;

                 new_response.command = temp_strm.str();
  
                 response_deque.push_back(new_response);

            }  /* |if|  */


@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

            else if (   irods_object_handle_vector.back().handle.empty()
                     || handle_vector.back().handle.empty())
            {
                 lock_cerr_mutex(); 
                 cerr << "[Thread " << thread_ctr << "] WARNING!  "
                      << "In `Scan_Parse_Parameter_Type::add_metadata':"
                      << endl 
                      << "`irods_object_handle_vector.back().handle' and/or "
                      << "`handle_vector.back().handle' is empty."
                      << endl 
                      << "Two PIDs required in `Scan_Parse_Parameter_Type::store_dc_metadata':"
                      << endl 
                      << "At least one is missing."
                      << endl 
                      << "Not calling `Scan_Parse_Parameter_Type::store_dc_metadata'."
                      << endl
                      << "Continuing."
                      << endl;
                 unlock_cerr_mutex(); 

                 temp_strm.str("");

                 temp_strm << "ADD METADATA RESPONSE 5 \"" << response.remote_filename << "\" " 
                           << "\"" << response.local_filename << "\" \"Failed to store "
                           << "Dublin Core metadata in iRODS object.\"";

#if DEBUG_COMPILE
                 if (DEBUG)
                 {
                     lock_cerr_mutex(); 
                     cerr << "temp_strm.str() == " << temp_strm.str() << endl;
                     unlock_cerr_mutex(); 

                 }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */ 

                 ++warnings_occurred;

                 new_response.command = temp_strm.str();
  
                 response_deque.push_back(new_response);

            }  /* |else if|  */


@q ******** (8) @>
@
\LOG
\initials{LDF 2013.03.07.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

            else if (   irods_object_handle_vector.back().handle_id == 0
                     || handle_vector.back().handle_id == 0)
            {
                 lock_cerr_mutex(); 
                 cerr << "[Thread " << thread_ctr << "] WARNING!  "
                      << "In `Scan_Parse_Parameter_Type::add_metadata':"
                      << endl 
                      << "`irods_object_handle_vector.back().handle_id' == 0 and/or "
                      << "`handle_vector.back().handle_id' == 0."
                      << endl 
                      << "Two handle IDs required in "
                      << "`Scan_Parse_Parameter_Type::store_dc_metadata':"
                      << endl 
                      << "At least one is missing."
                      << endl 
                      << "Not calling `Scan_Parse_Parameter_Type::store_dc_metadata'."
                      << endl
                      << "Continuing."
                      << endl;
                 unlock_cerr_mutex(); 

                 temp_strm.str("");

                 temp_strm << "ADD METADATA RESPONSE 5 \"" << response.remote_filename << "\" " 
                           << "\"" << response.local_filename << "\" \"Failed to store "
                           << "Dublin Core metadata in iRODS object.\"";

#if DEBUG_COMPILE
                 if (DEBUG)
                 {
                     lock_cerr_mutex(); 
                     cerr << "temp_strm.str() == " << temp_strm.str() << endl;
                     unlock_cerr_mutex(); 

                 }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */ 

                 ++warnings_occurred;

                 new_response.command = temp_strm.str();
  
                 response_deque.push_back(new_response);

            }  /* |else if|  */

           
@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

            else
            {
@q ********* (9) @>

#if DEBUG_COMPILE
                if (DEBUG)   
                {
                    lock_cerr_mutex(); 
                    cerr << "`irods_object_handle_vector.back().handle' == "
                         << "`" << irods_object_handle_vector.back().handle << "'"
                         << endl 
                         << "`handle_vector.back().handle' == " 
                         << "`" << handle_vector.back().handle << "'."
                         << endl;
                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********* (9) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

#if DEBUG_COMPILE
                if (DEBUG)
                {
                    lock_cerr_mutex(); 
                    curr_irods_object.show("curr_irods_object:");
                    response.show("response:");
                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

                status = store_dc_metadata(response, 
                                           irods_object_handle_vector.back(),
                                           handle_vector.back(),
                                           force_store,
                                           irods_object_path,
                                           dc_metadata_vector.front().id,
                                           curr_irods_object.id);


                if (status == 2)
                {
                     lock_cerr_mutex(); 
                     cerr << "[Thread " << thread_ctr << "] WARNING!  "
                          << "In `Scan_Parse_Parameter_Type::add_metadata':"
                          << endl 
                          << "`Scan_Parse_Parameter_Type::store_dc_metadata' returned 2:"
                          << endl
                          << "An iRODS object for `" << response.remote_filename << "' "
                          << "already exists"
                          << endl 
                          << "and the `--force-store' option was not used."
                          << endl 
                          << "Continuing."
                          << endl;
                     unlock_cerr_mutex(); 

                     temp_strm.str("");

                     temp_strm << "ADD METADATA RESPONSE 5 "
                               << "\"" << response.remote_filename << "\" " 
                               << "\"" << response.local_filename << "\" \"iRODS object "
                               << "already exists for Dublin Core metadata "
                               << "and `--force-store' option not used.\"";

#if DEBUG_COMPILE
                     if (DEBUG)
                     {
                         lock_cerr_mutex(); 
                         cerr << "temp_strm.str() == " << temp_strm.str() << endl;
                         unlock_cerr_mutex(); 

                     }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */ 

                     ++warnings_occurred;

                     new_response.command = temp_strm.str();
  
                     response_deque.push_back(new_response);

                }  /* |else if (status != 0)|  */

@q ********* (9) @>

                else if (status != 0)
                {
                     lock_cerr_mutex(); 
                     cerr << "[Thread " << thread_ctr << "] WARNING!  "
                          << "In `Scan_Parse_Parameter_Type::add_metadata':"
                          << endl 
                          << "`Scan_Parse_Parameter_Type::store_dc_metadata' failed, "
                          << "returning " << status << "."
                          << endl
                          << "Failed to store Dublin Core metadata in iRODS object.  "
                          << "Continuing."
                          << endl;
                     unlock_cerr_mutex(); 

                     temp_strm.str("");

                     temp_strm << "ADD METADATA RESPONSE 5 "
                               << "\"" << response.remote_filename << "\" " 
                               << "\"" << response.local_filename << "\" \"Failed to store "
                               << "Dublin Core metadata in iRODS object.\"";

#if DEBUG_COMPILE
                     if (DEBUG)
                     {
                         lock_cerr_mutex(); 
                         cerr << "temp_strm.str() == " << temp_strm.str() << endl;
                         unlock_cerr_mutex(); 

                     }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */ 

                     ++warnings_occurred;

                     new_response.command = temp_strm.str();
  
                     response_deque.push_back(new_response);

                }  /* |else if (status != 0)|  */

@q ********* (9) @>

@ |Scan_Parse_Parameter_Type::store_dc_metadata| succeeded.
\initials{LDF 2013.11.27.}

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

                else   /* |status == 0| */
                {   
@q ********** (10) @>

#if DEBUG_COMPILE
                    if (DEBUG)   
                    {
                        lock_cerr_mutex(); 
                        cerr << "[Thread " << thread_ctr << "] "
                              << "In `Scan_Parse_Parameter_Type::add_metadata':"
                              << endl 
                              << "`Scan_Parse_Parameter_Type::store_dc_metadata' succeeded, "
                              << "returning 0."
                              << endl
                              << "`irods_object_path' == " << irods_object_path
                              << endl;
                        unlock_cerr_mutex(); 

                    }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ********** (10) @>


                    temp_strm.str("");

                    temp_strm << "ADD METADATA RESPONSE 0 "
                              << "\"" << response.remote_filename << "\" " 
                              << "\"" << response.local_filename << "\" \"Stored "
                              << "Dublin Core metadata in iRODS object "
                              << "`" << irods_object_path << "' successfully.\"";

#if DEBUG_COMPILE
                    if (DEBUG)
                    {
                        lock_cerr_mutex(); 
                        cerr << "temp_strm.str() == " << temp_strm.str() << endl;
                        unlock_cerr_mutex(); 

                    }  /* |if (DEBUG)|  */
#endif /* |DEBUG_COMPILE|  */ 

                     new_response.command = temp_strm.str();
  
                     response_deque.push_back(new_response);

@q ********** (10) @>

                }  /* |else| (|status == 0|)  */

@q ********* (9) @>

            }  /* |else|  */

@q ******** (8) @>

        }  /* |else | (|items_written == true|)  */
        
@q ******* (7) @>

   }  /* |if (store)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

   if (items_written > 0)
   {
       temp_strm.str("");

       temp_strm << "ADD METADATA RESPONSE 0 \"" << response.remote_filename << "\" " 
                 << "\"" << response.local_filename << "\" \"(Success)\"";

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       
       new_response.command = temp_strm.str();
  
       response_deque.push_back(new_response);

   }  /* |if (items_written > 0)|  */

@q ****** (6) @>
@
\LOG
\initials{LDF 2013.01.04.}
Now sending response.

\initials{LDF 2013.01.11.}
Improved response.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

   else  /* |items_written == 0|  */
   {

       temp_strm.str("");

       temp_strm << "ADD METADATA RESPONSE 2 \"" << response.remote_filename << "\" " 
                 << "\"" << response.local_filename << "\" \"No XML metadata "
                 << "written to database";

        if (matched)
           temp_strm << ":  Matching XML data already present in database.";
        else
           temp_strm << ".";

        temp_strm << "\"";

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "temp_strm.str() == " << temp_strm.str() << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       new_response.command = temp_strm.str();
  
       response_deque.push_back(new_response);


#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "`item_written' == 0" << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |else| (|items_written == 0|) */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>=

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] Exiting `Scan_Parse_Parameter_Type::add_metadata' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;


}  /* End of |Scan_Parse_Parameter_Type::add_metadata| definition  */


@q **** (4) Parse metadata.  @>
@ Parse metadata..
\initials{LDF 2012.12.14.}

\LOG
\initials{LDF 2012.12.14.}
Added this function.

\initials{LDF 2013.02.13.}
Moved the definition of this function from \filename{scprpmtp.web} to 
this file (\filename{spptfnc1.web}).
\ENDLOG

@q ***** (5) Definition  @>
@
@<|Scan_Parse_Parameter_Type::parse_metadata| definition@>=

int
Scan_Parse_Parameter_Type::parse_metadata(vector<Dublin_Core_Metadata_Type> &dc_metadata_vector, 
                                          Response_Type &response)
{
@q ****** (6) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   int status;

   stringstream temp_strm;


#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "Entering `Scan_Parse_Parameter_Type::parse_metadata'."
            << endl;

       response.show("response:");

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) Test whether |response.temporary_file| contains metadata tags.  @>

@ Test whether |response.temporary_file| contains metadata tags.  
\initials{LDF 2013.01.10.}

@<|Scan_Parse_Parameter_Type::parse_metadata| definition@>=

   temp_strm.str("");

   temp_strm << "((cat '" << response.temporary_filename 
             << "' | grep -b \"metadata\") && echo \"0\") || echo \"1\"";


#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "temp_strm.str() == " << temp_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


   FILE *fp = popen(temp_strm.str().c_str(), "r");

   if (fp == 0)
   {
@q ******* (7) @>

       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "ERROR! In `Scan_Parse_Parameter_Type::parse_metadata':"
            << endl
            << "`popen' failed, returning NULL."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

@q ******* (7) @>

   }  /* |if (fp == 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::parse_metadata| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::parse_metadata':"
            << endl
            << "`popen' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


   char line_buffer[256][512];

   char *result;

   int i = 0;

   for(; ; ++i)
   {
@q ******* (7) @>

       if (i == 256)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "WARNING! In `Scan_Parse_Parameter_Type::parse_metadata':"
                << endl
                << "`popen' output exceeds maximum number of lines (255)."
                << endl
                << "Ignoring remaining lines.  Continuing."
                << endl;
           unlock_cerr_mutex(); 

           --i;

           ++warnings_occurred;

           break;      

       }  /* |if (i == 256)|  */

@q ******* (7) @>
 
       memset(line_buffer[i], 0, 512);

       result = fgets(line_buffer[i], 512, fp);

       if (result == 0)
       {
#if DEBUG_COMPILE
           if (DEBUG)  
           {
               lock_cerr_mutex(); 
               cerr << "`fgets' returned NULL.  Breaking." << endl
                    << "`feof(fp)' == " << feof(fp) << endl;                    
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           break;

       }  /* |if (result == 0)|  */

@q ******* (7) @>

       if (strlen(line_buffer[i]) == 511)
       {
          lock_cerr_mutex(); 
          cerr << "[Thread " << thread_ctr << "] "
               << "WARNING! In `Scan_Parse_Parameter_Type::parse_metadata':"
               << endl
               << "Length of `line_buffer[" << i << "]' read from `popen' output "
               << "exceeds maximum number of characters (510):"
               << endl 
               << "`strlen(line_buffer[" << i << "])' == " << strlen(line_buffer[i])
               << endl
               << "Will try to continue."
               << endl;
          unlock_cerr_mutex(); 

          ++warnings_occurred;

       }  /* |if (strlen(line_buffer[i]) == 511)|  */     

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "line_buffer[" << i << "] == " << line_buffer[i] << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

   }  /* |for|  */

   pclose(fp);
   fp = 0;


#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "After loop:  `i' == " << i << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::parse_metadata| definition@>=

   if (i == 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "ERROR! In `Scan_Parse_Parameter_Type::parse_metadata':"
            << endl
            << "`fgets' read 0 lines.  Failed to read `popen' output."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;     

   }  /* |if (i == 0)|  */

   status = strtol(line_buffer[i - 1], 0, 10);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Shell command result == `status' == " << status << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "ERROR! In `Scan_Parse_Parameter_Type::parse_metadata':"
            << endl
            << "Shell command failed, returning " << status << ".  "
            << "XML metadata file check failed."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;     

   }  /* |if (i == 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::parse_metadata':"
            << endl
            << "Shell command succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::parse_metadata| definition@>=

   if (i % 2 == 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "ERROR! In `Scan_Parse_Parameter_Type::parse_metadata':"
            << endl
            << "Shell command returned even number of lines.  "
            << "XML metadata file check failed."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;     


   }  /* |if (i % 2 == 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::parse_metadata':"
            << endl
            << "Shell command returned odd number of lines.  "
            << "This is correct."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::parse_metadata| definition@>=

   bool start = true;

   int curr_byte_ctr;
   char curr_tag[512];

   vector<int> byte_ctr_vector;

   for (int j = 0; j < i - 1; ++j)
   {
       memset(curr_tag, 0, 512);

       status = sscanf(line_buffer[j], "%d:%s", &curr_byte_ctr, curr_tag);

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "status == " << status << endl
                << "curr_byte_ctr == " << curr_byte_ctr << endl
                << "curr_tag == " << curr_tag << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


       if (   (   strncmp(curr_tag, "<metadata", strlen("<metadata")) == 0
               && start == false)
           || (   strncmp(curr_tag, "</metadata", strlen("</metadata")) == 0
               && start == true))
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "ERROR! In `Scan_Parse_Parameter_Type::parse_metadata':"
                << endl
                << "XML metadata file not correct:"
                << endl 
                << "Tag mismatch:  `start' == " << start << ", " 
                << "`curr_tag' == " << curr_tag << "."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           ++errors_occurred;

           return 1;                

       }  /* |if|  */
 
#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "Tags match:  `start' == " << start << ", " 
                << "`curr_tag' == " << curr_tag << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       byte_ctr_vector.push_back(curr_byte_ctr);

       start = !start;


   }  /* |for|  */


@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::parse_metadata| definition@>=

   ifstream in_strm;

   in_strm.open(response.temporary_filename.c_str());

   if (!in_strm)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "ERROR! In `Scan_Parse_Parameter_Type::parse_metadata':"
            << endl
            << "`in_strm' == `false'"
            << endl 
            << "Failed to open temporary file `" << response.temporary_filename << "' "
            << "for reading."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;                 

   }  /* |if (!in_strm)|  */

   if (!in_strm.is_open())
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "ERROR! In `Scan_Parse_Parameter_Type::parse_metadata':"
            << endl
            << "`in_strm.is_open()' == `false'"
            << endl 
            << "Failed to open temporary file `" << response.temporary_filename << "' "
            << "for reading."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;                 

   }  /* |if|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Opened temporary file `" << response.temporary_filename << "' "
            << "for reading successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
   

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::parse_metadata| definition@>=

   int start_val;
   int end_val;

   unsigned int buffer_size = 1048576;  /* $2^20$  */

   char buffer[buffer_size];

   Dublin_Core_Metadata_Type dcm;

   for (vector<int>::const_iterator iter = byte_ctr_vector.begin();
        iter != byte_ctr_vector.end();
        ++iter)
   {
@q ******* (7) @>

       memset(buffer, 0, buffer_size);

       in_strm.seekg(*iter);

       if (!in_strm.good())
       {

           cerr << "[Thread " << thread_ctr << "] "
                << "ERROR! In `Scan_Parse_Parameter_Type::parse_metadata':"
                << endl
                << "`in_strm.good()' == `false'"
                << endl 
                << "Failed to set position for reading `ifstream in_strm'."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           ++errors_occurred;

           in_strm.close();

           return 1;                 

       }  /* |if|  */

@q ******* (7) @>

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::parse_metadata':"
                << endl
                << "`in_strm.good()' == `true'"
                << endl 
                << "Set position for reading `ifstream in_strm' successfully."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       start_val = *iter++;
       end_val   = *iter;

       curr_byte_ctr = end_val - start_val + 11;  /* 11 == |strlen("</metadata>")|  */

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "start_val == " << start_val << endl
                << "end_val == " << end_val << endl
                << "curr_byte_ctr == " << curr_byte_ctr
                << endl;

           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>

       if (curr_byte_ctr >= buffer_size)
       {
           cerr << "[Thread " << thread_ctr << "] "
                << "ERROR! In `Scan_Parse_Parameter_Type::parse_metadata':"
                << endl
                << "`curr_byte_ctr' >= `buffer_size':" 
                << endl 
                << "`curr_byte_ctr' == " << curr_byte_ctr
                << endl 
                << "`buffer_size' == " << buffer_size
                << endl 
                << "XML data too long.  Can't read from `ifstream in_strm'."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           ++errors_occurred;

           in_strm.close();

           return 1;                 

       }  /* |if|  */

       in_strm.read(buffer, curr_byte_ctr);

       if (!in_strm.good())
       {
           cerr << "[Thread " << thread_ctr << "] "
                << "ERROR! In `Scan_Parse_Parameter_Type::parse_metadata':"
                << endl
                << "`in_strm.good()' == `false'"
                << endl 
                << "Failed to read from `ifstream in_strm'."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           ++errors_occurred;

           in_strm.close();

           return 1;                 

       }  /* |if|  */

@q ******* (7) @>

       else if (in_strm.gcount() != curr_byte_ctr)
       {
           cerr << "[Thread " << thread_ctr << "] "
                << "ERROR! In `Scan_Parse_Parameter_Type::parse_metadata':"
                << endl
                << "`in_strm.gcount()' != `curr_byte_ctr':"
                << endl 
                << "`in_strm.gcount()' == " << in_strm.gcount()
                << endl 
                << "`curr_byte_ctr' == " << curr_byte_ctr
                << endl 
                << "Failed to read from `ifstream in_strm'."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           ++errors_occurred;

           in_strm.close();

           return 1;                 

       }  /* |else if|  */


@q ******* (7) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "in_strm.gcount() == " << in_strm.gcount() << endl
#if 0 
                << "`buffer' == " << endl << buffer
#endif 
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******* (7) @>
@
@<|Scan_Parse_Parameter_Type::parse_metadata| definition@>=

        status = dcm.parse(buffer);

        if (status != 0)
        {
           cerr << "[Thread " << thread_ctr << "] "
                << "ERROR! In `Scan_Parse_Parameter_Type::parse_metadata':"
                << endl
                << "`Dublin_Core_Metadata_Type::parse' failed, returning " << status << "."
                << endl
                << "Failed to parse XML data."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           ++errors_occurred;

           in_strm.close();

           return 1;                 

        }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::parse_metadata':"
                 << endl
                << "`Dublin_Core_Metadata_Type::parse' succeeded, returning 0."
                << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        dcm.user_id = user_id;
        dcm.irods_object_path = response.local_filename;

        dc_metadata_vector.push_back(dcm);

        dcm.clear();

   }  /* |for|  */

   in_strm.close();

@q ****** (6) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex();
       cerr << "`dc_metadata_vector.size()' == " << dc_metadata_vector.size() << endl;
 
       for (vector<Dublin_Core_Metadata_Type>::const_iterator iter 
               = dc_metadata_vector.begin();
            iter != dc_metadata_vector.end();
            ++iter)
       {
           iter->show();
       }
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::parse_metadata| definition@>=

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] Exiting `Scan_Parse_Parameter_Type::parse_metadata' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;


}  /* End of |Scan_Parse_Parameter_Type::parse_metadata| definition  */


@q *** (3) Fetch handle from database.  @>
@ Fetch handle from database.
\initials{LDF 2013.02.07.}

\LOG
\initials{LDF 2013.02.07.}
Added this function.

\initials{LDF 2013.02.13.}
Moved the definition of this function from \filename{scprpmtp.web} to 
this file (\filename{spptfnc1.web}).

\initials{LDF 2013.02.28.}
Added argument |Handle_Type &handle|.  It replaces the old |Handle_Value_Type &| argument.
\ENDLOG

@q **** (4) Definition (version with scalar arguments)  @>
@
@<|Scan_Parse_Parameter_Type::fetch_handle_from_database| definition@>=
int
Scan_Parse_Parameter_Type::fetch_handle_from_database(unsigned long int handle_id,
                                                      Handle_Type &handle,
                                                      string type)
{

     int status;

     bool DEBUG = false;  /* |true|  */
     set_debug_level(DEBUG, 0, 0); 

#if DEBUG_COMPILE
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "Entering `Scan_Parse_Parameter_Type::fetch_handle_from_database' "
              << "(with scalar arguments)."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::fetch_handle_from_database| definition@>=

    vector<unsigned long int> handle_id_vector;
    vector<Handle_Type> handle_vector;

    handle_id_vector.push_back(handle_id);

    status = fetch_handles_from_database(handle_id_vector, 
                                         handle_vector,
                                         type);


    if (status != 0)
    {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] ERROR!  "
              << "In `Scan_Parse_Parameter_Type::fetch_handle_from_database' "
              << "(with scalar arguments):"
              << endl
              << "`Scan_Parse_Parameter_Type::fetch_handles_from_database' "
              << "(with vector arguments) failed, "
              << "returning " << status << "."
              << endl
              << "Exiting function unsuccessfully with return value " 
              << status << "."
              << endl;
         unlock_cerr_mutex(); 

    }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::fetch_handle_from_database' "
            << "(with scalar arguments):"
            << endl
            << "`Scan_Parse_Parameter_Type::fetch_handles_from_database' "
            << "(with vector arguments) succeeded, "
            << "returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   handle = handle_vector.front();


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::fetch_handle_from_database| definition@>=

#if DEBUG_COMPILE
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "Exiting `Scan_Parse_Parameter_Type::fetch_handle_from_database' "
              << "(with scalar arguments) successfully with return value 0."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

     return 0;

@q ***** (5) @>


}  /* End of |Scan_Parse_Parameter_Type::fetch_handle_from_database| (with scalar arguments)
      definition  */

@q *** (3) Fetch handle from database (|string| argument).  @>
@ Fetch handle from database (|string| argument).
\initials{LDF 2013.06.16.}

\LOG
\initials{LDF 2013.06.16.}
Added this function.
\ENDLOG

@q **** (4) Definition (version with |string| argument)  @>
@
@<|Scan_Parse_Parameter_Type::fetch_handle_from_database| definition@>=
int
Scan_Parse_Parameter_Type::fetch_handle_from_database(string handle_str,
                                                      Handle_Type &handle,
                                                      string type)
{

     int status;

     bool DEBUG = false;  /* |true|  */
     set_debug_level(DEBUG, 0, 0);

     stringstream sql_strm;

#if DEBUG_COMPILE
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "Entering `Scan_Parse_Parameter_Type::fetch_handle_from_database' "
              << "(with `string' argument)."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::fetch_handle_from_database| definition@>=

     sql_strm << "select distinct handle_id from handlesystem_standalone.handles "
              << "where handle = '" << handle_str << "' limit 1";

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::fetch_handle_from_database' "
            << "(with `string' arguments):"
            << endl
            << "`sql_strm.str()' == " << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
      
   MYSQL_RES *result = 0;
   unsigned int row_ctr;
   unsigned int field_ctr;
   MYSQL_ROW curr_row;

   status = submit_mysql_query(sql_strm.str().c_str(), result, &row_ctr, &field_ctr);

   if (status != 0)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] "
              << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_handle_from_database':"
              << endl 
              << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
              << status << "."
              << endl
              << mysql_error(mysql_ptr)
              << endl 
              << "Failed to fetch handle from database."
              << endl 
              << "Exiting function unsuccessfully with return value 1."
              << endl;
         unlock_cerr_mutex(); 

         if (result)
         {
             mysql_free_result(result);
         }

         ++errors_occurred;

         return 1;

     }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
     else if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] "
              << "In `Scan_Parse_Parameter_Type::fetch_handle_from_database':"
              << endl 
              << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
              << endl
              << "`row_ctr' == " << row_ctr
              << endl
              << "`field_ctr' == " << field_ctr
              << endl;
         unlock_cerr_mutex(); 

     }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::fetch_handle_from_database| definition@>=

     if (row_ctr == 0)
     {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::fetch_handle_from_database':"
                 << endl 
                 << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned 0 rows."
                 << endl
                 << "No handle ID fetched."
                 << endl 
                 << "Exiting function successfully with return value 2."
                 << endl;
            unlock_cerr_mutex(); 

    
        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        mysql_free_result(result);

        ++errors_occurred;

        return 2;

     }  /* |if (row_ctr == 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::fetch_handle_from_database| definition@>=

#if DEBUG_COMPILE
     else if (DEBUG)
     {
         lock_cerr_mutex();
         cerr << "[Thread " << thread_ctr << "] "
              << "In `Scan_Parse_Parameter_Type::fetch_handle_from_database':"
              << endl 
              << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned " 
              << row_ctr << " rows."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::fetch_handle_from_database| definition@>=

     if ((curr_row = mysql_fetch_row(result)) == 0)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] "
              << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_handle_from_database':"
              << endl 
              << "`mysql_fetch_row' failed:"
              << endl
              << mysql_error(mysql_ptr)
              << endl 
              << "Exiting function unsuccessfully with return value 1."
              << endl;
         unlock_cerr_mutex(); 

         mysql_free_result(result);

         ++errors_occurred;

         return 1;

     }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */


#if DEBUG_COMPILE 
     else if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] "
              << "In `Scan_Parse_Parameter_Type::fetch_handle_from_database':"
              << endl 
              << "`mysql_fetch_row' succeeded."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

     errno = 0;
     unsigned long int handle_id = strtoul(curr_row[0], 0, 10);

     if (handle_id == ULONG_MAX)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] "
              << "ERROR!  In `Scan_Parse_Parameter_Type::fetch_handle_from_database':"
              << endl 
              << "`strtoul' failed, returning `ULONG_MAX':"
              << endl
              << strerror(errno)
              << endl
              << "Exiting function unsuccessfully with return value 1."
              << endl;
         unlock_cerr_mutex(); 

         mysql_free_result(result);

         ++errors_occurred;

         return 1;         


     }  /* |if (handle_id == ULONG_MAX)|  */

#if DEBUG_COMPILE 
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] "
              << "In `Scan_Parse_Parameter_Type::fetch_handle_from_database':"
              << endl 
              << "`strtoul' succeeded."
              << endl
              << "`handle_id' == " << handle_id
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::fetch_handle_from_database| definition@>=

    mysql_free_result(result);
    result = 0;

    status = fetch_handle_from_database(handle_id,
                                        handle,
                                        type);


    if (status != 0)
    {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] ERROR!  "
              << "In `Scan_Parse_Parameter_Type::fetch_handle_from_database' "
              << "(with `string' argument):"
              << endl
              << "`Scan_Parse_Parameter_Type::fetch_handle_from_database' "
              << "(with scalar arguments) failed, "
              << "returning " << status << "."
              << endl
              << "Exiting function unsuccessfully with return value " 
              << status << "."
              << endl;
         unlock_cerr_mutex(); 

         return 1;

    }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::fetch_handle_from_database' "
            << "(with `string' arguments):"
            << endl
            << "`Scan_Parse_Parameter_Type::fetch_handles_from_database' "
            << "(with vector arguments) succeeded, "
            << "returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::fetch_handle_from_database| definition@>=

#if DEBUG_COMPILE
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "Exiting `Scan_Parse_Parameter_Type::fetch_handle_from_database' "
              << "(with `string' arguments) successfully with return value 0."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

     return 0;

@q ***** (5) @>


}  /* End of |Scan_Parse_Parameter_Type::fetch_handle_from_database| (with `string' argument)
      definition  */


@q *** (3) Fetch handles from database.  @>
@ Fetch handles from database.
\initials{LDF 2013.02.07.}

\LOG
\initials{LDF 2013.02.07.}
Added this function.

\initials{LDF 2013.02.13.}
Moved the definition of this function from \filename{scprpmtp.web} to 
this file (\filename{spptfnc1.web}).

\initials{LDF 2013.02.28.}
Added argument |vector<Handle_Type> &handle_vector|.  It replaces the old 
|vector<Handle_Value_Type> &| argument.  

\initials{LDF 2013.08.12.}
Removed code.  Now calling |Handle_Type::fetch_handles_from_database|, which 
contains the code that was formerly in this function.
\ENDLOG

@q **** (4) Definition (version with vector arguments)  @>
@
@<|Scan_Parse_Parameter_Type::fetch_handles_from_database| definition@>=
int
Scan_Parse_Parameter_Type::fetch_handles_from_database(
                               vector<unsigned long int> &handle_id_vector,
                               vector<Handle_Type> &handle_vector,
                               string type)

{
@q ***** (5) @>

     bool DEBUG = false;  /* |true|  */
     set_debug_level(DEBUG, 0, 0); 

     int status;

     stringstream temp_strm;

     temp_strm << "[Thread " << thread_ctr << "] ";

     string thread_str = temp_strm.str();

     temp_strm.str("");

#if DEBUG_COMPILE
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] "
              << "Entering `Scan_Parse_Parameter_Type::fetch_handles_from_database' "
              << "(with vector arguments)."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

     status = Handle_Type::fetch_handles_from_database(mysql_ptr, 
                                                       handle_id_vector,
                                                       handle_vector,
                                                       type,
                                                       thread_str);

     if (status != 0)
     {
#if DEBUG_COMPILE
         if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << "[Thread " << thread_ctr << "] "
                  << "ERROR! In `Scan_Parse_Parameter_Type::fetch_handles_from_database' "
                  << "(with vector arguments):"
                  << endl
                  << "`Handle_Type::fetch_handles_from_database::fetch_handles_from_database' "
                  << "failed, returning " << status << "."
                  << endl 
                  << "Exiting function unsuccessfully with return value " << status << "."
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

         ++errors_occurred;

         return status;

     }  /* |if (status != 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::fetch_handles_from_database| definition@>=

#if DEBUG_COMPILE
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] "
              << "In `Scan_Parse_Parameter_Type::fetch_handles_from_database' "
              << "(with vector arguments):"
              << endl
              << "`Handle_Type::fetch_handles_from_database::fetch_handles_from_database' "
              << "succeeded, returning 0."
              << endl
              << "handle_vector.size() == " << handle_vector.size() 
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::fetch_handles_from_database| definition@>=

#if DEBUG_COMPILE
     if (DEBUG)
     {
         lock_cerr_mutex(); 
         cerr << "[Thread " << thread_ctr << "] "
              << "Exiting `Scan_Parse_Parameter_Type::fetch_handles_from_database' "
              << "(with vector arguments) successfully with return value 0."
              << endl;
         unlock_cerr_mutex(); 

     }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

     return 0;

@q ***** (5) @>

}  /* End of |Scan_Parse_Parameter_Type::fetch_handles_from_database| (with vector arguments)
      definition  */

@q *** (3) Store Dublin Core metadata (|store_dc_metadata|).  @>
@ Store Dublin Core metadata (|store_dc_metadata|).
\initials{LDF 2013.03.01.}

\LOG
\initials{LDF 2013.03.01.}
Added this function.  It's declared in \filename{scprpmtp.web}.

\initials{LDF 2013.03.07.}
Changed arguments:  Now passing |Handle_Type| references instead of a string 
representing the handle and |unsigned long int| values representing the handle ID.

\initials{LDF 2013.11.25.}
Added optional argument |unsigned long irods_object_ref_id = 0UL|.

\initials{LDF 2013.11.27.}
Added required argument |unsigned long dc_metadata_id|.
\ENDLOG

@q **** (4) Definition @>

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

int
Scan_Parse_Parameter_Type::store_dc_metadata(const Response_Type &response,
                                             Handle_Type &irods_object_handle, 
                                             Handle_Type &dc_metadata_handle,
                                             bool force,
                                             string &dc_metadata_irods_object_path,
                                             unsigned long int dc_metadata_id,
                                             unsigned long int irods_object_ref_id,
                                             string thread_str)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   int status;

   MYSQL_RES *result = 0;
   unsigned int row_ctr;
   unsigned int field_ctr;

  long int affected_rows;

   stringstream sql_strm;
   stringstream temp_strm;

   FILE *fp;

   char buffer[1024];

   memset(buffer, 0, 1024);

   bool irods_object_exists = false;

   vector<Handle_Value_Triple>  hvt_vector;
   
   Handle_Value_Triple hvt;

   Response_Type new_response;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "Entering `Scan_Parse_Parameter_Type::store_dc_metadata'."
            << endl; 

       response.show("response:");

       cerr << "`force' == " << force << endl
            << "irods_object_handle.handle == " << irods_object_handle.handle << endl
            << "irods_object_handle.handle_id == " << irods_object_handle.handle_id << endl
            << "dc_metadata_handle.handle == " << dc_metadata_handle.handle << endl
            << "dc_metadata_handle.handle_id == " << dc_metadata_handle.handle_id << endl
            << "irods_current_dir == " << irods_current_dir << endl
            << "dc_metadata_irods_object_path == " << dc_metadata_irods_object_path 
            << endl
            << "basename(response.remote_filename.c_str()) == " 
            << basename(response.remote_filename.c_str()) << endl
            << "dc_metadata_id == " << dc_metadata_id
            << endl 
            << "irods_object_ref_id == " << irods_object_ref_id
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@ @:TODO@> !! TODO:  Make it possible to use the same directory as the iRODS object
to which the metadata refers.
\initials{LDF 2013.03.08.}

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   dc_metadata_irods_object_path = basename(response.remote_filename.c_str());

   if (dc_metadata_irods_object_path.empty())
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl
            << "`basename' returned empty string."
            << endl 
            << "Filename for Dublin Core metadata is empty."
            << endl         
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (dc_metadata_irods_object_path.empty())|  */

   dc_metadata_irods_object_path.insert(0, "/");

   dc_metadata_irods_object_path.insert(0, irods_current_dir);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl
            << "`dc_metadata_irods_object_path' == `" << dc_metadata_irods_object_path << "'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) Check whether iRODS object already exists.  @>

@ Check whether iRODS object already exists.  
\initials{LDF 2013.03.06.}

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   Irods_Object_Type curr_irods_object;

   curr_irods_object.set(user_id, 
                         dc_metadata_irods_object_path, 
                         dc_metadata_id, 
                         irods_object_ref_id);



#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       curr_irods_object.show("curr_irods_object:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = curr_irods_object.get_from_database(mysql_ptr, true);

   if (status == -1)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl
            << "`Irods_Object_Type::get_from_database' failed, returning -1."
            << endl         
            << "Failed to check for existence of iRODS object "
            << "`" << dc_metadata_irods_object_path << "'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (status == -1)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "]  "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl
            << "`Irods_Object_Type::get_from_database' succeeded, returning " << status << "."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

@ iRODS object found in database and |force == false|.  iRODS object not 
overwritten.  Exit.
\initials{LDF 2013.03.07.}

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   if (status > 0 && !force)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] WARNING!  "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl
            << "`Irods_Object_Type::get_from_database' returned " << status << " (> 0)."
            << endl         
            << "iRODS object `" << dc_metadata_irods_object_path << "' already exists "
            << "and `force' == `false'."
            << endl 
            << "Not overwriting iRODS object."
            << endl 
            << "Exiting function successfully with return value 2."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 2;

   }  /* |if (status > 0 && !force)|  */

@q ***** (5) @>

@ iRODS object exists in database, but |force == true|.  Will overwrite iRODS object.
\initials{LDF 2013.03.07.}

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   else if (status > 0 && force)
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                << endl
                << "`Irods_Object_Type::get_from_database' returned " << status << " (> 0)."
                << endl         
                << "iRODS object `" << dc_metadata_irods_object_path << "' already exists "
                << "and `force' is `true'."
                << endl
                << "Will call \"iput\" with the `-f' option."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       irods_object_exists = true;

   }  /* |else if (status > 0 && force)|  */

@q ***** (5) @>

@ iRODS object not found in database.  Will check iRODS system using \.{ils} to see if
an iRODS exists.  Normally, this shouldn't be the case, but an iRODS object may have been
created directly using \.{iput} or one of the Jargon APIs.
\initials{LDF 2013.03.07.}

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl
            << "`Irods_Object_Type::get_from_database' returned 0."
            << endl         
            << "iRODS object `" << dc_metadata_irods_object_path << "' not found in database."
            << endl 
            << "Will check using `ils'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

@ iRODS object doesn't exist in the database.  Write it to database.  This needs 
to be done even if an iRODS object exists in the iRODS system.
\initials{LDF 2013.03.07.}

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   if (!irods_object_exists)
   {
@q ****** (6) @>

        status = curr_irods_object.write_to_database(mysql_ptr);  

@q ****** (6) @>

        if (status != 0)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] ERROR!  "
                 << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl
                 << "`Irods_Object_Type::write_to_database' failed, returning -1."
                 << endl         
                 << "Failed to write iRODS object "
                 << "`" << dc_metadata_irods_object_path << "' to database."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            ++errors_occurred;

            return 1;

        }  /* |if (status != 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl
                 << "`Irods_Object_Type::write_to_database' succeeded, returning 0."
                 << endl;         

            curr_irods_object.show("curr_irods_object:");
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */         

@q ****** (6) @>
@
\LOG
\initials{LDF 2013.11.27.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

        sql_strm.str("");

        if (result)
        {
           mysql_free_result(result);
           result = 0;
        }

        sql_strm << "update gwirdsif.Dublin_Core_Metadata set irods_object_self_id = "
                 << curr_irods_object.id << " where dublin_core_metadata_id = " 
                 << dc_metadata_id;

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl
                 << "`sql_strm.str()' == " << sql_strm.str()
                 << endl;         
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */         

        status = submit_mysql_query(sql_strm.str(), result, 0, 0, &affected_rows);

        if (status != 0)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl
                 << "`submit_mysql_query' failed, returning " << status << "."
                 << endl
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex(); 

            if (result)
               mysql_free_result(result);

            ++errors_occurred;

            return 1;

        }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << thread_str << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl
                 << "`submit_mysql_query' succeeded, returning 0."
                 << endl
                 << "`affected_rows' == " << affected_rows
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */  

@q ****** (6) @>

        sql_strm.str("");
        mysql_free_result(result);
        result = 0;

@q ****** (6) @>
@ Call \.{ils}.
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

        temp_strm.str();

        temp_strm << "r=`env irodsEnvFile=" << irods_env_filename << " ils "
                  << dc_metadata_irods_object_path << " 2>&1`; echo -e \"$?\\n$r\"";

#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl 
                 << "`temp_strm.str()' == " << temp_strm.str()
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        errno = 0;
        fp = popen(temp_strm.str().c_str(), "r");

        if (fp == 0)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl 
                 << "`popen' failed, returning NULL:"
                 << endl
                 << strerror(errno)
                 << endl
                 << "Failed to check for existence of iRODS object using `ils'."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex();            

            ++errors_occurred;

            return 1;

        }  /* |if (fp == 0)|  */
   
@q ****** (6) @>
  
#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl 
                 << "`popen' succeeded."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

        int temp_val;

        errno = 0;
        status = fscanf(fp, "%d", &temp_val);

        if (status != 1)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl 
                 << "`fscanf' failed, returning " << status << ":"
                 << endl
                 << strerror(errno)
                 << endl
                 << "Failed to check for existence of iRODS object using `ils'."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex();            

            ++errors_occurred;

            pclose(fp);

            return 1;

        }  /* |if (status != 1)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl 
                 << "`fscanf' succeeded, returning 1."
                 << endl
                 << "`temp_val' == " << temp_val
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

        if (temp_val == 0)
        {
            lock_cerr_mutex(); 
             cerr << "[Thread " << thread_ctr << "] "
                  << "WARNING!  In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                  << endl 
                  << "`ils' returned 0:  "
                  << "An iRODS object already exists for "
                  << "`" << dc_metadata_irods_object_path << "' and "
                  << "`force' == `false'."
                  << endl
                  << "Not storing Dublin Core metadata in an iRODS object."
                  << endl 
                  << "Exiting function successfully with return value 2."
                  << endl;
            unlock_cerr_mutex();            
    
            if (result)
               mysql_free_result(result);

            ++warnings_occurred;

            pclose(fp);

            return 2;

        }  /* |if (temp_val == 0)|  */

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "temp_val == " << temp_val << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

@ Read the output of the \.{ils} command.  This isn't really necessary, since it's not evaluated.
However, it may be useful for some purpose in the future.
\initials{LDF 2013.03.07.}

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

        memset(buffer, 0, 1024);

        status = fread(buffer, 1, 1024, fp);
  
        if (status == 0)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl 
                 << "`fread' failed, returning 0."
                 << endl
                 << "Failed to retrieve output from call to `ils'."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex();            

            ++errors_occurred;

            pclose(fp);

            return 1;

        }  /* |if (status == 0)|  */

@q ****** (6) @>

        else if (status == 1024)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "ERROR!  In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl 
                 << "`fread' returned 1024:  Number of characters returned by call to `ils' "
                 << "exceeds maximum allowed (1023)."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1."
                 << endl;
            unlock_cerr_mutex();            

            ++errors_occurred;

            pclose(fp);

            return 1;

        }  /* |else if (status == 1024)|  */


#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "status == " << status << endl
                 << "buffer == " << buffer << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        pclose(fp);
        fp = 0;

@q ****** (6) @>

        if (temp_val == 0)
           irods_object_exists = true;

   }  /* |if (!irods_object_exists)|  */


@q ***** (5) @>

@ |force == true|.  Overwrite iRODS object, if it already exists.
\initials{LDF 2013.03.07.}

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   if (force)
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                << endl
                << "`force' == `true' and "
                << endl;

           if (irods_object_exists)
           {

                cerr << "`irods_object_exists' == `true'."
                     << endl
                     << "iRODS object `" << dc_metadata_irods_object_path << "' already exists.  "
                     << "Will overwrite."
                     << endl;

           }  /* |if (irods_object_exists)|  */

           else
           {
                cerr << "`irods_object_exists' == `false'."
                << endl
                << "iRODS object `" << dc_metadata_irods_object_path << "' "
                << "doesn't already exist.  "
                << "Will create."
                << endl;
           }

           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |if (force)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   else /* |!force|  */
   {
@q ****** (6) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                << endl
                << "`force' == `false'."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */       

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

@q ****** (6) @>
@ |force == false| and iRODS
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

       if (irods_object_exists)
       {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "WARNING!  In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl 
                 << "`force' == `false' and `irods_object_exists' == `true'."
                 << endl
                 << "iRODS object `" << dc_metadata_irods_object_path << "' already exists.  "
                 << "Not overwriting."
                 << "Exiting function successfully with return value 2."
                 << endl;
            unlock_cerr_mutex();            

            ++warnings_occurred;

            return 2;

       }  /* |if (irods_object_exists)|  */

@q ****** (6) @>

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                << endl 
                << "`force' == `false' and `irods_object_exists' == `false'."
                << endl
                << "iRODS object `" << dc_metadata_irods_object_path << "' "
                << "doesn't already exist.  Will create."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

   } /* |else| (|!force|)  */

@q ***** (5) Generate PID.  @>

@ Generate PID.  
\initials{LDF 2013.03.07.}

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   string curr_pid;
   vector<Handle_Type> handle_vector;

   status = generate_pids(mysql_ptr, 
                          default_handle_prefix, 
                          curr_pid,
                          0,      /* PID vector pointer (|vector<string> *| */
                          1,      /* Number of PIDS  */
                          0,      /* Handle ID vector pointer */
                          0,      /* Handle value ID vector pointer */
                          true,   /* standalone handle server  */
                          "",     /* Institute string  */
                          "",     /* Suffix string  */
                          &handle_vector,
                          "", /* |fifo_pathname|  */
                          user_id,
                          username);

@q ***** (5) @>

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl 
            << "`generate_pids' failed, returning "
            << status << "."
            << endl 
            << "Failed to generate PID."
            << "Exiting function unsuccessfully with return value 1." 
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   else  /* |status == 0|  */
   {
#if DEBUG_COMPILE
        if (DEBUG)      
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl 
                 << "`generate_pids' succeeded, returning 0:"
                 << endl
                 << "`curr_pid' == " << curr_pid 
                 << endl;

             if (handle_vector.size() != 0)
             {
                  cerr << "Showing `handle_vector.back()':" << endl;

                  handle_vector.back().show(
                     "handle_vector.back()");

             }  /* |if|  */
             unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
 
        new_response.clear();
        new_response.type = Response_Type::COMMAND_ONLY_TYPE;

        temp_strm.str("");

        temp_strm << "STORE METADATA RESPONSE 0 \"" << dc_metadata_irods_object_path << "\" "
                  << "\"" << response.local_filename << "\" "
                  << "\"" << "Generated handle " << handle_vector.back().handle 
                  << " for Dublin Core metadata iRODS object "
                  << "`" << dc_metadata_irods_object_path << "'.\"";

         new_response.command = temp_strm.str();

         temp_strm.str("");

         response_deque.push_back(new_response);

   }  /* |else| (|status == 0|)  */

   curr_irods_object.handle_id_vector.push_back(handle_vector.back().handle_id);

@q ***** (5) @>

@ Call |Handle_Type::add_value| on |handle_vector.back()|.
\initials{LDF 2013.03.07.}

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

@q ****** (6) @>

   hvt.idx = Handle_Value_Type::DC_METADATA_IRODS_OBJECT_INDEX;
   hvt.type = Handle_Value_Type::idx_type_map[Handle_Value_Type::DC_METADATA_IRODS_OBJECT_INDEX];
   hvt.data_str = dc_metadata_irods_object_path;

   hvt_vector.push_back(hvt);

@q ****** (6) @>

   hvt.idx  = Handle_Value_Type::IRODS_OBJECT_REF_INDEX;
   hvt.type 
      = Handle_Value_Type::idx_type_map[Handle_Value_Type::IRODS_OBJECT_REF_INDEX];
   hvt.data_str = response.local_filename;

   hvt_vector.push_back(hvt);

@q ****** (6) @>

   hvt.idx  = Handle_Value_Type::IRODS_OBJECT_PID_INDEX;
   hvt.type 
      = Handle_Value_Type::idx_type_map[Handle_Value_Type::IRODS_OBJECT_PID_INDEX];
   hvt.data_str = irods_object_handle.handle;

   hvt_vector.push_back(hvt);

@q ****** (6) @>

   hvt.idx  = Handle_Value_Type::DC_METADATA_PID_INDEX;
   hvt.type 
      = Handle_Value_Type::idx_type_map[Handle_Value_Type::DC_METADATA_PID_INDEX];
   hvt.data_str = dc_metadata_handle.handle;

   hvt_vector.push_back(hvt);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl 
            << "hvt_vector:" << endl;

       for (vector<Handle_Value_Triple>::iterator iter = hvt_vector.begin();
            iter != hvt_vector.end();
            ++iter)
       {
          cerr << "iter->idx == " << iter->idx << endl
               << "iter->type == " << iter->type << endl
               << "iter->data_str == " << iter->data_str << endl;
               
       }
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ****** (6) @>

   status = handle_vector.back().add_values(mysql_ptr, 
                                            hvt_vector,
                                            user_id);
   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl 
            << "`Handle_Type::add_value' failed, returning " << status << "."
            << endl 
            << "Failed to add value to PID `" << curr_pid << "'."
            << endl 
            << "Exiting function unsuccessfully with return value 1." 
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl 
            << "`Handle_Type::add_value' succeeded, returning 0."
            << endl 
            << "Added value to PID `" << curr_pid << "' successfully."
            << endl; 

       handle_vector.back().show("handle_vector.back():");

       cerr << "response.local_filename == " << response.local_filename << endl
            << "irods_object_handle.handle == " << irods_object_handle.handle << endl
            << "irods_object_handle.handle_id == " << irods_object_handle.handle_id << endl
            << "dc_metadata_handle.handle == " << dc_metadata_handle.handle << endl
            << "dc_metadata_handle.handle_id == " << dc_metadata_handle.handle_id << endl;

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   hvt_vector.clear();

   hvt.idx  = Handle_Value_Type::DC_METADATA_IRODS_OBJECT_REF_INDEX;
   hvt.type 
      = Handle_Value_Type::idx_type_map[Handle_Value_Type::DC_METADATA_IRODS_OBJECT_REF_INDEX];
   hvt.data_str = dc_metadata_irods_object_path;

   hvt_vector.push_back(hvt);

   hvt.idx  = Handle_Value_Type::DC_METADATA_IRODS_OBJECT_PID_INDEX;
   hvt.type 
      = Handle_Value_Type::idx_type_map[Handle_Value_Type::DC_METADATA_IRODS_OBJECT_PID_INDEX];
   hvt.data_str = curr_pid;

   hvt_vector.push_back(hvt);

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   status = irods_object_handle.add_values(mysql_ptr, hvt_vector, user_id);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl 
            << "`Handle_Type::add_value' failed, returning " << status << "."
            << endl 
            << "Failed to add value to PID `" << irods_object_handle.handle << "'."
            << endl 
            << "Exiting function unsuccessfully with return value 1." 
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl 
            << "`Handle_Type::add_value' succeeded, returning 0."
            << endl 
            << "Added value to PID `" << irods_object_handle.handle << "' successfully."
            << endl; 

       irods_object_handle.show("irods_object_handle:");
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   status = dc_metadata_handle.add_values(mysql_ptr, hvt_vector, user_id);


   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl 
            << "`Handle_Type::add_value' failed, returning " << status << "."
            << endl 
            << "Failed to add value to PID `" << dc_metadata_handle.handle << "'."
            << endl 
            << "Exiting function unsuccessfully with return value 1." 
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl 
            << "`Handle_Type::add_value' succeeded, returning 0."
            << endl 
            << "Added value to PID `" << dc_metadata_handle.handle << "' successfully."
            << endl; 

       dc_metadata_handle.show("dc_metadata_handle:");

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>
@ Set AVUs in |curr_irods_object|.
\initials{LDF 2013.03.07.}

\LOG
\initials{LDF 2013.03.07.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   time_t t = time(0);

   int temp_val_1 = curr_irods_object.avu_vector.size();

   Irods_AVU_Type curr_avu("TYPE", "DC_METADATA_IRODS_OBJECT", "", t, curr_irods_object.id);

   curr_irods_object.avu_vector.push_back(curr_avu);

   curr_avu.set("PID", curr_pid, "", t, curr_irods_object.id);

   curr_irods_object.avu_vector.push_back(curr_avu);
 
   curr_avu.set("IRODS_OBJECT_REF", response.local_filename, "", t, curr_irods_object.id);

   curr_irods_object.avu_vector.push_back(curr_avu);

   curr_avu.set("IRODS_OBJECT_PID", irods_object_handle.handle, "", t, curr_irods_object.id);

   curr_irods_object.avu_vector.push_back(curr_avu);

   curr_avu.set("DC_METADATA_PID", dc_metadata_handle.handle, "", t, curr_irods_object.id);

   curr_irods_object.avu_vector.push_back(curr_avu);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       curr_irods_object.show("curr_irods_object:");

       cerr << "temp_val_1 == " << temp_val_1 << endl
            << "curr_irods_object.avu_vector.size() == " 
            << curr_irods_object.avu_vector.size() 
            << endl;

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   for (int i = temp_val_1; i < curr_irods_object.avu_vector.size(); ++i)
   {
@q ****** (6) @>

        status = curr_irods_object.avu_vector[i].write_to_database(mysql_ptr, thread_ctr);

        if (status != 0)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] ERROR!  "
                 << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl 
                 << "`Irods_AVU_Type::write_to_database' failed, returning " << status << "."
                 << endl 
                 << "Failed to write AVU to `gwirdsif.Irods_AVUs' database table."
                 << endl 
                 << "Exiting function unsuccessfully with return value 1." 
                 << endl;
            unlock_cerr_mutex(); 

            ++errors_occurred;

            return 1;

        }  /* |if (status != 0)|  */

@q ****** (6) @>

#if DEBUG_COMPILE
        else if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                 << endl 
                 << "`Irods_AVU_Type::write_to_database' succeeded, returning 0."
                 << endl 
                 << "Wrote AVU to `gwirdsif.Irods_AVUs' database table successfully."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

   }  /* |for|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   status = curr_irods_object.update(mysql_ptr);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl 
            << "`Irods_Object_Type::update' failed, returning "
            << status << "."
            << endl 
            << "Failed to update `curr_irods_object'."
            << "Exiting function unsuccessfully with return value 1." 
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl 
            << "`Irods_Object_Type::update' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

@ Call |Irods_Object_Type::put_irods_object| on |curr_irods_object|.
\initials{LDF 2013.03.07.}

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   status = curr_irods_object.put_irods_object(response.temporary_filename, 
                                               irods_env_filename,
                                               force);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl 
            << "`Irods_Object_Type::put_irods_object' failed, returning "
            << status << "."
            << endl 
            << "Failed to \"put\" `curr_irods_object'."
            << "Exiting function unsuccessfully with return value 1." 
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl 
            << "`Irods_Object_Type::put_irods_object' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   Irods_Object_Type ref_irods_object;

   ref_irods_object.set(user_id, response.local_filename);

   status = ref_irods_object.get_from_database(mysql_ptr, true);

   if (status == -1)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
            << endl
            << "`Irods_Object_Type::get_from_database' failed, returning -1."
            << endl         
            << "Failed to check for existence of iRODS object "
            << "`" << response.local_filename << "'."
            << endl 
            << "Exiting function unsuccessfully with return value 1." 
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (status == -1)|  */

@q ***** (5) @>
@ iRODS object |response.local_filename| doesn't exist in database.
This may occur if Dublin Core metadata is added for a non-existent iRODS
object.  
\par
@:NOTE@> !! PLEASE NOTE:  This code {\it does not\/} check the iRODS system
using the \.{ils}  command;  If there's no database entry for the iRODS object,
one is not created here and no AVU is added.
\par
@:TODO@> !! TODO:  Set up a response and send it to the client.
\initials{LDF 2013.03.08.}

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   else if (status == 0)
   {
        lock_cerr_mutex(); 
        cerr << "[Thread " << thread_ctr << "] WARNING!  "
             << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
             << endl
             << "`Irods_Object_Type::get_from_database' returned 0:"
             << endl         
             << "iRODS object `" << response.local_filename << "' not present in database."
             << endl 
             << "Not adding AVU.  Continuing."
             << endl;
        unlock_cerr_mutex(); 
 
   }  /* |else if (status == 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

   else /* |status > 0|  */
   {
@q ****** (6) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]  "
                << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                << endl
                << "`Irods_Object_Type::get_from_database' succeeded, returning " << status << "."
                << endl;
      
           ref_irods_object.show("ref_irods_object:");
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
\LOG
\initials{LDF 2013.08.16.}
@:BUG FIX@> BUG FIX:  Added |Irods_AVU_TYPE avu_1|.  
Now calling |Irods_AVU_TYPE::write_to_database| on both |avu| and |avu_1|.  Previously,
only |avu| was used.  It was reset and |Irods_Object::add_avu| was called twice, but
|Irods_AVU_TYPE::write_to_database| was only called once and after |avu| had been reset.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

       Irods_AVU_Type avu("DC_METADATA_IRODS_OBJECT_REF", dc_metadata_irods_object_path);
       Irods_AVU_Type avu_1("DC_METADATA_IRODS_OBJECT_PID", curr_pid);

       avu.irods_object_id = avu_1.irods_object_id = ref_irods_object.id;

       status = ref_irods_object.add_avu(avu, irods_env_filename, true, false, false);

       if (status == 0)
       {
           status = ref_irods_object.add_avu(avu_1, irods_env_filename, true, false, false);
       }

@q ****** (6) @>

       if (status != 0)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                << endl
                << "`Irods_Object_Type::add_avu' failed, returning " << status << "."
                << endl         
                << "Failed to add AVU to iRODS object `" << ref_irods_object.path << "'."
                << endl 
                << "Exiting function unsuccessfully with return value 1." 
                << endl;
           unlock_cerr_mutex(); 

           ++errors_occurred;

           return 1;

       }  /* |if (status != 0)|  */

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                << endl
                << "`Irods_Object_Type::add_avu' succeeded, returning 0."
                << endl         
                << "Added AVU to iRODS object `" << ref_irods_object.path << "' successfully."
                << endl; 
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */       

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

      status = avu.write_to_database(mysql_ptr, thread_ctr);

      if (status == 0)
         status = avu_1.write_to_database(mysql_ptr, thread_ctr);

      if (status != 0)
      {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                << endl
                << "`Irods_AVU_Type::write_to_database' failed, returning " << status << "."
                << endl         
                << "Failed to write `avu' or `avu_1' to `gwirdsif.Irods_AVUs' database table."
                << endl 
                << "Exiting function unsuccessfully with return value 1." 
                << endl;
           unlock_cerr_mutex(); 

           ++errors_occurred;

           return 1;

      }
#if DEBUG_COMPILE
      else if (DEBUG)
      {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::store_dc_metadata':"
                << endl
                << "`Irods_AVU_Type::write_to_database' succeeded, returning 0."
                << endl         
                << "Wrote `avu' and `avu_1' to `gwirdsif.Irods_AVUs' database table successfully."
                << endl;
           unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

   } /* |else| (|status > 0|)  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "Exiting `Scan_Parse_Parameter_Type::store_dc_metadata' successfully "
            << "with return value 0."
            << endl;       
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::store_dc_metadata|  */

@q *** (3) Show certificates  @>
@ Show certificates.
\initials{LDF 2013.05.15.}

\LOG
\initials{LDF 2013.05.15.}
Added this function.
\ENDLOG

@q **** (4) Definition  @>

@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

int
Scan_Parse_Parameter_Type::show_certificates(Response_Type &response, 
                                             char *buffer, 
                                             size_t buffer_size,
                                             string &filename)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   stringstream sql_strm;

   MYSQL_RES *result = 0;
   unsigned int row_ctr;
   unsigned int field_ctr;
   MYSQL_ROW curr_row;

   int status;

   stringstream temp_strm;

   temp_strm << "[Thread " << thread_ctr << "] ";

   string thread_ctr_str = temp_strm.str();

   temp_strm.str("");

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "Entering `Scan_Parse_Parameter_Type::show_certificates'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   memset(buffer, 0, buffer_size);

@q ***** (5) @>
@
\LOG
\initials{LDF 2013.05.16.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

   if (response.int_val == 0)
   {
      if (privileges & SHOW_CERTIFICATES_PRIVILEGE == 0U)  
      {
           /* Normally, this code should never be reached, because this case
              is caught in |yyparse|.  
              \initials{LDF 2013.05.16.}  */

           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::show_certificates':"
                << endl
                << "User " << username << " (ID " << user_id << ") is not authorized to "
                << "show all certificates."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           strcpy(buffer, "SHOW CERTIFICATE RESPONSE 3");

           ++errors_occurred;

           return 1;

      }  /* |if (privileges & SHOW_CERTIFICATES_PRIVILEGE == 0U)|  */

#if DEBUG_COMPILE
      else if (DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::show_certificates':"
               << endl
               << "User " << username << " (ID " << user_id << ") is authorized to "
               << "show all certificates."
               << endl;
          unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |if (response.int_val == 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::show_certificates':"
            << endl;
       response.show("response:");
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   sql_strm << "select C.certificate_id, C.user_id, U.username, C.issuer_cert_id, C.is_ca, "
            << "C.is_proxy, C.serialNumber, C.organization, C.organizationalUnitName, "
            << "C.commonName, C.countryName, C.localityName, C.stateOrProvinceName, "
            << "C.Validity_notBefore, C.Validity_notAfter "
            << "from gwirdsif.Certificates as C, Users as U "
            << "where C.certificate_id > 0 and C.user_id = U.user_id  ";

   if (response.int_val == 1)
      sql_strm << "and C.user_id = " << user_id << " ";

   sql_strm << "order by certificate_id";

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::show_certificates':"
            << endl
            << "`sql_strm.str()' == " << sql_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "ERROR!  In `Scan_Parse_Parameter_Type::show_certificates':"
            << endl
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
            << status << ":"
            << endl
            << mysql_error(mysql_ptr)
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
          mysql_free_result(result);

       strcpy(buffer, "SHOW CERTIFICATE RESPONSE 1");

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::show_certificates':"
            << endl
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded, returning 0:" 
            << endl
            << "`row_ctr' ==   " << row_ctr
            << endl
            << "`field_ctr' == " << field_ctr
            << endl;

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

   vector<X509_Cert_Type> cert_vector;

   X509_Cert_Type curr_cert;

   for (int i = 0; i < row_ctr; ++i)
   {
@q ****** (6) @>

       if ((curr_row = mysql_fetch_row(result)) == 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "ERROR!  "
                << "In `Scan_Parse_Parameter_Type::show_certificates':"
                << endl 
                << "`mysql_fetch_row' failed:"
                << endl
                << mysql_error(mysql_ptr)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           temp_strm.str("");

           memset(buffer, 0, buffer_size);
           strcpy(buffer, "SHOW CERTIFICATE RESPONSE 1");

           ++errors_occurred;

           return 1;

       }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

@q ****** (6) @>

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::show_certificates':"
                << endl 
                << "`mysql_fetch_row' succeeded, returning 0."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
 
       status = curr_cert.set(curr_row, thread_ctr_str);

       if (status != 0)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "ERROR!  "
                << "In `Scan_Parse_Parameter_Type::show_certificates':"
                << endl 
                << "`x509_Cert_Type::set' failed, returning " << status << "."
                << endl
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           temp_strm.str("");

           memset(buffer, 0, buffer_size);
           strcpy(buffer, "SHOW CERTIFICATE RESPONSE 1");

           ++errors_occurred;

           return 1;

       }  /* |if (status != 0)|  */

@q ****** (6) @>

#if 0 
#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::show_certificates':"
                << endl 
                << "`x509_Cert_Type::set' succeeded, returning 0."
                << endl;

           curr_cert.show("curr_cert:");

           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
#endif 

       cert_vector.push_back(curr_cert);
 
@q ****** (6) @>

       curr_cert.clear();

   }  /* |for|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "cert_vector.size() == " << cert_vector.size() << endl;

       if (cert_vector.size() > 0)
          cerr << "Showing `cert_vector':"
               << endl;

       for (vector<X509_Cert_Type>::iterator iter = cert_vector.begin();
            iter != cert_vector.end();
            ++iter)
       {
           iter->show();

           cerr << "`iter->output()':"
                << endl
                << iter->output()
                << endl;

       }  /* |for|  */

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

   temp_strm.str("");

   for (vector<X509_Cert_Type>::iterator iter = cert_vector.begin();
        iter != cert_vector.end();
        ++iter)
   {

       temp_strm << "SHOW CERTIFICATE RESPONSE 0 " << iter->output()
                 << " ";

   }  /* |for|  */

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::show_certificates':"
            << endl 
            << "`temp_strm.str()' == " 
            << endl
            << temp_strm.str()
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

   if (result)
   {
      mysql_free_result(result);

      result = 0;
   }

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

   if (temp_strm.str().length() >= buffer_size)
   {
@q ****** (6) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::show_certificates':"
                << endl 
                << "`temp_strm.str()length()' == " << temp_strm.str().length() << " "
                << "(>= `buffer_size == " << buffer_size << ")"
                << endl
                << "Storing contents of `temp_strm.str()' in a temporary file."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

      char temp_filename[] = "/tmp/gwirdsif.XXXXXX";

      errno = 0;
      int fd = mkstemp(temp_filename);

      if (fd == -1)
      {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "ERROR!  "
                << "In `Scan_Parse_Parameter_Type::show_certificates':"
                << endl 
                << "`mkstemp' failed, returning -1:"
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           temp_strm.str("");

           memset(buffer, 0, buffer_size);
           strcpy(buffer, "SHOW CERTIFICATE RESPONSE 1");

           ++errors_occurred;

           return 1;

      }  /* |if (fd == -1)|  */

#if DEBUG_COMPILE
      else if (DEBUG)
      {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "  "
                << "In `Scan_Parse_Parameter_Type::show_certificates':"
                << endl 
                << "`mkstemp' succeeded.  `temp_filename' == " << temp_filename << "."
                << endl;
           unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

      temp_file_vector.push_back(temp_filename);

@q ****** (6) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

      errno = 0;
      status = write(fd, temp_strm.str().c_str(), temp_strm.str().length());

      if (status <= 0)
      {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "ERROR!  "
                << "In `Scan_Parse_Parameter_Type::show_certificates':"
                << endl 
                << "`write' failed, returning " << status;

            if (status == -1)
                cerr << ":" << endl << strerror(errno)
                    << endl;
            else if (status == 0)
               cerr << " (no bytes written)."
                << endl;

            cerr << "Failed to write to file `" << temp_filename << "'."
                 << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           temp_strm.str("");

           memset(buffer, 0, buffer_size);
           strcpy(buffer, "SHOW CERTIFICATE RESPONSE 1");

           ++errors_occurred;

           return 1;


      }   /* |if (status <= 0)|  */

#if DEBUG_COMPILE
      else if (DEBUG)
      {
          lock_cerr_mutex(); 
          cerr << thread_ctr_str << "  "
               << "In `Scan_Parse_Parameter_Type::show_certificates':"
               << endl 
               << "`write' succeeded.  Wrote " << status << " "
               << "bytes to file `" << temp_filename << "'."
               << endl;
          unlock_cerr_mutex(); 

      }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

      close(fd);
      fd = 0;

      filename = temp_filename;

      memset(buffer, 0, buffer_size);


@q ****** (6) @>

   }  /* |if (temp_strm.str().length() >= buffer_size)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

   else
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_ctr_str << "In `Scan_Parse_Parameter_Type::show_certificates':"
                << endl 
                << "`temp_strm.str().length()' == " << temp_strm.str().length() << " "
                << "(< `buffer_size == " << buffer_size << ")"
                << endl
                << "Not storing contents of `temp_strm.str()' in a temporary file."
                << endl
                << "Copying them to `buffer'."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       strncpy(buffer, temp_strm.str().c_str(), temp_strm.str().length());
   }

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_ctr_str << "Exiting `Scan_Parse_Parameter_Type::show_certificates' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 



   return 0;

@q ***** (5) @>

}  /* End of |Scan_Parse_Parameter_Type::show_certificates| definition  */


@q *** (3) get privileges gwirdsif.  (|get_privileges_gwirdsif|).  @>
@ get privileges gwirdsif.  (|get_privileges_gwirdsif|).
\initials{LDF 2013.05.16.}

\LOG
\initials{LDF 2013.05.16.}
Added this function definition.  The declaration is in \filename{scprpmtp.web}.

\initials{LDF 2014.02.18.}
Renamed this function.  Old name:  |get_privileges|.  
New name:  |get_privileges_gwirdsif|.  About to add 
|Scan_Parse_Parameter_Type::get_privileges_gwirdcli|.
\par
Added code for querying the database for fields added since I wrote this function and
setting the corresponding privileges.
\ENDLOG

@q **** (4) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=
int
Scan_Parse_Parameter_Type::get_privileges_gwirdsif(int curr_user_id, unsigned int *privs)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   int status = 0;

#if DEBUG_COMPILE  
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "Entering `Scan_Parse_Parameter_Type::get_privileges_gwirdsif'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   if (!is_gwirdsif)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] WARNING!  "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
            << endl
            << "`is_gwirdsif' == `false'.  This function is only meant to be used by the server "
            << "program `gwirdsif'."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++warnings_occurred;

       return 1;

   }  /* |if (!is_gwirdsif)|  */


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

   unsigned int temp_privileges = 0U;


   bool set_privileges;  /* If a value $> 0$ is passed for |curr_user_id|, 
                            then we don't want to set |this->privileges|.  
                            Otherwise, we do.
                            \initials{LDF 2013.05.16.}
                         */

   if (curr_user_id <= 0)
   {
      curr_user_id = user_id;
      set_privileges = true;
   }
   else
      set_privileges = false;

   if (curr_user_id <= 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
            << endl
            << "`curr_user_id' == " << curr_user_id << " (<= 0)."
            << endl 
            << "User unknown.  Can't retrieve privileges."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (curr_user_id <= 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

   MYSQL_RES *result = 0;
   unsigned int row_ctr;
   unsigned int field_ctr;
   MYSQL_ROW curr_row;

   stringstream sql_strm;

   sql_strm << "select distinct superuser, delegate, add_groups, delete_groups, "
            << "delete_handles, "
            << "delete_handle_values, delete_hs_admin_handle_values, "
            << "delete_last_hs_admin_handle_value, undelete_handle_values, "
            << "show_user_info, show_groups, "
            << "show_certificates, show_distinguished_names, show_privileges, "
            << "pull_request_self, pull_request_group, pull_request_all "
            << "from gwirdsif.Privileges where user_id = " << curr_user_id;

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);                  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
            << status << "."
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to retrieve privileges for user " << curr_user_id << "."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
           mysql_free_result(result);
       }

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
            << endl
            << "`row_ctr' == " << row_ctr
            << endl
            << "`field_ctr' == " << field_ctr
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

   if (row_ctr == 0)
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned 0 rows."
                << endl
                << "No entry for user " << curr_user_id << " in database table "
                << "gwirdsif.Privileges'."
                << endl 
                << "Exiting function successfully with return value 2."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (set_privileges)
          privileges = 0U;

       if (privs)
          *privs = 0U;

       return 2;

   }  /* |if (row_ctr == 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

   else if (row_ctr > 1)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] WARNING!  "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned " 
            << row_ctr << " rows (> 1)."
            << endl
            << "This shouldn't ever happen."
            << endl 
            << "Will use the data from the first row.  Continuing."
            << endl;
       unlock_cerr_mutex(); 

       ++warnings_occurred;

   }  /* |if (row_ctr > 1)|  */


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

   if ((curr_row = mysql_fetch_row(result)) == 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
            << endl 
            << "`mysql_fetch_row' failed:"
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       ++errors_occurred;

       return 1;

   }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
            << endl 
            << "`mysql_fetch_row' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

    field_ctr = 0;

    unsigned long temp_val = 0UL;

@q ****** (6) superuser.  @>

@ superuser.
\initials{LDF 2013.05.16.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {
           temp_privileges = ~0U;

           bitset<sizeof(unsigned int) * 8> temp_bitset(temp_privileges);

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "User " << curr_user_id << " has \"superuser\" privilege."
                    << endl
                    << "`temp_privileges' == " << temp_bitset
                    << endl
                    << "Skipping to `END_ASSIGN' label, because there's no "
                    << "need to check other fields."
                    << endl;
               
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


           goto END_ASSIGN;  /* Don't bother checking the other fields 
                                if the user has the ``superuser'' privilege.
                                \initials{LDF 2013.05.16.}  */ 


       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"superuser\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
       
    }  /* |else |  */

@q ******* (7) @>

@q ****** (6) delegate.  @>

@ delegate.
\initials{LDF 2013.05.16.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"delegate\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= DELEGATE_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"delegate\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) add groups.  @>

@ add groups.
\initials{LDF 2014.02.18.}

\LOG
\initials{LDF 2014.02.18.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"add_groups\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= ADD_GROUPS_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"add_groups\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) delete groups.  @>

@ delete groups.
\initials{LDF 2014.02.18.}

\LOG
\initials{LDF 2014.02.18.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"delete_groups\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= DELETE_GROUPS_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"delete_groups\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>




@q ****** (6) delete_handles.  @>

@ |delete_handles|.
\initials{LDF 2013.07.04.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"delete_handles\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= DELETE_HANDLES_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"delete_handles\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) delete_handle_values.  @>

@ |delete_handle_values|.
\initials{LDF 2013.09.12.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"delete_handle_values\" privilege for user " 
                    << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= DELETE_HANDLE_VALUES_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"delete_handle_values\" privilege for user " 
                 << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) delete_hs_admin_handle_values.  @>

@ |delete_hs_admin_handle_values|.
\initials{LDF 2013.09.12.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"delete_hs_admin_handle_values\" privilege for user " 
                    << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= DELETE_HS_ADMIN_HANDLE_VALUES_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"delete_hs_admin_handle_values\" privilege for user " 
                 << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) delete_last_hs_admin_handle_value.  @>

@ |delete_last_hs_admin_handle_value|.
\initials{LDF 2013.09.12.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"delete_last_hs_admin_handle_value\" privilege for user " 
                    << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= DELETE_LAST_HS_ADMIN_HANDLE_VALUE_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"delete_last_hs_admin_handle_value\" privilege for user " 
                 << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) undelete_handle_values.  @>

@ |undelete_handle_values|.
\initials{LDF 2013.09.12.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"undelete_handle_values\" privilege for user " 
                    << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= UNDELETE_HANDLE_VALUES_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"undelete_handle_values\" privilege for user " 
                 << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) show user info (|show_user_info|).  @>

@ show user info (|show_user_info|).
\initials{LDF 2013.05.17.}

\LOG
\initials{LDF 2013.05.17.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"show user info\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= SHOW_USER_INFO_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"show user info\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) show groups (|show_groups|).  @>

@ show groups (|show_groups|).
\initials{LDF 2013.06.05.}

\LOG
\initials{LDF 2013.06.05.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"show groups\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= SHOW_GROUPS_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"show groups\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>




@q ****** (6) show certificates.  @>

@ show certificates.
\initials{LDF 2013.05.16.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"show certificates\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= SHOW_CERTIFICATES_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"show certificates\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) show distinguished names.  @>

@ show distinguished names.
\initials{LDF 2013.05.16.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"show distinguished names\" privilege for user " 
                    << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= SHOW_DISTINGUISHED_NAMES_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"show distinguished names\" privilege for user " 
                 << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) show privileges.  @>

@ show privileges.
\initials{LDF 2013.05.16.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"show privileges\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= SHOW_PRIVILEGES_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"show privileges\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) pull request self.  @>

@ pull request self.
\initials{LDF 2014.02.18.}

\LOG
\initials{LDF 2014.02.18.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"pull request self\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= PULL_REQUEST_SELF_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"pull request self\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) pull request group.  @>

@ pull request group.
\initials{LDF 2014.02.18.}

\LOG
\initials{LDF 2014.02.18.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"pull request group\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= PULL_REQUEST_GROUP_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"pull request group\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) pull request all.  @>

@ pull request all.
\initials{LDF 2014.02.18.}

\LOG
\initials{LDF 2014.02.18.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"pull request all\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= PULL_REQUEST_ALL_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdsif':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"pull request all\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>




@q ****** (6) @>

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>=

END_ASSIGN:   

   if (privs)
     *privs = temp_privileges;

   if (set_privileges)
      privileges = temp_privileges;

   mysql_free_result(result);

   result = 0;

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr 
            << "] Exiting `Scan_Parse_Parameter_Type::get_privileges_gwirdsif' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   if (result)
      mysql_free_result(result);
  
   return 0;
 
@q ***** (5) @>
 
}  /* |Scan_Parse_Parameter_Type::get_privileges_gwirdsif|  */

@q **** (4) @>

@q *** (3) get privileges gwirdcli.  (|get_privileges_gwirdcli|).  @>
@ get privileges gwirdcli.  (|get_privileges_gwirdcli|).
\initials{LDF 2014.02.18.}

\LOG
\initials{LDF 2014.02.18.}
Added this function definition.  The declaration is in \filename{scprpmtp.web}.
\ENDLOG

@q **** (4) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=
int
Scan_Parse_Parameter_Type::get_privileges_gwirdcli(int curr_user_id, unsigned int *privs)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   int status = 0;

#if DEBUG_COMPILE  
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "Entering `Scan_Parse_Parameter_Type::get_privileges_gwirdcli'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   if (!is_gwirdcli)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] WARNING!  "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
            << endl
            << "`is_gwirdcli' == `false'.  This function is only meant to be used by the client "
            << "program `gwirdcli'."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++warnings_occurred;

       return 1;

   }  /* |if (!is_gwirdcli)|  */


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

   unsigned int temp_privileges = 0U;


   bool set_privileges;  /* If a value $> 0$ is passed for |curr_user_id|, 
                            then we don't want to set |this->privileges|.  
                            Otherwise, we do.
                            \initials{LDF 2013.05.16.}
                         */

   if (curr_user_id <= 0)
   {
      curr_user_id = user_id;
      set_privileges = true;
   }
   else
      set_privileges = false;

   if (curr_user_id <= 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
            << endl
            << "`curr_user_id' == " << curr_user_id << " (<= 0)."
            << endl 
            << "User unknown.  Can't retrieve privileges."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       ++errors_occurred;

       return 1;

   }  /* |if (curr_user_id <= 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

   MYSQL_RES *result = 0;
   unsigned int row_ctr;
   unsigned int field_ctr;
   MYSQL_ROW curr_row;

   stringstream sql_strm;

   sql_strm << "select distinct superuser, delegate, add_groups, delete_groups, "
            << "show_user_info, show_groups, "
            << "show_certificates, show_distinguished_names, show_privileges, "
            << "pull_response_self, pull_response_group, pull_response_all "
            << "from gwirdcli.Privileges_Gwirdcli where user_id = " 
            << curr_user_id;

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] sql_strm.str() == " << sql_strm.str() << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

   status = submit_mysql_query(sql_strm.str(), result, &row_ctr, &field_ctr);                  

   if (status != 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' failed, returning " 
            << status << "."
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to retrieve privileges for user " << curr_user_id << "."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
           mysql_free_result(result);
       }

       ++errors_occurred;

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' succeeded."
            << endl
            << "`row_ctr' == " << row_ctr
            << endl
            << "`field_ctr' == " << field_ctr
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

   if (row_ctr == 0)
   {
#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "]  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned 0 rows."
                << endl
                << "No entry for user " << curr_user_id << " in database table "
                << "gwirdcli.Privileges'."
                << endl 
                << "Exiting function successfully with return value 2."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (set_privileges)
          privileges = 0U;

       if (privs)
          *privs = 0U;

       return 2;

   }  /* |if (row_ctr == 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

   else if (row_ctr > 1)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] WARNING!  "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
            << endl 
            << "`Scan_Parse_Parameter_Type::submit_mysql_query' returned " 
            << row_ctr << " rows (> 1)."
            << endl
            << "This shouldn't ever happen."
            << endl 
            << "Will use the data from the first row.  Continuing."
            << endl;
       unlock_cerr_mutex(); 

       ++warnings_occurred;

   }  /* |if (row_ctr > 1)|  */


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

   if ((curr_row = mysql_fetch_row(result)) == 0)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] ERROR!  "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
            << endl 
            << "`mysql_fetch_row' failed:"
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       mysql_free_result(result);

       ++errors_occurred;

       return 1;

   }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr << "] "
            << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
            << endl 
            << "`mysql_fetch_row' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

    field_ctr = 0;

    unsigned long temp_val = 0UL;

@q ****** (6) superuser.  @>

@ superuser.
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {
           temp_privileges = ~0U;

           bitset<sizeof(unsigned int) * 8> temp_bitset(temp_privileges);

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "User " << curr_user_id << " has \"superuser\" privilege."
                    << endl
                    << "`temp_privileges' == " << temp_bitset
                    << endl
                    << "Skipping to `END_ASSIGN' label, because there's no "
                    << "need to check other fields."
                    << endl;
               
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


           goto END_ASSIGN;  /* Don't bother checking the other fields 
                                if the user has the ``superuser'' privilege.
                                \initials{LDF 2013.05.16.}  */ 


       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"superuser\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
       
    }  /* |else |  */

@q ******* (7) @>

@q ****** (6) delegate.  @>

@ delegate.
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"delegate\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= DELEGATE_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"delegate\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) add_groups.  @>

@ |add_groups|.
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"add_groups\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= ADD_GROUPS_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"add_groups\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) delete_groups.  @>

@ |delete_groups|.
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"delete_groups\" privilege for user " 
                    << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= DELETE_GROUPS_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"delete_groups\" privilege for user " 
                 << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) delete_hs_admin_handle_values.  @>

@ |delete_hs_admin_handle_values|.
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"delete_hs_admin_handle_values\" privilege for user " 
                    << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= DELETE_HS_ADMIN_HANDLE_VALUES_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"delete_hs_admin_handle_values\" privilege for user " 
                 << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) delete_last_hs_admin_handle_value.  @>

@ |delete_last_hs_admin_handle_value|.
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {

       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"delete_last_hs_admin_handle_value\" privilege for user " 
                    << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= DELETE_LAST_HS_ADMIN_HANDLE_VALUE_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"delete_last_hs_admin_handle_value\" privilege for user " 
                 << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) show user info (|show_user_info|).  @>

@ show user info (|show_user_info|).
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"show user info\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= SHOW_USER_INFO_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"show user info\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) show groups (|show_groups|).  @>

@ show groups (|show_groups|).
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"show groups\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= SHOW_GROUPS_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"show groups\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) show certificates.  @>

@ show certificates.
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"show certificates\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= SHOW_CERTIFICATES_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"show certificates\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) show distinguished names.  @>

@ show distinguished names.
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"show distinguished names\" privilege for user " 
                    << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= SHOW_DISTINGUISHED_NAMES_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"show distinguished names\" privilege for user " 
                 << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) show privileges.  @>

@ show privileges.
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"show privileges\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= SHOW_PRIVILEGES_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"show privileges\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) pull response self.  @>

@ pull response self.
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"pull response self\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= PULL_RESPONSE_SELF_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"pull response self\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) pull response group.  @>

@ pull response group.
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"pull response group\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= PULL_RESPONSE_GROUP_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"pull response group\" privilege for user " 
                 << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) pull response all.  @>

@ pull response all.
\initials{LDF 2014.02.18.}

@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

@q ******* (7) @>

    ++field_ctr;

    if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)
    {
       errno = 0;
       temp_val = strtoul(curr_row[field_ctr], 0, 10);

       if (temp_val == ULONG_MAX)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] ERROR!  "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' failed, returning `ULONG_MAX'."
                << endl
                << strerror(errno)
                << endl 
                << "Exiting function unsuccessfully with return value 1."
                << endl;
           unlock_cerr_mutex(); 

           mysql_free_result(result);

           ++errors_occurred;

           return 1;

       }  /* |if (temp_val == ULONG_MAX)|  */

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "[Thread " << thread_ctr << "] "
                << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                << endl 
                << "`strtoul' succeeded, returning " << temp_val << "."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

       if (temp_val > 0)
       {

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "[Thread " << thread_ctr << "] "
                    << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                    << endl 
                    << "`temp_val' == " << temp_val << " (> 0)"
                    << endl
                    << "Setting \"pull response all\" privilege for user " << curr_user_id << "."
                    << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           temp_privileges |= PULL_RESPONSE_ALL_PRIVILEGE;

       }  /* |if (temp_val)|  */


    }  /* |if (curr_row[field_ctr] && strlen(curr_row[field_ctr]) > 0)|  */

@q ******* (7) @>

    else 
    {
#if DEBUG_COMPILE
        if (DEBUG)
        {
            lock_cerr_mutex(); 
            cerr << "[Thread " << thread_ctr << "] "
                 << "In `Scan_Parse_Parameter_Type::get_privileges_gwirdcli':"
                 << endl 
                 << "`curr_row[" << field_ctr << "]' is NULL or empty."
                 << endl
                 << "Not setting \"pull response all\" privilege for user " << curr_user_id << "."
                 << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
        
    }

@q ******* (7) @>

@q ****** (6) @>

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>=

END_ASSIGN:   

   if (privs)
     *privs = temp_privileges;

   if (set_privileges)
      privileges = temp_privileges;

   mysql_free_result(result);

   result = 0;

#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "[Thread " << thread_ctr 
            << "] Exiting `Scan_Parse_Parameter_Type::get_privileges_gwirdcli' "
            << "successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   if (result)
      mysql_free_result(result);
  
   return 0;
 
@q ***** (5) @>
 
}  /* |Scan_Parse_Parameter_Type::get_privileges_gwirdcli|  */



@q *** (3) Set user info.  (|set_user_info|).  @>
@ Set user info.  (|set_user_info|).
\initials{LDF 2013.05.19.}

\LOG
\initials{LDF 2013.05.19.}
Added this function definition.  The declaration is in \filename{scprpmtp.web}.
\ENDLOG

@q **** (4) @>

@<|Scan_Parse_Parameter_Type::set_user_info| definition@>=

int
Scan_Parse_Parameter_Type::set_user_info(User_Info_Type &user_info) const
{

   user_info.user_id                            = user_id;      
   user_info.username                           = username;
   user_info.certificate                        = user_cert;
   user_info.distinguished_name                 = distinguished_name;
   user_info.privileges                         = privileges;

   user_info.irods_password_encrypted           = irods_password_encrypted;
   user_info.irods_password_encrypted_timestamp = irods_password_encrypted_timestamp;
   user_info.irods_current_dir                  = irods_current_dir;
   user_info.irods_homedir                      = irods_homedir;
   user_info.irods_zone                         = irods_zone;
   user_info.irods_default_resource             = irods_default_resource;

   user_info.default_handle_prefix_id           = default_handle_prefix_id;
   user_info.default_handle_prefix              = default_handle_prefix;
   user_info.default_institute_id               = default_institute_id;
   user_info.default_institute_name             = default_institute_name;

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::set_user_info| definition  */

@q *** (3) Show privileges.  (|show_privileges|).  @>
@ Show privileges.  (|show_privileges|).
\initials{LDF 2013.05.22.}

\LOG
\initials{LDF 2013.05.22.}
Added this function definition.  
The declaration is in \filename{scprpmtp.web}.
\ENDLOG

@q **** (4) @>

@<|Scan_Parse_Parameter_Type::show_privileges| definition@>=
int
Scan_Parse_Parameter_Type::show_privileges(unsigned int privileges, ostream *strm, bool verbose)
{

     stringstream temp_strm;

     temp_strm << "privileges:"
               << endl;

     if (verbose)
     {
         bitset<sizeof(unsigned int) * 8> b(privileges);
      
         temp_strm << privileges << " (decimal) " 
                   << oct << privileges << " (octal) " << hex << privileges << " (hexadecimal)"
                   << dec 
                   << endl 
                   << b << " (binary)"
                   << endl;
     }

     temp_strm << "   superuser:                          " 
               << ((privileges & SUPERUSER_PRIVILEGE) ? 1 : 0) << " (  1)"
               << endl 
               << "   delegate:                           " 
               << ((privileges & DELEGATE_PRIVILEGE) ? 1 : 0) << " (  2)"
               << endl 
               << "   delete_handles:                     " 
               << ((privileges & DELETE_HANDLES_PRIVILEGE) ? 1 : 0) << " (  4)"
               << endl 

               << "   delete_handle_values:               " 
               << ((privileges & DELETE_HANDLE_VALUES_PRIVILEGE) ? 1 : 0) << " (  8)"
               << endl 

               << "   delete_hs_admin_handle_values:      " 
               << ((privileges & DELETE_HS_ADMIN_HANDLE_VALUES_PRIVILEGE) ? 1 : 0) << " ( 16)"
               << endl 

               << "   delete_last_hs_admin_handle_value:  " 
               << ((privileges & DELETE_LAST_HS_ADMIN_HANDLE_VALUE_PRIVILEGE) ? 1 : 0) << " ( 32)"
               << endl 

               << "   undelete_handle_values:             " 
               << ((privileges & UNDELETE_HANDLE_VALUES_PRIVILEGE) ? 1 : 0) << " ( 64)"
               << endl 

               << "   show_user_info:                     " 
               << ((privileges & SHOW_USER_INFO_PRIVILEGE) ? 1 : 0) << " (128)"
               << endl 
               << "   show_groups:                        " 
               << ((privileges & SHOW_GROUPS_PRIVILEGE) ? 1 : 0) << " (256)"
               << endl          
               << "   show_certificates:                  " 
               << ((privileges & SHOW_CERTIFICATES_PRIVILEGE)  ? 1 : 0) << " (512)"
               << endl          
               << "   show_distinguished_names:           " 
               << ((privileges & SHOW_DISTINGUISHED_NAMES_PRIVILEGE)
                  ? 1 : 0) << " (1024)"
               << endl          
               << "   show_privileges:                    " 
               << ((privileges & SHOW_PRIVILEGES_PRIVILEGE) ? 1 : 0) << " (2048)"
               << endl          
               << "   pull_request_self:                  " 
               << (((privileges & PULL_REQUEST_SELF_PRIVILEGE) > 0U) ? 1 : 0) << " (4096)"
               << endl          
               << "   pull_request_group:                 " 
               << (((privileges & PULL_REQUEST_GROUP_PRIVILEGE) > 0U) ? 1 : 0) << " (8192)"
               << endl          
               << "   pull_request_all:                   " 
               << (((privileges & PULL_REQUEST_ALL_PRIVILEGE) > 0U) ? 1 : 0) << " (16384)"
               << endl;          
          
   if (strm != 0)
      *strm << temp_strm.str();
   else
      cerr << temp_strm.str();

   return 0;

}  /* End of |Scan_Parse_Parameter_Type::show_privileges| definition  */

@q *** (3) Get highest value (|get_highest_value|).  @>
@ Get highest value (|get_highest_value|).  
\initials{LDF 2013.06.06.}

Get the highest value of column |column| from database table |table|
and store it in |val|.  If |bool incr == true|, increment it before 
returning.  |incr| is optional, with default |false| 
(|val| is not incremented).
This function returns 0 upon success, otherwise 1.
\initials{LDF 2013.06.06.}

\LOG
\initials{LDF 2013.06.06.}
Added this function definition.  The declaration is in \filename{scprpmtp.web}.
\ENDLOG

@q **** (4) Definition  @>

@<|Scan_Parse_Parameter_Type::get_highest_value| definition@>=

int
Scan_Parse_Parameter_Type::get_highest_value(MYSQL *mysql_ptr,
                                             string table, 
                                             string column, 
                                             unsigned long int &val, 
                                             bool incr)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 
   int status = 0;

   stringstream sql_strm;

   MYSQL_RES *result = 0;
   MYSQL_ROW curr_row;
   unsigned int row_ctr;
   unsigned int field_ctr;

   stringstream temp_strm;

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `Scan_Parse_Parameter_Type::get_highest_value'." 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_highest_value| definition@>=

   sql_strm << "select " << column << " from " << table << " "
            << "order by " << column << " desc limit 1";

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Scan_Parse_Parameter_Type::get_highest_value':" 
            << endl 
            << "sql_strm.str() == " << sql_strm.str() 
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_highest_value| definition@>=

   status = ::submit_mysql_query(sql_strm.str().c_str(), result, mysql_ptr, &row_ctr, &field_ctr);

   if (status != 0)
   {
       cerr << "ERROR!  In `Scan_Parse_Parameter_Type::get_highest_value':"
            << endl
            << "`submit_mysql_query' failed, returning " << status << "."
            << endl
            << "Failed to retrieve highest value of `" << table << "." << column << "'."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
          mysql_free_result(result);
       }

       return 1;

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Scan_Parse_Parameter_Type::get_highest_value':"
            << endl
            << "`submit_mysql_query' succeeded, returning 0."
            << endl
            << "Retrieved highest value of `" << table << "." << column << "' successfully."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_highest_value| definition@>=

   if ((curr_row = mysql_fetch_row(result)) == 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Scan_Parse_Parameter_Type::get_highest_value':"
            << endl 
            << "`mysql_fetch_row' failed:"
            << endl
            << mysql_error(mysql_ptr)
            << endl 
            << "Failed to read highest value of `" << table << "." << column << "' from "
            << "database."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
          mysql_free_result(result);
       }

       return 1;

   }  /* |if (curr_row = mysql_fetch_row(result) == 0)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Scan_Parse_Parameter_Type::get_highest_value':"
            << endl 
            << "`mysql_fetch_row' succeeded."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_highest_value| definition@>=

   if (curr_row[0] == 0 || strlen(curr_row[0]) == 0)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Scan_Parse_Parameter_Type::get_highest_value':"
            << endl 
            << "`curr_row[0]' is NULL or empty."
            << endl 
            << "Failed to read highest value of `" << table << "." << column << "' from "
            << "database.  Can't set `val'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
          mysql_free_result(result);
       }

       return 1;

   }  /* |if (curr_row[0] == 0 || strlen(curr_row[0]) == 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "curr_row[0] == " << curr_row[0] << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_highest_value| definition@>=

   errno = 0;
   val = strtoul(curr_row[0], 0, 10);

   if (val == ULONG_MAX)
   {
       lock_cerr_mutex(); 
       cerr << "ERROR!  In `Scan_Parse_Parameter_Type::get_highest_value':"
            << endl 
            << "`strtoul' failed, returning `ULONG_MAX':"
            << endl 
            << "Error:  " << strerror(errno)
            << endl 
            << "Failed to convert highest value of `" << table << "." << column << "' from "
            << "database.  Failed to set `val'."
            << endl 
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       if (result)
       {
          mysql_free_result(result);
       }

       return 1;

   }  /* |if (val == ULONG_MAX)|  */

#if DEBUG_COMPILE 
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Scan_Parse_Parameter_Type::get_highest_value':  "
            << "`val' == " << val << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   if (incr)
   {
      ++val;  /* Increment |val|.  */

#if DEBUG_COMPILE 
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "In `Scan_Parse_Parameter_Type::get_highest_value':  "
                << "Incremented `val'.  New value:  " << val << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |if (incr)|  */
#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `Scan_Parse_Parameter_Type::get_highest_value':  "
            << "Not incrementing `val' == " << val << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_highest_value| definition@>=

   mysql_free_result(result);
   result = 0;

   sql_strm.str("");

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Exiting `Scan_Parse_Parameter_Type::get_highest_value' "
            << "successfully with return value 0."
            << endl; 
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

    return 0;

}  /* End of |Scan_Parse_Parameter_Type::get_highest_value| definition  */

@q *** (3) Get input (|get_input|).   @>
@ Get input (|get_input|).
\initials{LDF 2013.07.11.}

\LOG
\initials{LDF 2013.07.11.}
Added this function definition.  The declaration is in \filename{scprpmtp.web}.
\ENDLOG

@q **** (4) Definition  @>

@<|Scan_Parse_Parameter_Type::get_input| definition@>=

int
Scan_Parse_Parameter_Type::get_input(void)
{
@q ***** (5) @>

    bool DEBUG = false;  /* |true|  */ 

    set_debug_level(DEBUG, 0, 0);

    int status;

    char buffer[BUFFER_SIZE];

    memset(buffer, 0, BUFFER_SIZE);

    int char_ctr = 0;

    int fd;
 
    char temp_filename[21] = "/tmp/gwirdcli.XXXXXX";

    string thread_str;

    stringstream temp_strm;

    bool write_to_file = false;

    ofstream out_strm;

    if (thread_ctr >= 0)
    {
        temp_strm << "[Thread " << thread_ctr << "] ";
        thread_str = temp_strm.str();
        temp_strm.str("");
   }


#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str << "Entering `Scan_Parse_Parameter_Type::get_input'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */     

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_input| definition@>=

    if (!is_gwirdcli)
    {
        lock_cerr_mutex(); 
        cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_input':"
             << endl
             << "`is_gwirdcli' == `false'.  Not `gwirdcli'.  This is currently not permitted."
             << endl 
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        ++errors_occurred;

        return 1;
    
    }

@q ***** (5) @>

@ If standard input is connected to a terminal, |EOF| will normally never be read.
However, it probably will occur if it's connected to a pipe.  If |EOF| is read,
this function exits with return value 6.
\par
If the output of \.{echo} or \.{cat} has been piped to \.{gwirdcli} using the shell, 
it will not be possible to get additional input via standarad input through a terminal.  
In this case, it doesn't make sense to set |terminate_on_end_input = false|.  However,
it does no harm, since this function simply exits.
\par
@:TODO@> !! TODO: It would be possible to change this function so that it could 
read from other sources, e.g., a file descriptor connected to a pipe.  However, I don't
think this feature is needed at the present time.

@<|Scan_Parse_Parameter_Type::get_input| definition@>=

    if (cin.eof())
    {
#if DEBUG_COMPILE
       if (DEBUG)
       {
            lock_cerr_mutex(); 
            cerr << "In `Scan_Parse_Parameter_Type::get_input:"
                 << endl 
                 << "Read EOF.  Exiting successfully with return value 6." << endl;
            unlock_cerr_mutex();  
       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

        return 6;
    }

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_input| definition@>=

    if (data_filename == "-")
       data_filename = "";

    if (!data_filename.empty())
    {
        lock_cerr_mutex(); 
        cerr << thread_str << "WARNING!  In `Scan_Parse_Parameter_Type::get_input':"
             << endl
             << "`data_filename' == " << data_filename
             << endl 
             << "`data_filename' is not empty or \"-\".  "
             << "Not getting input from standard input."
             << endl
             << "Exiting function unsuccessfully with return value 2."
             << endl;
        unlock_cerr_mutex(); 

        ++warnings_occurred;

        return 2;
     
    }


@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_input| definition@>=

    if (strlen(data_buffer) > 0)
    {
        lock_cerr_mutex(); 
        cerr << thread_str << "WARNING!  In `Scan_Parse_Parameter_Type::get_input':"
             << endl
             << "`strlen(data_buffer)' == " << strlen(data_buffer) << " (> 0)"
             << endl 
             << "`data_buffer' is not empty.  Not getting input from standard input."
             << endl
             << "Exiting function unsuccessfully with return value 2."
             << endl;
        unlock_cerr_mutex(); 

        ++warnings_occurred;

        return 2;
     
    }

@q ***** (5) @>

@ If the global variable |unsigned int suppress_prompt == 0|, the prompt is
printed to standard output.  Otherwise, it's not.  If |suppress_prompt == 1|,
the prompt is suppressed, but |suppress_prompt| is set to 0 following the code
for printing the prompt.  The effect is that the prompt will only be suppressed
once.  If |suppress_prompt > 1|, it is not decremented, so that the prompt will
always be suppressed.
\initials{LDF 2013.08.29.}

\LOG
\initials{LDF 2013.08.29.}
Added code for suppressing the prompt.
\ENDLOG 

@<|Scan_Parse_Parameter_Type::get_input| definition@>=

    if (suppress_prompt == 0)
    {
       lock_cerr_mutex(); 
       lock_cout_mutex();
       cout << "Enter commands:"
            << endl 
            << "Type commands followed by <ENTER>.  Multiple lines may be entered."
            << endl 
            << "Enter a single period (`.') on a line to finish."
            << endl 
            << "Use `q' (or `Q') command to quit."
            << endl;
       unlock_cout_mutex(); 
       unlock_cerr_mutex(); 
    }
    else if (suppress_prompt == 1)
        suppress_prompt = 0;

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::get_input| definition@>=

    char_ctr = 0;

    for(;;)
    {
@q ****** (6) @>

        memset(buffer, 0, BUFFER_SIZE);

        cin.getline(buffer, BUFFER_SIZE);

@q ****** (6) @>

#if DEBUG_COMPILE
        if (DEBUG)   
        {
            lock_cerr_mutex(); 
            cerr << "`cin.gcount()' == " << cin.gcount() 
                 << endl
                 << "`cin.eof()' == " << cin.eof() << endl;

            if (cin.gcount() == 0)
                cerr << "No characters read." << endl;
            else
                cerr << "Read " << strlen(buffer) << " characters."
                     << endl 
                     << "buffer == " << buffer << endl;
            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

        if (cin.gcount() == 0 && !cin.eof())
        {
#if DEBUG_COMPILE
            if (DEBUG)   
            {
                lock_cerr_mutex(); 
                cerr << "No characters read and `cin.eof()' == `false'.  "
                     << "Continuing." << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

            continue;
        }

@q ****** (6) @>

        else if (cin.gcount() == 0 && cin.eof())
        {
#if DEBUG_COMPILE
            if (DEBUG)   
            {
                lock_cerr_mutex(); 
                cerr << "No characters read and `cin.eof()' == `true'.  Breaking." 
                     << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

            break;
        }

@q ****** (6) @>


        else if (strlen(buffer) == 1 && tolower(buffer[0]) == 'q')
        {
#if DEBUG_COMPILE
            if (DEBUG)   
            {
                lock_cerr_mutex(); 
                cerr << "Read `" << buffer[0] << "'.  Will quit." << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
 
            memset(data_buffer, 0, BUFFER_SIZE);
            data_filename = "";

            return 4;
        }

@q ****** (6) @>

        else if (strlen(buffer) == 1 && buffer[0] == '.')
        {
#if DEBUG_COMPILE
            if (DEBUG)   
            {
                lock_cerr_mutex(); 
                cerr << "Read a single period.  Breaking." << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


            break;
        }

@q ****** (6) @>
 
        else 
        {
@q ******* (7) @>

#if DEBUG_COMPILE
            if (DEBUG)   
            {
                lock_cerr_mutex(); 
                cerr << "Read " << strlen(buffer) << " characters."
                     << endl
                     << "buffer == " << buffer << endl;
                unlock_cerr_mutex(); 

            }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

            if (write_to_file)
            {
#if DEBUG_COMPILE
               if (DEBUG)  
               {
                   lock_cerr_mutex(); 
                   cerr << "`write_to_file' == `true'.  Writing to `out_strm'."
                        << endl;
                   unlock_cerr_mutex(); 

               }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

                out_strm.write(buffer, strlen(buffer));
                out_strm << endl;
            }

            else if ((char_ctr + strlen(buffer) + 1) < BUFFER_SIZE)
            {
               strcat(data_buffer, buffer);
               strcat(data_buffer, "\n");
               char_ctr += strlen(buffer) + 1;
            }
            else
            {
@q ******** (8) @>

#if DEBUG_COMPILE
                if (DEBUG)       
                {
                    lock_cerr_mutex(); 
                    cerr << "(char_ctr + strlen(buffer) + 1) >= BUFFER_SIZE:"
                         << endl
                         << "char_ctr == " << char_ctr
                         << endl 
                         << "strlen(buffer) == " << strlen(buffer)
                         << endl 
                         << "char_ctr + strlen(buffer) + 1 == " << (char_ctr + strlen(buffer) + 1)
                         << endl 
                         << "BUFFER_SIZE == " << BUFFER_SIZE
                         << endl  
                         << "(char_ctr + strlen(buffer) + 1) >= BUFFER_SIZE == " 
                         << ((char_ctr + strlen(buffer) + 1) >= BUFFER_SIZE)
                         << endl
                         << "Writing to file."
                         << endl;
                    unlock_cerr_mutex(); 

                }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */                      

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::get_input| definition@>=                

               errno = 0;
               fd = mkstemp(temp_filename);

               if (fd == -1)
               {

                   lock_cerr_mutex(); 
                   cerr << thread_str << "ERROR!  In `Scan_Parse_Parameter_Type::get_input':"
                        << endl 
                        << "`mkstemp' failed, returning -1:"
                        << endl
                        << strerror(errno)
                        << endl
                        << "Failed to create temporary file."
                        << endl
                        << "Exiting function unsuccessfully with return value 1."
                        << endl;
                    unlock_cerr_mutex(); 

                   ++errors_occurred;

                   return 1;      

               }  /* |if (fd == -1)|  */

@q ******** (8) @>

#if DEBUG_COMPILE
               else if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "In `Scan_Parse_Parameter_Type::get_input':"
                        << endl 
                        << "`mkstemp' succeeded."
                        << endl
                        << "`temp_filename' == " << temp_filename
                        << endl;
                   unlock_cerr_mutex(); 

               }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


               close(fd);  /* We just need the name.  \initials{LDF 2013.07.10.}  */
               fd = 0;

               data_filename = temp_filename;

               temp_file_vector.push_back(data_filename);

               out_strm.open(data_filename.c_str());

@q ******** (8) @>

               if (!(out_strm && out_strm.is_open()))
               {
                  lock_cerr_mutex(); 
                  cerr << thread_str
                       << "ERROR!  In `Scan_Parse_Parameter_Type::get_input':  "
                       << "`out_strm.open()' failed."
                       << endl 
                       << "Failed to open temporary output file "
                       << "`" << temp_filename << "'."
                       << endl 
                       << "Exiting function unsuccessfully with return value 1."
                       << endl;
                  unlock_cerr_mutex(); 

                  ++errors_occurred;

                  return 1;

               }  /* |if (!(out_strm && out_strm.is_open()))|  */

@q ******** (8) @>

#if DEBUG_COMPILE
               else if (DEBUG)
               {
                   lock_cerr_mutex(); 
                   cerr << thread_str << "In `Scan_Parse_Parameter_Type::get_input':"
                        << endl 
                        << "`out_strm.open()' succeeded."
                        << endl;
                   unlock_cerr_mutex(); 

               }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>

               out_strm.write(data_buffer, strlen(data_buffer));

               if (out_strm.good())
                  out_strm.write(buffer, strlen(buffer));

               if (!out_strm.good())
               {
                  lock_cerr_mutex();
                  cerr << thread_str
                       << "ERROR!  In `Scan_Parse_Parameter_Type::get_input':  "
                       << "`out_strm.write()' failed,"
                       << endl 
                       << "`out_strm.good()' == `false'."
                       << endl 
                       << "Failed to write to temporary file `" << data_filename << "'."
                       << endl
                       << "Exiting function unsuccessfully with return value 1."
                       << endl;
                  unlock_cerr_mutex(); 

                  ++errors_occurred;

                  return 1;

               }  /* |if (!out_strm.good())|  */

@q ******** (8) @>

#if DEBUG_COMPILE
              else if (DEBUG)
              {
                  lock_cerr_mutex(); 

                  unlock_cerr_mutex(); 

              }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ******** (8) @>
@
@<|Scan_Parse_Parameter_Type::get_input| definition@>=

                memset(data_buffer, 0, BUFFER_SIZE);

                write_to_file = true;

@q ******** (8) @>

            }  /* |else|  */

@q ******* (7) @>

        }  /* |else|  */

@q ****** (6) @>
            
        if (cin.eof())
        {
#if DEBUG_COMPILE
        if (DEBUG)   
        {
            lock_cerr_mutex(); 
            cerr << "`cin.eof()' == `true'." 
                 << endl
                 << "Breaking."
                 << endl;


            unlock_cerr_mutex(); 

        }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


           cin.clear();
           break;
        }  

@q ****** (6) @>

    }  /* |for|  */

@q ***** (5) @>

    if (write_to_file)
       out_strm.close();   


@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Exiting `Scan_Parse_Parameter_Type::get_input' successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */     

    
    return 0;

@q ***** (5) @>

}  /* End of |Scan_Parse_Parameter_Type::get_input| definition  */ 

@q *** (3) Mark iRODS objects for deletion.  @>
@ Mark iRODS objects for deletion.
\initials{LDF 2013.08.07.}

\LOG
\initials{LDF 2013.08.07.}
Added this function.
\ENDLOG

@q **** (4) Definition  @>
@
@<|Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition@>=
int
Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion(Response_Type &response, 
                                                           char *buffer_ptr, 
                                                           size_t buffer_size)
{
@q ***** (5) @>

   bool DEBUG = false;  /* |true|  */ 
   set_debug_level(DEBUG, 0, 0); 

   int status;

   size_t pos;

   stringstream temp_strm;

   string thread_str;

   bool delete_from_archive;
   bool delete_from_database;

   if (thread_ctr > 0)
   {
       temp_strm << "[Thread " << thread_ctr << "] ";
       thread_str = temp_strm.str();
       temp_strm.str("");

   }

@q ***** (5) @>


   if (response.options & 2U && response.options & 4U)
      delete_from_database = true;

   if (response.options & 4U)
       delete_from_archive = false;
   else
       delete_from_archive = true;
 
@q ***** (5) @>


#if DEBUG_COMPILE 
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "Entering `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion'."
            << endl;

       response.show("response:");

       if (response.options & 2U && response.options & 4U)
       {
           cerr << "`database' option and `database-only' options are both set."
                << endl
                << "This is an error.  It will be handled below and this function "
                << "will exit unsuccessfully."
                << endl; 
 
      }

       else if (response.options & 2U)
       {
           cerr << "`database' option is set."
                << endl
                << "Will delete entry/entries for iRODS object(s) "
                << "from `gwirdsif.Irods_Objects' database table"
                << endl 
                << "and AVUs from `gwirdsif.Irods_AVUs' database table."
                << endl;
       }
       else if (response.options & 4U)
       {
           cerr << "`database-only' option is set."
                << endl 
                << "Will delete entry/entries for iRODS object(s) "
                << "from `gwirdsif.Irods_Objects' database table"
                << endl 
                << "and AVUs from `gwirdsif.Irods_AVUs' database table."
                << endl
                << "Will not delete iRODS object(s) from archive."
                << endl;
       }     

       cerr << "user_id == " << user_id << endl
            << "irods_env_filename == " << irods_env_filename 
            << endl;

       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 



@q ***** (5) Error handling:  `database' and `database-only' options both specified.  @>

@ Error handling:  \.{`database'} and \.{`database-only'} options both specified.  
\initials{LDF 2013.08.12.}

This should never occur, because the case is caught and handled in |yyparse|.
\initials{LDF 2013.08.12.}

\LOG
\initials{LDF 2013.08.12.}
Added this section.
\ENDLOG

@<|Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition@>=

   if (response.options & 2U && response.options & 4U)
   {

       lock_cerr_mutex(); 
       cerr << thread_str << "ERROR!  "
            << "In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
            << endl 
            << "`database' and `database-only' options are both set."
            << endl
            << "This is not permitted."
            << endl
            << "Exiting function unsuccessfully with return value 1."
            << endl;
       unlock_cerr_mutex(); 

       temp_strm.str("");

       temp_strm << "MARK IRODS_OBJECT FOR DELETION RESPONSE "
                 << GW_ERROR << " " << response.options << "U "
                 << "\"(no iRODS objects)\" "
                 << "0UL "
                 << "\"Option error: `database' and `database-only' options both specified"
                 << "This is not permitted.\"";

#if DEBUG_COMPILE
           if (DEBUG)
           {
               lock_cerr_mutex(); 
               cerr << "temp_strm.str() == " << temp_strm.str() << endl;
               unlock_cerr_mutex(); 

           }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

           strcpy(buffer_ptr, temp_strm.str().c_str());

           ++errors_occurred;

           return 1;

   }  /* |if (response.options & 2U && response.options & 4U)|  */


@q ***** (5) @>
@ 
@<|Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition@>=

   if (response.string_vector.size() == 0)
   {
        lock_cerr_mutex();
        cerr << thread_str 
             << "WARNING! In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
             << endl
             << "`response.string_vector' is empty.  No iRODS objects to mark for deletion."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex(); 

        ++warnings_occurred; 

        temp_strm.str("");

        temp_strm << "MARK IRODS_OBJECT FOR DELETION RESPONSE "
                  << GW_ERROR << " " << response.options << "U "
                  << "\"(no iRODS objects)\" "
                  << "0UL "
                  << "\"Error:  No iRODS objects found to mark for deletion\"";


        strcpy(buffer_ptr, temp_strm.str().c_str());

        return 1;

   }  /* |if (response.string_vector.size() == 0)|  */

@q ***** (5) @>
@ 
@<|Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition@>=

   Response_Type new_response;

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition@>=

   string new_flags;

   pos = response.flags.find("-f");
   
   if (pos != string::npos)
      new_flags += "-f ";

   pos = response.flags.find("-n");
   
   if (pos != string::npos)
      new_flags += "-n ";

   pos = response.flags.find("-r");
   
   if (pos != string::npos)
      new_flags += "-r ";

   pos = response.flags.find("-U");
   
   if (pos != string::npos)
      new_flags += "-U ";

   pos = response.flags.find("-v");
   
   if (pos != string::npos)
      new_flags += "-v ";

   pos = response.flags.find("-V");
   
   if (pos != string::npos)
      new_flags += "-V ";

   pos = response.flags.find("--empty");
   
   if (pos != string::npos)
      new_flags += "--empty ";

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
            << endl
            << "`new_flags' == " << new_flags
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition@>=

   vector<Irods_Object_Type> irods_object_vector;

   Irods_Object_Type curr_irods_object;

   for (vector<string>::const_iterator iter = response.string_vector.begin();
        iter != response.string_vector.end();
        ++iter)
   {
@q ****** (6) @>

         temp_strm.str("");     

         pos = iter->find('/');

         if (pos == string::npos)
            temp_strm << irods_current_dir << "/";

         temp_strm << *iter;

         curr_irods_object.set(user_id, temp_strm.str());

         status = curr_irods_object.get_from_database(mysql_ptr);
 
         if (status < 0)
         {
             lock_cerr_mutex(); 
             cerr << thread_str 
                  << "ERROR! In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
                  << endl
                  << "`Irods_Object_Type::get_from_database' failed, returning " << status << "."
                  << endl
                  << "Exiting function unsuccessfully with return value 1."
                  << endl;
             unlock_cerr_mutex();              

             ++errors_occurred; 

             temp_strm.str("");

             temp_strm << "MARK IRODS_OBJECT FOR DELETION RESPONSE "
                       << GW_SERVER_SIDE_DATABASE_ERROR << " " 
                       << response.options << "U "
                       << "\"(empty)\" "
                       << "0UL "
                       << "\"Error:  Failed to retrieve iRODS object(s) from database\"";


             strcpy(buffer_ptr, temp_strm.str().c_str());


             return 1;

         }  /* |if (status < 0)|  */

@q ****** (6) @>

         else if (status == 0)
         {
             lock_cerr_mutex(); 
             cerr << thread_str 
                  << "WARNING! In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
                  << endl
                  << "`Irods_Object_Type::get_from_database' returned 0 rows."
                  << endl
                  << "Failed to fetch iRODS object with path `" << *iter << "' "
                  << "from `gwirdsif.Irods_Objects' database table."
                  << endl
                  << "Will try to continue."
                  << endl;
             unlock_cerr_mutex();              

             ++warnings_occurred; 

             continue;

         }  /* |else if (status == 0)|  */        

@q ****** (6) @>

         else if (status > 1)
         {
             lock_cerr_mutex(); 
             cerr << thread_str 
                  << "WARNING! In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
                  << endl
                  << "`Irods_Object_Type::get_from_database' returned " << status 
                  << " rows (> 1)."
                  << endl
                  << "This shouldn't be possible."
                  << endl
                  << "Will try to continue."
                  << endl;
             unlock_cerr_mutex();              

             ++warnings_occurred; 

             continue;

         }  /* |else if (status == 0)|  */        

@q ****** (6) @>

#if DEBUG_COMPILE
         else if (DEBUG)
         {
             lock_cerr_mutex(); 
             cerr << thread_str 
                  << "In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
                  << endl
                  << "`Irods_Object_Type::get_from_database' succeeded, returning 1."
                  << endl;
             unlock_cerr_mutex(); 

         }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
       

         if (   (   !(response.options & 4U)
                 && curr_irods_object.marked_for_deletion_from_archive == false)
             || (   (response.options & 2U || response.options & 4U)
                 && curr_irods_object.marked_for_deletion_from_gwirdsif_db == false))
         {
             irods_object_vector.push_back(curr_irods_object);
         }
         else
         {
            lock_cerr_mutex(); 
            cerr << thread_str 
                 << "WARNING! In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
                 << endl
                 << "iRODS object " << curr_irods_object.id << " "
                 << "`" << curr_irods_object.path << "' already marked for deletion."
                 << endl
                 << "Not marking again.  Continuing."
                 << endl;

            unlock_cerr_mutex();              

            temp_strm.str("");

            temp_strm << "MARK IRODS_OBJECT FOR DELETION RESPONSE "
                      << GW_IRODS_OBJECT_ALREADY_MARKED_FOR_DELETION << " "
                      << response.options << "U "
                      << "\"" << curr_irods_object.path << "\" ";

            if (   curr_irods_object.delete_from_archive_timestamp > 0
                && !(response.options & 2U || response.options & 4U))
                temp_strm << curr_irods_object.delete_from_archive_timestamp 
                          << "UL ";
            else if (   curr_irods_object.delete_from_gwirdsif_db_timestamp > 0
                     && (response.options & 2U || response.options & 4U))
                temp_strm << curr_irods_object.delete_from_gwirdsif_db_timestamp 
                          << "UL ";

            else if (   curr_irods_object.delete_from_archive_timestamp 
                     == curr_irods_object.delete_from_gwirdsif_db_timestamp)
                temp_strm << curr_irods_object.delete_from_archive_timestamp 
                          << "UL ";
            else
            {
                /* In this case, the iRODS object is already marked for deletion from 
                   both the archive and the \.{gwirdsif.Irods\_Objects} database table,
                   but the timestamps differ.  There's no way to decide which 
                   timestamp to send, so we just send |0UL|.
                
                   This case shouldn't occur too often, so I'm not going 
                   to bother trying to fix it at present.

                   !! TODO:  Do something about this, maybe.
                   \initials{LDF 2013.08.08.}  */

                temp_strm << "OUL ";
            }


            temp_strm << "\"Error:  iRODS object already marked for deletion\"";

            new_response.type = Response_Type::COMMAND_ONLY_TYPE;

            new_response.command = temp_strm.str();
            response_deque.push_back(new_response);

            ++warnings_occurred; 
 
         }  /* |else|  */

                
         curr_irods_object.clear();

@q ****** (6) @>

   }  /* |for|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition@>=

   if (irods_object_vector.size() == 0)
   {
        lock_cerr_mutex(); 
        cerr << thread_str 
             << "WARNING! In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
             << endl
             << "`irods_object_vector.size()' == 0" 
             << endl
             << "Failed to retrieve any `Irods_Object_Type' objects."
             << endl
             << "Exiting function unsuccessfully with return value 2."
             << endl;
        unlock_cerr_mutex();              

        ++warnings_occurred; 

        return 2;

   }  /* |if (irods_object_vector.size() == 0)|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition@>=

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
            << endl
            << "`irods_object_vector.size()' == " << irods_object_vector.size()
            << endl;

       for (vector<Irods_Object_Type>::iterator iter = irods_object_vector.begin();
            iter != irods_object_vector.end();
            ++iter)
       {
               iter->show();

       }  /* |for|  */

       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 


@q ***** (5) @>

@ The delay value is stored in |delay|.  
It's passed to |Irods_Object_Type::mark_for_deletion| as a reference.
The delay value that's used is |response.delay_value|.
\initials{LDF 2013.08.14.}

@<|Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition@>=

   time_t delay = static_cast<time_t>(0);    

   status = Irods_Object_Type::mark_for_deletion(irods_object_vector, 
                                                 mysql_ptr, 
                                                 response, 
                                                 user_id,
                                                 irods_env_filename,
                                                 delay,
                                                 thread_str, 
                                                 false);

   if (status != 0)
   {
        lock_cerr_mutex(); 
        cerr << thread_str 
             << "ERROR! In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
             << endl
             << "`Irods_Object_Type::mark_for_deletion' failed, returning " << status << "."
             << endl
             << "Exiting function unsuccessfully with return value 1."
             << endl;
        unlock_cerr_mutex();              

        ++errors_occurred; 

        return 1; 

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
            << endl
            << "`Irods_Object_Type::mark_for_deletion' succeeded, returning 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition@>=

   new_response.type = Response_Type::COMMAND_ONLY_TYPE;
   
   for (vector<Irods_Object_Type>::iterator iter = irods_object_vector.begin();
        iter != irods_object_vector.end();
        ++iter)
   {

       temp_strm.str("");

       temp_strm << "MARK IRODS_OBJECT FOR DELETION RESPONSE 0 "
                 << response.options << "U "
                 << "\"" << iter->path << "\" " << delay << "UL \"Success\"";

       new_response.command = temp_strm.str();
       response_deque.push_back(new_response);
   
   }  /* |for|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition@>=

   if (purge_irods_archive_thread_id == static_cast<pthread_t>(0))
   {
       lock_cerr_mutex(); 
       cerr << thread_str 
            << "NOTICE:  In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
            << endl 
            << "`purge_irods_archive_thread_id' == 0:"
            << endl
            << "\"Purge iRODS archive thread\" not running."
            << endl
            << "iRODS objects marked for immediate deletion will "
            << "be deleted the next time `gwirdsif' is started with"
            << endl
            << "purging the iRODS archive enabled."
            << endl
            << "Not calling `pthread_cond_signal'.  Continuing."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if|  */

@q ***** (5) @>

   else 
   {
@q ****** (6) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str 
                << "In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
                << endl 
                << "`purge_irods_archive_thread_id' != 0:"
                << endl
                << "\"Purge iRODS archive thread\" running.  "
                << "Calling `pthread_cond_signal' to wake it up."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

       pthread_mutex_lock(&purge_irods_archive_mutex);

       status = pthread_cond_signal(&purge_irods_archive_cond);

       if (status != 0)
       {
          lock_cerr_mutex(); 
          cerr << thread_str 
               << "ERROR!  In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
               << endl
               << "`pthread_cond_signal' failed, returning " << status << ":"
               << endl
               << "Error:  " << strerror(status)
               << endl
               << "Exiting function unsuccessfully with return value 1." 
               << endl;
          unlock_cerr_mutex(); 

          return 1;

       }

#if DEBUG_COMPILE
       else if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << thread_str << "In `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion':"
                << endl
                << "`pthread_cond_signal' succeeded, returning 0."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

       pthread_mutex_unlock(&purge_irods_archive_mutex); 

   }  /* |else|  */

@q ***** (5) @>
@
@<|Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition@>=

#if DEBUG_COMPILE 
   if (DEBUG)
   {
        lock_cerr_mutex(); 
        cerr << thread_str 
             << "Exiting `Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion' "
             << "successfully with return value 0."
             << endl;
        unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */ 
#endif  /* |DEBUG_COMPILE|  */ 


   return 0;

}  /* End of |Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition  */

@q **** (4) @>


@q *** (3) @>

@q ** (2) @>
@
@<Garbage@>=


@q ** (2) Putting `spptfnc1.web' together.  @>

@ Putting {\tt spptfnc1\PERIOD web} together.

@q *** (3) This is what's compiled.  @>
@ This is what's compiled.
@c
@<Include files@>@;@/
using namespace std;
using namespace gwrdifpk;
@<External function declarations@>@;@/
@<|Scan_Parse_Parameter_Type::get_handle| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_metadata| definition@>@;@/
@<|Scan_Parse_Parameter_Type::add_metadata| definition@>@;@/
@<|Scan_Parse_Parameter_Type::parse_metadata| definition@>@;@/
@<|Scan_Parse_Parameter_Type::fetch_handle_from_database| definition@>@;@/
@<|Scan_Parse_Parameter_Type::fetch_handles_from_database| definition@>@;@/
@<|Scan_Parse_Parameter_Type::store_dc_metadata| definition@>@;@/
@<|Scan_Parse_Parameter_Type::show_certificates| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdsif| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_privileges_gwirdcli| definition@>@;@/
@<|Scan_Parse_Parameter_Type::set_user_info| definition@>@;@/
@<|Scan_Parse_Parameter_Type::show_privileges| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_highest_value| definition@>@;@/
@<|Scan_Parse_Parameter_Type::get_input| definition@>@;@/
@<|Scan_Parse_Parameter_Type::mark_irods_objects_for_deletion| definition@>@;@/

#if 0 
@<Garbage@>@;@/
#endif 

@q *** (3) This is what's written to the header file `spptfnc1.h'.  @>

@ This is what's written to the header file \filename{spptfnc1.h}.
\initials{LDF 2013.02.13.}

@(spptfnc1.h@>=
#ifndef SPPTFNC1_H
#define SPPTFNC1_H 1
1/* Empty  */
#endif 

@q ** (2) @>

@q * (1) Emacs-Lisp code for use in indirect buffers  @>

@q (progn (cweb-mode) (outline-minor-mode))                          @>

@q * (1) Local variables for Emacs @>

@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q abbrev-mode:t @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>
